{
  AffinityTopologyVersion topVer=cctx.mvcc().lastExplicitLockTopologyVersion(Thread.currentThread().getId());
  if (topVer == null && tx != null && tx.system()) {
    IgniteInternalTx tx0=cctx.tm().anyActiveThreadTx(tx);
    if (tx0 != null)     topVer=tx0.topologyVersionSnapshot();
  }
  if (topVer != null && tx != null)   tx.topologyVersion(topVer);
  if (topVer == null && tx != null)   topVer=tx.topologyVersionSnapshot();
  if (topVer != null) {
    for (    GridDhtTopologyFuture fut : cctx.shared().exchange().exchangeFutures()) {
      if (fut.topologyVersion().equals(topVer)) {
        if (!fut.isCacheTopologyValid(cctx)) {
          onDone(new IgniteCheckedException("Failed to perform cache operation (cache topology is not valid): " + cctx.name()));
          return;
        }
        break;
      }
    }
    this.topVer.compareAndSet(null,topVer);
    map(keys,false);
    markInitialized();
    return;
  }
  mapOnTopology(false);
}
