{
  for (int i=0; i < GRID_CNT; i++) {
    final int idx=i;
    final Ignite grid=concurrent ? null : startGrid(idx);
    IgniteInternalFuture<?> fut=multithreadedAsync(new Runnable(){
      @Override public void run(){
        Random rnd=new Random();
        try {
          final Ignite ignite=grid == null ? startGrid(idx) : grid;
          final IgniteCache<UUID,UUID> cache=getCache(ignite).withAsync();
          CacheAffEarlySelfTest.this.execute(cache,new IgniteInClosure<IgniteCache<UUID,UUID>>(){
            @Override public void apply(            IgniteCache<UUID,UUID> entries){
              cache.put(ignite.cluster().localNode().id(),UUID.randomUUID());
            }
          }
);
          while (!stopped) {
            int val=Math.abs(rnd.nextInt(100));
            if (val >= 0 && val < 40)             execute(cache,new IgniteInClosure<IgniteCache<UUID,UUID>>(){
              @Override public void apply(              IgniteCache<UUID,UUID> entries){
                cache.containsKey(ignite.cluster().localNode().id());
              }
            }
);
 else             if (val >= 40 && val < 80)             execute(cache,new IgniteInClosure<IgniteCache<UUID,UUID>>(){
              @Override public void apply(              IgniteCache<UUID,UUID> entries){
                cache.get(ignite.cluster().localNode().id());
              }
            }
);
 else             execute(cache,new IgniteInClosure<IgniteCache<UUID,UUID>>(){
              @Override public void apply(              IgniteCache<UUID,UUID> entries){
                cache.put(ignite.cluster().localNode().id(),UUID.randomUUID());
              }
            }
);
            Thread.sleep(50);
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
,1);
    futs.add(fut);
  }
  Thread.sleep(10000);
  stopped=true;
  for (  IgniteInternalFuture<?> fut : futs)   fut.get();
}
