{
  Iterator<?> valsIter=vals != null ? vals.iterator() : null;
  GridBiTuple<Boolean,V> res=null;
  GridCachePartialUpdateException err=null;
  GridCacheVersion ver=ctx.versions().next();
  for (  K key : keys) {
    Object val=valsIter != null ? valsIter.next() : null;
    if (key == null)     continue;
    while (true) {
      GridCacheEntryEx<K,V> entry=null;
      try {
        entry=entryEx(key);
        GridBiTuple<Boolean,V> t=entry.localUpdate(ver,val == null ? DELETE : op,val,storeEnabled(),retval,ttl,true,true,filter);
        if (res == null)         res=t;
        break;
      }
 catch (      GridCacheEntryRemovedException ignored) {
        if (log.isDebugEnabled())         log.debug("Got removed entry while updating (will retry): " + key);
        entry=null;
      }
catch (      GridException e) {
        if (err == null)         err=new GridCachePartialUpdateException("Failed to update keys " + "(retry update if possible).");
        err.add(F.asList(key),e);
        U.error(log,"Failed to update key : " + key,e);
        break;
      }
 finally {
        if (entry != null)         ctx.evicts().touch(entry);
      }
    }
  }
  if (err != null)   throw err;
  return res == null ? null : rawRetval ? new GridCacheReturn<>(res.get2(),res.get1()) : retval ? res.get2() : res.get1();
}
