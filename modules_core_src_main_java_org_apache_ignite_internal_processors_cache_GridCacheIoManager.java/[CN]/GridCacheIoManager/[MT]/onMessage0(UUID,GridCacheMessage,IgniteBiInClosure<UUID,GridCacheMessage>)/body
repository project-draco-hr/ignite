{
  rw.readLock();
  try {
    if (stopping) {
      if (log.isDebugEnabled())       log.debug("Received cache communication message while stopping (will ignore) [nodeId=" + nodeId + ", msg="+ cacheMsg+ ']');
      return;
    }
    if (depEnabled)     cctx.deploy().ignoreOwnership(true);
    unmarshall(nodeId,cacheMsg);
    if (cacheMsg.classError() != null)     processFailedMessage(nodeId,cacheMsg);
 else {
      if (cacheMsg.allowForStartup())       processMessage(nodeId,cacheMsg,c);
 else {
        IgniteInternalFuture<?> startFut=startFuture(cacheMsg);
        if (startFut.isDone())         processMessage(nodeId,cacheMsg,c);
 else {
          if (log.isDebugEnabled())           log.debug("Waiting for start future to complete for message [nodeId=" + nodeId + ", locId="+ cctx.localNodeId()+ ", msg="+ cacheMsg+ ']');
          startFut.listen(new CI1<IgniteInternalFuture<?>>(){
            @Override public void apply(            final IgniteInternalFuture<?> f){
              cctx.kernalContext().closure().runLocalSafe(new GridPlainRunnable(){
                @Override public void run(){
                  rw.readLock();
                  try {
                    if (stopping) {
                      if (log.isDebugEnabled())                       log.debug("Received cache communication message while stopping " + "(will ignore) [nodeId=" + nodeId + ", msg="+ cacheMsg+ ']');
                      return;
                    }
                    f.get();
                    if (log.isDebugEnabled())                     log.debug("Start future completed for message [nodeId=" + nodeId + ", locId="+ cctx.localNodeId()+ ", msg="+ cacheMsg+ ']');
                    processMessage(nodeId,cacheMsg,c);
                  }
 catch (                  IgniteCheckedException e) {
                    if (startErr.compareAndSet(false,true))                     U.error(log,"Failed to complete preload start future " + "(will ignore message) " + "[fut=" + f + ", nodeId="+ nodeId+ ", msg="+ cacheMsg+ ']',e);
                  }
 finally {
                    rw.readUnlock();
                  }
                }
              }
);
            }
          }
);
        }
      }
    }
  }
 catch (  Throwable e) {
    U.error(log,"Failed to process message [senderId=" + nodeId + ", messageType="+ cacheMsg.getClass()+ ']',e);
    if (e instanceof Error)     throw (Error)e;
  }
 finally {
    if (depEnabled)     cctx.deploy().ignoreOwnership(false);
    rw.readUnlock();
  }
}
