{
  GridCacheContext ctx=cctx.cacheContext(msg.cacheId());
switch (msg.directType()) {
case 14:
{
      GridCacheEvictionRequest req=(GridCacheEvictionRequest)msg;
      GridCacheEvictionResponse res=new GridCacheEvictionResponse(ctx.cacheId(),req.futureId(),req.classError() != null);
      sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
    }
  break;
case 30:
{
  GridDhtLockRequest req=(GridDhtLockRequest)msg;
  GridDhtLockResponse res=new GridDhtLockResponse(ctx.cacheId(),req.version(),req.futureId(),req.miniId(),0);
  sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
}
break;
case 34:
{
GridDhtTxPrepareRequest req=(GridDhtTxPrepareRequest)msg;
GridDhtTxPrepareResponse res=new GridDhtTxPrepareResponse(req.version(),req.futureId(),req.miniId());
res.error(req.classError());
sendResponseOnFailedMessage(nodeId,res,cctx,req.policy());
}
break;
case 38:
{
GridDhtAtomicUpdateRequest req=(GridDhtAtomicUpdateRequest)msg;
GridDhtAtomicUpdateResponse res=new GridDhtAtomicUpdateResponse(ctx.cacheId(),req.futureVersion());
res.onError(req.classError());
sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
}
break;
case 40:
{
GridNearAtomicUpdateRequest req=(GridNearAtomicUpdateRequest)msg;
GridNearAtomicUpdateResponse res=new GridNearAtomicUpdateResponse(ctx.cacheId(),nodeId,req.futureVersion());
res.error(req.classError());
sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
}
break;
case 42:
{
GridDhtForceKeysRequest req=(GridDhtForceKeysRequest)msg;
GridDhtForceKeysResponse res=new GridDhtForceKeysResponse(ctx.cacheId(),req.futureId(),req.miniId());
res.error(req.classError());
sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
}
break;
case 45:
{
GridDhtPartitionSupplyMessage req=(GridDhtPartitionSupplyMessage)msg;
U.error(log,"Supply message cannot be unmarshalled.",req.classError());
}
break;
case 49:
{
GridNearGetRequest req=(GridNearGetRequest)msg;
GridNearGetResponse res=new GridNearGetResponse(ctx.cacheId(),req.futureId(),req.miniId(),req.version());
res.error(req.classError());
sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
}
break;
case 50:
{
GridNearGetResponse res=(GridNearGetResponse)msg;
GridCacheFuture fut=ctx.mvcc().future(res.version(),res.futureId());
if (fut == null) {
if (log.isDebugEnabled()) log.debug("Failed to find future for get response [sender=" + nodeId + ", res="+ res+ ']');
return;
}
res.error(res.classError());
if (fut instanceof GridNearGetFuture) ((GridNearGetFuture)fut).onResult(nodeId,res);
 else ((GridPartitionedGetFuture)fut).onResult(nodeId,res);
}
break;
case 51:
{
GridNearLockRequest req=(GridNearLockRequest)msg;
GridNearLockResponse res=new GridNearLockResponse(ctx.cacheId(),req.version(),req.futureId(),req.miniId(),false,0,req.classError(),null);
sendResponseOnFailedMessage(nodeId,res,cctx,ctx.ioPolicy());
}
break;
case 55:
{
GridNearTxPrepareRequest req=(GridNearTxPrepareRequest)msg;
GridNearTxPrepareResponse res=new GridNearTxPrepareResponse(req.version(),req.futureId(),req.miniId(),req.version(),req.version(),null,null,null);
res.error(req.classError());
sendResponseOnFailedMessage(nodeId,res,cctx,req.policy());
}
break;
default :
throw new IgniteCheckedException("Failed to send response to node. Unsupported direct type [message=" + msg + "]");
}
}
