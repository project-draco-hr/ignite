{
  final RoundRobinLoadBalancingSpi spi=getSpi();
  final List<ClusterNode> allNodes=(List<ClusterNode>)getSpiContext().nodes();
  GridTestUtils.runMultiThreaded(new Callable<Object>(){
    @Override public Object call() throws Exception {
      ComputeTaskSession ses=new GridTestTaskSession(IgniteUuid.randomUuid());
      Map<UUID,AtomicInteger> nodeCnts=new HashMap<>();
      for (int i=1; i <= ITER_CNT; i++) {
        ClusterNode node=spi.getBalancedNode(ses,allNodes,new GridTestJob());
        if (!nodeCnts.containsKey(node.id()))         nodeCnts.put(node.id(),new AtomicInteger(1));
 else         nodeCnts.get(node.id()).incrementAndGet();
      }
      int predictCnt=ITER_CNT / allNodes.size();
      int floor=(int)(predictCnt * 0.8);
      double avgSpread=0;
      for (      ClusterNode n : allNodes) {
        int curCnt=nodeCnts.get(n.id()).intValue();
        avgSpread+=Math.abs(predictCnt - curCnt);
        String msg="Node stats [id=" + n.id() + ", cnt="+ curCnt+ ", floor="+ floor+ ", predictCnt="+ predictCnt+ ']';
        info(msg);
        assertTrue(msg,curCnt >= floor);
      }
      avgSpread/=allNodes.size();
      avgSpread=100.0 * avgSpread / predictCnt;
      info("Average spread for " + allNodes.size() + " nodes is "+ avgSpread+ " percents");
      assertTrue("Average spread is too big: " + avgSpread,avgSpread <= 10);
      return null;
    }
  }
,THREAD_CNT,"balancer-test-worker");
}
