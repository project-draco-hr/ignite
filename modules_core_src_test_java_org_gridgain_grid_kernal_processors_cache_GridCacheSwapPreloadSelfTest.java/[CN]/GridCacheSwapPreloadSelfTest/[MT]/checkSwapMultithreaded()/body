{
  final AtomicBoolean done=new AtomicBoolean();
  GridFuture<?> fut=null;
  try {
    startGrid(0);
    final GridCache<Integer,Integer> cache=grid(0).cache(null);
    assertNotNull(cache);
    for (int i=0; i < ENTRY_CNT; i++)     cache.put(i,i);
    cache.evictAll();
    fut=multithreadedAsync(new Callable<Object>(){
      @Nullable @Override public Object call() throws Exception {
        Random rnd=new Random();
        while (!done.get()) {
          int key=rnd.nextInt(ENTRY_CNT);
          Integer i=cache.get(key);
          assertNotNull(i);
          assertEquals(Integer.valueOf(key),i);
          boolean b=cache.evict(rnd.nextInt(ENTRY_CNT));
          assert b;
        }
        return null;
      }
    }
,10);
    startGrid(1);
    done.set(true);
    int size=grid(1).cache(null).size();
    info("New node cache size: " + size);
    if (size != ENTRY_CNT) {
      Iterable<Integer> keySet=new TreeSet<>(grid(1).<Integer,Integer>cache(null).keySet());
      int next=0;
      for (      Integer i : keySet) {
        while (next < i)         info("Missing key: " + next++);
        next++;
      }
    }
    assertEquals(ENTRY_CNT,size);
  }
  finally {
    done.set(true);
    try {
      if (fut != null)       fut.get();
    }
  finally {
      stopAllGrids();
    }
  }
}
