{
  if (dataCachePrj.ggfsDataSpaceUsed() >= dataCachePrj.ggfsDataSpaceMax()) {
    try {
      ggfs.awaitDeletesAsync().get(trashPurgeTimeout);
    }
 catch (    IgniteFutureTimeoutCheckedException ignore) {
    }
    if (dataCachePrj.ggfsDataSpaceUsed() >= dataCachePrj.ggfsDataSpaceMax()) {
      final WriteCompletionFuture completionFut=pendingWrites.get(fileId);
      if (completionFut == null) {
        if (log.isDebugEnabled())         log.debug("Missing completion future for file write request (most likely exception occurred " + "which will be thrown upon stream close) [fileId=" + fileId + ']');
        return;
      }
      IgfsOutOfSpaceException e=new IgfsOutOfSpaceException("Failed to write data block " + "(GGFS maximum data size exceeded) [used=" + dataCachePrj.ggfsDataSpaceUsed() + ", allowed="+ dataCachePrj.ggfsDataSpaceMax()+ ']');
      completionFut.onDone(new IgniteCheckedException("Failed to write data (not enough space on node): " + ggfsCtx.kernalContext().localNodeId(),e));
      return;
    }
  }
  if (colocatedKey.affinityKey() == null) {
    dataCachePrj.invoke(colocatedKey,new UpdateProcessor(startOff,data));
    return;
  }
  if (startOff == 0) {
    dataCachePrj.putx(colocatedKey,data);
    return;
  }
  IgfsBlockKey key=new IgfsBlockKey(colocatedKey.getFileId(),null,colocatedKey.evictExclude(),colocatedKey.getBlockId());
  try (IgniteInternalTx tx=dataCachePrj.txStartEx(PESSIMISTIC,REPEATABLE_READ)){
    Map<IgfsBlockKey,byte[]> vals=dataCachePrj.getAll(F.asList(colocatedKey,key));
    boolean hasVal=false;
    UpdateProcessor transformClos=new UpdateProcessor(startOff,data);
    if (vals.get(colocatedKey) != null) {
      dataCachePrj.invoke(colocatedKey,transformClos);
      hasVal=true;
    }
    if (vals.get(key) != null) {
      dataCachePrj.invoke(key,transformClos);
      hasVal=true;
    }
    if (!hasVal)     throw new IgniteCheckedException("Failed to write partial block (no previous data was found in cache) " + "[key=" + colocatedKey + ", relaxedKey="+ key+ ", startOff="+ startOff+ ", dataLen="+ data.length+ ']');
    tx.commit();
  }
 }
