{
  GridCacheTxState state=state();
  if (state != ROLLING_BACK && state != ROLLED_BACK) {
    setRollbackOnly();
    throw new GridException("Invalid transaction state for rollback [state=" + state + ", tx="+ this+ ']',commitErr.get());
  }
  if (doneFlag.compareAndSet(false,true)) {
    try {
      if (near())       for (      GridCacheTxEntry<K,V> e : allEntries())       evictNearEntry(e,false);
      cctx.tm().rollbackTx(this);
      GridCacheStoreManager<K,V> store=cctx.store();
      if (store.configured() && (isSingleUpdate() || isBatchUpdate())) {
        if (!internal() || groupLock())         store.txEnd(this,false);
      }
    }
 catch (    Error|RuntimeException e) {
      U.addLastCause(e,commitErr.get(),log);
      throw e;
    }
  }
}
