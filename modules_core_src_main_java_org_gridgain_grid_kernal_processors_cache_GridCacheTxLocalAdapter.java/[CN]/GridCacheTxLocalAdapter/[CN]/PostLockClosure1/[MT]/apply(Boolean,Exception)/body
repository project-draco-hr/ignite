{
  if (e != null) {
    setRollbackOnly();
    if (commit && commitAfterLock())     return rollbackAsync().chain(new C1<IgniteFuture<GridCacheTx>,T>(){
      @Override public T apply(      IgniteFuture<GridCacheTx> f){
        throw new GridClosureException(e);
      }
    }
);
    throw new GridClosureException(e);
  }
  if (!locked) {
    setRollbackOnly();
    final GridClosureException ex=new GridClosureException(new GridCacheTxTimeoutException("Failed to " + "acquire lock within provided timeout for transaction [timeout=" + timeout() + ", tx="+ this+ ']'));
    if (commit && commitAfterLock())     return rollbackAsync().chain(new C1<IgniteFuture<GridCacheTx>,T>(){
      @Override public T apply(      IgniteFuture<GridCacheTx> f){
        throw ex;
      }
    }
);
    throw ex;
  }
  boolean rollback=true;
  try {
    final T r=postLock(arg);
    if (commit && commitAfterLock()) {
      rollback=false;
      return commitAsync().chain(new CX1<IgniteFuture<GridCacheTx>,T>(){
        @Override public T applyx(        IgniteFuture<GridCacheTx> f) throws GridException {
          f.get();
          return r;
        }
      }
);
    }
    rollback=false;
    return new GridFinishedFuture<>(cctx.kernalContext(),r);
  }
 catch (  final GridException ex) {
    if (commit && commitAfterLock())     return rollbackAsync().chain(new C1<IgniteFuture<GridCacheTx>,T>(){
      @Override public T apply(      IgniteFuture<GridCacheTx> f){
        throw new GridClosureException(ex);
      }
    }
);
    throw new GridClosureException(ex);
  }
 finally {
    if (rollback)     setRollbackOnly();
  }
}
