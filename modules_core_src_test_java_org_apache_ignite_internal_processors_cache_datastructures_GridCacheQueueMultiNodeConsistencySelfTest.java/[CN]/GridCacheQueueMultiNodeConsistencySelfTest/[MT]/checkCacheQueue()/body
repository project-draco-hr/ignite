{
  startGrids(GRID_CNT);
  final String queueName=UUID.randomUUID().toString();
  CacheQueue<Integer> queue0=grid(0).cache(null).dataStructures().queue(queueName,QUEUE_CAPACITY,false,true);
  assertTrue(queue0.isEmpty());
  grid(0).compute().broadcast(new AddAllJob(queueName,RETRIES));
  assertEquals(GRID_CNT * RETRIES,queue0.size());
  if (stopRandomGrid)   stopGrid(1 + new Random().nextInt(GRID_CNT));
  if (forceRepartition)   for (int i=0; i < GRID_CNT; i++)   grid(i).cache(null).forceRepartition();
  Ignite newIgnite=startGrid(GRID_CNT + 1);
  Collection<Integer> locQueueContent=compute(newIgnite.cluster().forLocal()).call(new IgniteCallable<Collection<Integer>>(){
    @IgniteInstanceResource private Ignite grid;
    /** 
 * {@inheritDoc} 
 */
    @Override public Collection<Integer> call() throws Exception {
      Collection<Integer> values=new ArrayList<>();
      grid.log().info("Running job [node=" + grid.cluster().localNode().id() + ", job="+ this+ "]");
      CacheQueue<Integer> locQueue=grid.cache(null).dataStructures().queue(queueName,QUEUE_CAPACITY,false,true);
      grid.log().info("Queue size " + locQueue.size());
      for (      Integer element : locQueue)       values.add(element);
      return values;
    }
  }
);
  assertTrue(CollectionUtils.isEqualCollection(queue0,locQueueContent));
  grid(0).cache(null).dataStructures().removeQueue(queueName);
}
