{
  for (  Map.Entry<GridCacheInternal,GridCacheRemovable> e : dsMap.entrySet()) {
    final GridCacheRemovable v=e.getValue();
    if (v instanceof GridCacheQueue) {
      final GridCacheInternal key=e.getKey();
      GridCacheProjectionEx<GridCacheInternal,GridCacheInternal> cache=(GridCacheProjectionEx<GridCacheInternal,GridCacheInternal>)cctx.cache();
      GridFuture<GridCacheInternal> fut=cache.getForcePrimaryAsync(key);
      fut.listenAsync(new CI1<GridFuture<GridCacheInternal>>(){
        @Override public void apply(        GridFuture<GridCacheInternal> f){
          if (queueBusyLock.enterBusy()) {
            try {
              GridCacheQueueHeader hdr=cast(f.get(),GridCacheQueueHeader.class);
              if (hdr != null) {
                GridCacheQueueEx queue=cast(v,GridCacheQueueEx.class);
                queue.onHeaderChanged(hdr);
              }
 else               if (v != null)               queueDelCands.add(key);
            }
 catch (            GridException ex) {
              U.error(log,"Failed to synchronize queue state (will invalidate the queue): " + v,ex);
              v.onInvalid(ex);
            }
 finally {
              queueBusyLock.leaveBusy();
            }
          }
 else           U.warn(log,"Partition change callback is ignored because grid is stopping.");
        }
      }
);
    }
  }
}
