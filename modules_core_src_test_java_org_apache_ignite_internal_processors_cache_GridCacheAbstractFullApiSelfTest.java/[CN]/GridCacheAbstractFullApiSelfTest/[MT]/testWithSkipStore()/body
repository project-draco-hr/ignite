{
  IgniteCache<String,Integer> cache=grid(0).cache(null);
  IgniteCache<String,Integer> cacheSkipStore=cache.withSkipStore();
  List<String> keys=primaryKeysForCache(cache,10);
  for (int i=0; i < keys.size(); ++i)   putToStore(keys.get(i),i);
  assertFalse(cacheSkipStore.iterator().hasNext());
  for (  String key : keys) {
    assertNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
  }
  for (  String key : keys) {
    cacheSkipStore.remove(key);
    assertNotNull(cache.get(key));
  }
  cache.removeAll();
  for (  String key : keys)   assertNull(cache.get(key));
  keys=new ArrayList<>(1000);
  for (int i=0; i < 1000; i++)   keys.add("key_" + i);
  for (int i=0; i < keys.size(); ++i)   cache.put(keys.get(i),i);
  for (  String key : keys) {
    assertNotNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertTrue(map.containsKey(key));
  }
  for (  String key : keys) {
    cacheSkipStore.remove(key);
    assertNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertTrue(map.containsKey(key));
  }
  for (  String key : keys) {
    cache.remove(key);
    assertNull(cacheSkipStore.get(key));
    assertNull(cache.get(key));
    assertFalse(map.containsKey(key));
  }
  assertFalse(cacheSkipStore.iterator().hasNext());
  assertTrue(map.size() == 0);
  assertTrue(cache.size(CachePeekMode.ALL) == 0);
  Map<String,Integer> data=new HashMap<>();
  for (int i=0; i < keys.size(); i++)   data.put(keys.get(i),i);
  cacheSkipStore.putAll(data);
  for (  String key : keys) {
    assertNotNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertFalse(map.containsKey(key));
  }
  cache.putAll(data);
  for (  String key : keys) {
    assertNotNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertTrue(map.containsKey(key));
  }
  cacheSkipStore.removeAll(data.keySet());
  for (  String key : keys) {
    assertNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertTrue(map.containsKey(key));
  }
  cacheSkipStore.putAll(data);
  for (  String key : keys) {
    assertNotNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertTrue(map.containsKey(key));
  }
  cacheSkipStore.removeAll();
  for (  String key : keys) {
    assertNull(cacheSkipStore.get(key));
    assertNotNull(cache.get(key));
    assertTrue(map.containsKey(key));
  }
  cache.removeAll(data.keySet());
  for (  String key : keys) {
    assertNull(cacheSkipStore.get(key));
    assertNull(cache.get(key));
    assertFalse(map.containsKey(key));
  }
  assertTrue(map.size() == 0);
  String newKey="New key";
  assertFalse(map.containsKey(newKey));
  cacheSkipStore.put(newKey,1);
  assertFalse(map.containsKey(newKey));
  cache.put(newKey,1);
  assertTrue(map.containsKey(newKey));
  Iterator<Cache.Entry<String,Integer>> it=cacheSkipStore.iterator();
  assertTrue(it.hasNext());
  Cache.Entry<String,Integer> entry=it.next();
  String rmvKey=entry.getKey();
  assertTrue(map.containsKey(rmvKey));
  it.remove();
  assertNull(cacheSkipStore.get(rmvKey));
  assertTrue(map.containsKey(rmvKey));
  assertTrue(cache.size(CachePeekMode.ALL) == 0);
  assertTrue(cacheSkipStore.size(CachePeekMode.ALL) == 0);
  cache.remove(rmvKey);
  assertTrue(map.size() == 0);
  if (atomicityMode() == CacheAtomicityMode.TRANSACTIONAL) {
    checkSkipStoreWithTransaction(cache,cacheSkipStore,data,keys,TransactionConcurrency.OPTIMISTIC,TransactionIsolation.READ_COMMITTED);
    checkSkipStoreWithTransaction(cache,cacheSkipStore,data,keys,TransactionConcurrency.OPTIMISTIC,TransactionIsolation.REPEATABLE_READ);
    checkSkipStoreWithTransaction(cache,cacheSkipStore,data,keys,TransactionConcurrency.OPTIMISTIC,TransactionIsolation.SERIALIZABLE);
    checkSkipStoreWithTransaction(cache,cacheSkipStore,data,keys,TransactionConcurrency.PESSIMISTIC,TransactionIsolation.READ_COMMITTED);
    checkSkipStoreWithTransaction(cache,cacheSkipStore,data,keys,TransactionConcurrency.PESSIMISTIC,TransactionIsolation.REPEATABLE_READ);
    checkSkipStoreWithTransaction(cache,cacheSkipStore,data,keys,TransactionConcurrency.PESSIMISTIC,TransactionIsolation.SERIALIZABLE);
  }
}
