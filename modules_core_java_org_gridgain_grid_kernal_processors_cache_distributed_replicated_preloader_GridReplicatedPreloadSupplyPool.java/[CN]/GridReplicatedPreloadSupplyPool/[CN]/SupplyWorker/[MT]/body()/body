{
  long preloadThrottle=cctx.config().getPreloadThrottle();
  while (!isCancelled()) {
    DemandMessage<K,V> msg=take(queue,this);
    GridNode node=cctx.discovery().node(msg.senderId());
    if (node == null) {
      if (log.isDebugEnabled())       log.debug("Received message from non-existing node (will ignore): " + msg);
      continue;
    }
    GridReplicatedPreloadDemandMessage<K,V> d=msg.message();
    if (!preloadFinished.apply()) {
      GridReplicatedPreloadSupplyMessage<K,V> s=new GridReplicatedPreloadSupplyMessage<>(d.workerId(),true);
      try {
        reply(node,d,s);
      }
 catch (      GridException e) {
        U.error(log,"Failed to send supply message to node: " + node.id(),e);
      }
      continue;
    }
    GridFuture<?> fut=cctx.partitionReleaseFuture(Collections.singleton(d.partition()),node.order());
    try {
      fut.get(d.timeout());
    }
 catch (    GridException e) {
      U.error(log,"Failed to wait until partition is released: " + d.partition(),e);
      continue;
    }
    GridReplicatedPreloadSupplyMessage<K,V> s=new GridReplicatedPreloadSupplyMessage<>(d.workerId());
    SwapListener<K,V> swapLsnr=null;
    boolean nodeLeft=false;
    try {
      boolean swapEnabled=cctx.isSwapOrOffheapEnabled();
      if (swapEnabled) {
        swapLsnr=new SwapListener<>();
        cctx.swap().addOffHeapListener(d.partition(),swapLsnr);
        cctx.swap().addSwapListener(d.partition(),swapLsnr);
      }
      for (      GridCacheEntryEx<K,V> entry : cctx.cache().allEntries()) {
        if (U.safeAbs(entry.hashCode() % d.nodeCount()) != d.mod() || cctx.affinity().partition(entry.key()) != d.partition())         continue;
        GridCacheEntryInfo<K,V> info=entry.info();
        if (s.size() >= cctx.config().getPreloadBatchSize()) {
          if (!reply(node,d,s)) {
            nodeLeft=true;
            break;
          }
          if (preloadThrottle > 0)           U.sleep(preloadThrottle);
          s=new GridReplicatedPreloadSupplyMessage<>(d.workerId());
        }
        if (info != null && !(info.key() instanceof GridPartitionLockKey) && !info.isNew()) {
          if (preloadPred == null || preloadPred.apply(info))           s.addEntry(info,cctx);
 else           if (log.isDebugEnabled())           log.debug("Preload predicate evaluated to false (will not sender cache entry): " + info);
        }
      }
      if (swapEnabled) {
        GridCloseableIterator<Map.Entry<byte[],GridCacheSwapEntry<V>>> iter=cctx.swap().iterator(d.partition());
        if (iter != null) {
          try {
            boolean prepared=false;
            for (            Map.Entry<byte[],GridCacheSwapEntry<V>> e : iter) {
              GridCacheSwapEntry<V> swapEntry=e.getValue();
              if (U.safeAbs(swapEntry.keyHash() % d.nodeCount()) != d.mod())               continue;
              if (s.size() >= cctx.config().getPreloadBatchSize()) {
                if (!reply(node,d,s)) {
                  nodeLeft=true;
                  break;
                }
                if (preloadThrottle > 0)                 U.sleep(preloadThrottle);
                s=new GridReplicatedPreloadSupplyMessage<>(d.workerId());
              }
              GridCacheEntryInfo<K,V> info=new GridCacheEntryInfo<>();
              info.keyBytes(e.getKey());
              info.valueBytes(swapEntry.valueBytes());
              info.ttl(swapEntry.ttl());
              info.expireTime(swapEntry.expireTime());
              info.version(swapEntry.version());
              if (preloadPred == null || preloadPred.apply(info))               s.addEntry0(info,cctx);
 else {
                if (log.isDebugEnabled())                 log.debug("Preload predicate evaluated to false (will not send " + "cache entry): " + info);
                continue;
              }
              if (depEnabled && !prepared) {
                ClassLoader ldr=swapEntry.keyClassLoaderId() != null ? cctx.deploy().getClassLoader(swapEntry.keyClassLoaderId()) : swapEntry.valueClassLoaderId() != null ? cctx.deploy().getClassLoader(swapEntry.valueClassLoaderId()) : null;
                if (ldr == null)                 continue;
                if (ldr instanceof GridDeploymentInfo) {
                  s.prepare((GridDeploymentInfo)ldr);
                  prepared=true;
                }
              }
            }
          }
  finally {
            iter.close();
          }
        }
        cctx.swap().removeSwapListener(d.partition(),swapLsnr);
        Collection<GridCacheEntryInfo<K,V>> entries=swapLsnr.entries();
        swapLsnr=null;
        for (        GridCacheEntryInfo<K,V> info : entries) {
          if (s.size() >= cctx.config().getPreloadBatchSize()) {
            if (!reply(node,d,s)) {
              nodeLeft=true;
              break;
            }
            s=new GridReplicatedPreloadSupplyMessage<>(d.workerId());
          }
          if (preloadPred == null || preloadPred.apply(info))           s.addEntry(info,cctx);
 else {
            if (log.isDebugEnabled())             log.debug("Preload predicate evaluated to false (will not sender cache entry): " + info);
          }
        }
      }
      if (!nodeLeft) {
        s.last(true);
        reply(node,d,s);
      }
    }
 catch (    GridException e) {
      U.error(log,"Failed to send supply message to node: " + node.id(),e);
      cctx.io().removeMessageId(d.topic());
    }
 finally {
      if (swapLsnr != null)       cctx.swap().removeSwapListener(d.partition(),swapLsnr);
      if (s.last() || nodeLeft) {
        cctx.io().removeMessageId(d.topic());
      }
    }
  }
}
