{
  while (!isCancelled()) {
    U.sleep(checkPntFreq);
    if (!updatedAfterCheckPnt)     continue;
    updatedAfterCheckPnt=false;
    long t=U.currentTimeMillis();
    Path file=dir.resolve(t + FILE_EXTENSION);
    try {
      head.fsync();
      ObjectOutputStream out=new ObjectOutputStream(new BufferedOutputStream(Files.newOutputStream(file,CREATE_NEW,DSYNC)));
      Collection<DataCenterStream> streams=streams();
      out.writeShort(MAGIC);
      out.writeInt(streams.size());
      LogPos min=null;
      for (      DataCenterStream s : streams) {
        out.writeByte(s.id);
        LogPos p=s.position();
        if (min == null || min.compareTo(p) > 0)         min=p;
        out.writeLong(p.file.id);
        out.writeLong(p.off);
        out.writeLong(s.size());
        out.writeShort(MAGIC);
      }
      out.flush();
      out.close();
      checkPoints.addLast(file);
      for (      LogFile logFile : files.headSet(min.file,false)) {
        try {
          delete(logFile);
        }
 catch (        GridException e) {
          U.error(log,"Failed to delete file: " + file,e);
        }
      }
      while (checkPoints.size() > 5)       Files.deleteIfExists(checkPoints.pollFirst());
    }
 catch (    IOException e) {
      U.error(log,"Failed to create checkpoint: " + file,e);
    }
  }
}
