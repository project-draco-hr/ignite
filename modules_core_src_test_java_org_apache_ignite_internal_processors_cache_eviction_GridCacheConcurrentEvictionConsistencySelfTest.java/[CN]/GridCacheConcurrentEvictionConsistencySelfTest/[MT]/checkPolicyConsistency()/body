{
  try {
    final Ignite ignite=startGrid(1);
    final IgniteCache<Integer,Integer> cache=ignite.cache(null);
    long start=System.currentTimeMillis();
    IgniteInternalFuture<?> fut=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        final Random rnd=new Random();
        for (int i=0; i < ITERATION_CNT; i++) {
          int j=rnd.nextInt(keyCnt);
          try (Transaction tx=ignite.transactions().txStart()){
            if (rnd.nextBoolean())             cache.put(j,j);
 else             cache.remove(j);
            tx.commit();
          }
           if (i != 0 && i % 5000 == 0)           info("Stats [iterCnt=" + i + ", size="+ cache.size()+ ']');
        }
        return null;
      }
    }
,threadCnt);
    fut.get();
    Collection<EvictableEntry<Integer,Integer>> queue=internalQueue(plc);
    info("Test results [threadCnt=" + threadCnt + ", iterCnt="+ ITERATION_CNT+ ", cacheSize="+ cache.size()+ ", internalQueueSize"+ queue.size()+ ", duration="+ (System.currentTimeMillis() - start)+ ']');
    boolean detached=false;
    for (    Cache.Entry<Integer,Integer> e : queue) {
      Integer rmv=cache.getAndRemove(e.getKey());
      CacheEvictableEntryImpl unwrapped=e.unwrap(CacheEvictableEntryImpl.class);
      if (rmv == null && (unwrapped.meta() != null || unwrapped.isCached())) {
        U.warn(log,"Detached entry: " + e);
        detached=true;
      }
 else       info("Entry removed: " + rmv);
    }
    if (detached)     fail("Eviction policy contains keys that are not present in cache");
    if (!(cache.localSize() == 0)) {
      boolean zombies=false;
      for (      Cache.Entry<Integer,Integer> e : cache) {
        U.warn(log,"Zombie entry: " + e);
        zombies=true;
      }
      if (zombies)       fail("Cache contained zombie entries.");
    }
 else     info("Cache is empty after test.");
  }
  finally {
    stopAllGrids();
  }
}
