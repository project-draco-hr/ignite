{
  cache.topology().readLock();
  AffinityTopologyVersion topVer=null;
  try {
    if (cache.topology().stopping()) {
      onDone(new IgniteCheckedException("Failed to perform cache operation (cache is stopped): " + cache.name()));
      return;
    }
    GridDhtTopologyFuture fut=cctx.topologyVersionFuture();
    if (fut.isDone()) {
      topVer=fut.topologyVersion();
      if (futVer == null)       futVer=cctx.versions().next(topVer);
    }
 else {
      if (waitTopFut) {
        fut.listen(new CI1<IgniteInternalFuture<AffinityTopologyVersion>>(){
          @Override public void apply(          IgniteInternalFuture<AffinityTopologyVersion> t){
            mapOnTopology(keys,remap,oldNodeId,waitTopFut);
          }
        }
);
      }
 else       onDone(new GridCacheTryPutFailedException());
      return;
    }
    mapTime=U.currentTimeMillis();
    if (!remap && (cctx.config().getAtomicWriteOrderMode() == CLOCK || syncMode != FULL_ASYNC))     cctx.mvcc().addAtomicFuture(version(),this);
  }
  finally {
    cache.topology().readUnlock();
  }
  map0(topVer,keys,remap,oldNodeId);
}
