{
  if (futVer != null)   cctx.mvcc().removeAtomicFuture(version());
  Collection<Object> remapKeys=new ArrayList<>(failed.size());
  Collection<Object> remapVals=vals != null ? new ArrayList<>(failed.size()) : null;
  Collection<GridCacheDrInfo> remapConflictPutVals=conflictPutVals != null ? new ArrayList<GridCacheDrInfo>(failed.size()) : null;
  Collection<GridCacheVersion> remapConflictRmvVals=conflictRmvVals != null ? new ArrayList<GridCacheVersion>(failed.size()) : null;
  Iterator<?> keyIt=keys.iterator();
  Iterator<?> valsIt=vals != null ? vals.iterator() : null;
  Iterator<GridCacheDrInfo> conflictPutValsIt=conflictPutVals != null ? conflictPutVals.iterator() : null;
  Iterator<GridCacheVersion> conflictRmvValsIt=conflictRmvVals != null ? conflictRmvVals.iterator() : null;
  for (  Object key : failed) {
    while (keyIt.hasNext()) {
      Object nextKey=keyIt.next();
      Object nextVal=valsIt != null ? valsIt.next() : null;
      GridCacheDrInfo nextConflictPutVal=conflictPutValsIt != null ? conflictPutValsIt.next() : null;
      GridCacheVersion nextConflictRmvVal=conflictRmvValsIt != null ? conflictRmvValsIt.next() : null;
      if (F.eq(key,nextKey)) {
        remapKeys.add(nextKey);
        if (remapVals != null)         remapVals.add(nextVal);
        if (remapConflictPutVals != null)         remapConflictPutVals.add(nextConflictPutVal);
        if (remapConflictRmvVals != null)         remapConflictRmvVals.add(nextConflictRmvVal);
        break;
      }
    }
  }
  keys=remapKeys;
  vals=remapVals;
  conflictPutVals=remapConflictPutVals;
  conflictRmvVals=remapConflictRmvVals;
  single=null;
  futVer=null;
  err=null;
  opRes=null;
  GridFutureAdapter<Void> fut0;
synchronized (this) {
    mappings=new ConcurrentHashMap8<>(keys.size(),1.0f);
    topVer=AffinityTopologyVersion.ZERO;
    fut0=topCompleteFut;
    topCompleteFut=null;
  }
  if (fut0 != null)   fut0.onDone();
  singleNodeId=null;
  singleReq=null;
  fastMapRemap=false;
  updVer=null;
  topLocked=false;
  map();
}
