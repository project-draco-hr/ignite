{
  cache.topology().readLock();
  AffinityTopologyVersion topVer=null;
  try {
    if (cache.topology().stopping()) {
      onDone(new IgniteCheckedException("Failed to perform cache operation (cache is stopped): " + cache.name()));
      return;
    }
    GridDhtTopologyFuture fut=cctx.topologyVersionFuture();
    if (fut.isDone()) {
      if (!fut.isCacheTopologyValid(cctx)) {
        onDone(new IgniteCheckedException("Failed to perform cache operation (cache topology is not valid): " + cctx.name()));
        return;
      }
      topVer=fut.topologyVersion();
    }
 else {
      if (waitTopFut) {
        fut.listen(new CI1<IgniteInternalFuture<AffinityTopologyVersion>>(){
          @Override public void apply(          IgniteInternalFuture<AffinityTopologyVersion> t){
            cctx.kernalContext().closure().runLocalSafe(new Runnable(){
              @Override public void run(){
                mapOnTopology(keys,remap,oldNodeId);
              }
            }
);
          }
        }
);
      }
 else       onDone(new GridCacheTryPutFailedException());
      return;
    }
  }
  finally {
    cache.topology().readUnlock();
  }
  map0(topVer,keys,remap,oldNodeId);
}
