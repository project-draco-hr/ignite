{
  getSpiContext().addLocalEventListener(evtLsnr=new GridLocalEventListener(){
    @Override public void onEvent(    IgniteEvent evt){
switch (evt.type()) {
case EVT_TASK_FINISHED:
case EVT_TASK_FAILED:
{
          GridTaskEvent taskEvt=(GridTaskEvent)evt;
          taskTops.remove(taskEvt.taskSessionId());
          if (log.isDebugEnabled())           log.debug("Removed task topology from topology cache for session: " + taskEvt.taskSessionId());
          break;
        }
case EVT_JOB_MAPPED:
{
        GridJobEvent jobEvt=(GridJobEvent)evt;
        IgniteBiTuple<Boolean,WeightedTopology> weightedTop=taskTops.get(jobEvt.taskSessionId());
        if (weightedTop != null)         weightedTop.set1(true);
        if (log.isDebugEnabled())         log.debug("Job has been mapped. Ignore cache for session: " + jobEvt.taskSessionId());
        break;
      }
case EVT_NODE_METRICS_UPDATED:
case EVT_NODE_FAILED:
case EVT_NODE_JOINED:
case EVT_NODE_LEFT:
{
      IgniteDiscoveryEvent discoEvt=(IgniteDiscoveryEvent)evt;
      rwLock.writeLock().lock();
      try {
switch (evt.type()) {
case EVT_NODE_JOINED:
{
            nodeJobs.put(discoEvt.eventNode().id(),new AtomicInteger(0));
            break;
          }
case EVT_NODE_LEFT:
case EVT_NODE_FAILED:
{
          nodeJobs.remove(discoEvt.eventNode().id());
          break;
        }
case EVT_NODE_METRICS_UPDATED:
{
        nodeJobs.put(discoEvt.eventNode().id(),new AtomicInteger(0));
        break;
      }
  }
}
  finally {
  rwLock.writeLock().unlock();
}
}
}
}
}
,EVT_NODE_METRICS_UPDATED,EVT_NODE_FAILED,EVT_NODE_JOINED,EVT_NODE_LEFT,EVT_TASK_FINISHED,EVT_TASK_FAILED,EVT_JOB_MAPPED);
rwLock.writeLock().lock();
try {
for (ClusterNode node : getSpiContext().nodes()) nodeJobs.put(node.id(),new AtomicInteger(0));
}
  finally {
rwLock.writeLock().unlock();
}
}
