{
  int keyHash=U.hash(key.hashCode());
  AtomicLongArray tbl0=tbl;
  int addr=keyHash & (tbl0.length() - 1);
  long newMetaPtr=0;
  write(val,valSer);
  int valSize=out.offset();
  long valPtr=copy(12);
  valueSize(valPtr,valSize);
  for (; ; ) {
    long metaPtr0=tbl0.get(addr);
    if (metaPtr0 != 0) {
      long metaPtr=metaPtr0;
      do {
        if (keyHash(metaPtr) == keyHash && key.equals(keyReader.readKey(metaPtr))) {
          if (newMetaPtr != 0) {
            mem.release(key(newMetaPtr),keySize(newMetaPtr));
            mem.release(newMetaPtr,40);
          }
          long nextValPtr;
          do {
            nextValPtr=value(metaPtr);
            nextValue(valPtr,nextValPtr);
          }
 while (!casValue(metaPtr,nextValPtr,valPtr));
          return 0;
        }
        metaPtr=collision(metaPtr);
      }
 while (metaPtr != 0);
    }
    if (newMetaPtr == 0) {
      write(key,keySer);
      int keySize=out.offset();
      long keyPtr=copy(0);
      nextValue(valPtr,0);
      newMetaPtr=createMeta(keyHash,keySize,keyPtr,valPtr,metaPtr0,0);
    }
 else     collision(newMetaPtr,metaPtr0);
    if (tbl0.compareAndSet(addr,metaPtr0,newMetaPtr))     return newMetaPtr;
  }
}
