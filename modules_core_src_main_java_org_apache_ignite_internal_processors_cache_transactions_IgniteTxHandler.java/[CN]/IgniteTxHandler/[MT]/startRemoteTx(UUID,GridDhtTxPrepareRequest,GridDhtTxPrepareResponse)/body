{
  if (!F.isEmpty(req.writes())) {
    GridDhtTxRemote tx=ctx.tm().tx(req.version());
    if (tx == null) {
      tx=new GridDhtTxRemote(ctx,req.nearNodeId(),req.futureId(),nodeId,req.threadId(),req.topologyVersion(),req.version(),null,req.system(),req.policy(),req.concurrency(),req.isolation(),req.isInvalidate(),req.timeout(),req.writes() != null ? Math.max(req.writes().size(),req.txSize()) : req.txSize(),req.nearXidVersion(),req.transactionNodes(),req.subjectId(),req.taskNameHash());
      tx.writeVersion(req.writeVersion());
      tx=ctx.tm().onCreated(null,tx);
      if (tx == null || !ctx.tm().onStarted(tx)) {
        if (log.isDebugEnabled())         log.debug("Attempt to start a completed transaction (will ignore): " + tx);
        return null;
      }
      if (ctx.discovery().node(nodeId) == null) {
        tx.state(ROLLING_BACK);
        tx.state(ROLLED_BACK);
        ctx.tm().uncommitTx(tx);
        return null;
      }
    }
 else {
      tx.writeVersion(req.writeVersion());
      tx.transactionNodes(req.transactionNodes());
    }
    if (!tx.isSystemInvalidate() && !F.isEmpty(req.writes())) {
      int idx=0;
      for (      IgniteTxEntry entry : req.writes()) {
        GridCacheContext cacheCtx=entry.context();
        tx.addWrite(entry,ctx.deploy().globalLoader());
        if (isNearEnabled(cacheCtx) && req.invalidateNearEntry(idx))         invalidateNearEntry(cacheCtx,entry.key(),req.version());
        try {
          if (req.needPreloadKey(idx)) {
            GridCacheEntryEx cached=entry.cached();
            if (cached == null)             cached=cacheCtx.cache().entryEx(entry.key(),req.topologyVersion());
            GridCacheEntryInfo info=cached.info();
            if (info != null && !info.isNew() && !info.isDeleted())             res.addPreloadEntry(info);
          }
        }
 catch (        GridDhtInvalidPartitionException e) {
          tx.addInvalidPartition(cacheCtx,e.partition());
          tx.clearEntry(entry.txKey());
        }
        idx++;
      }
    }
    tx.prepare();
    if (req.last())     tx.state(PREPARED);
    res.invalidPartitionsByCacheId(tx.invalidPartitions());
    if (tx.empty() && req.last()) {
      tx.rollback();
      return null;
    }
    return tx;
  }
  return null;
}
