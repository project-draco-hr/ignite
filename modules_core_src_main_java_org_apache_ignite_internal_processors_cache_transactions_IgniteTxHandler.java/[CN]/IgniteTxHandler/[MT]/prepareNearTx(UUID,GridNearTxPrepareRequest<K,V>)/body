{
  ClusterNode nearNode=ctx.node(nearNodeId);
  if (nearNode == null) {
    if (log.isDebugEnabled())     log.debug("Received transaction request from node that left grid (will ignore): " + nearNodeId);
    return null;
  }
  try {
    for (    IgniteTxEntry<K,V> e : F.concat(false,req.reads(),req.writes()))     e.unmarshal(ctx,false,ctx.deploy().globalLoader());
  }
 catch (  IgniteCheckedException e) {
    return new GridFinishedFuture<>(ctx.kernalContext(),e);
  }
  GridDhtTxLocal<K,V> tx;
  GridCacheVersion mappedVer=ctx.tm().mappedVersion(req.version());
  if (mappedVer != null) {
    tx=ctx.tm().tx(mappedVer);
    if (tx == null)     U.warn(log,"Missing local transaction for mapped near version [nearVer=" + req.version() + ", mappedVer="+ mappedVer+ ']');
  }
 else {
    tx=new GridDhtTxLocal<>(ctx,nearNode.id(),req.version(),req.futureId(),req.miniId(),req.threadId(),false,false,req.system(),req.concurrency(),req.isolation(),req.timeout(),req.isInvalidate(),false,req.txSize(),req.groupLockKey(),req.partitionLock(),req.transactionNodes(),req.subjectId(),req.taskNameHash());
    tx=ctx.tm().onCreated(tx);
    if (tx != null)     tx.topologyVersion(req.topologyVersion());
 else     U.warn(log,"Failed to create local transaction (was transaction rolled back?) [xid=" + tx.xid() + ", req="+ req+ ']');
  }
  if (tx != null) {
    IgniteFuture<IgniteTxEx<K,V>> fut=tx.prepareAsync(req.reads(),req.writes(),req.dhtVersions(),req.messageId(),req.miniId(),req.transactionNodes(),req.last(),req.lastBackups());
    if (tx.isRollbackOnly()) {
      try {
        tx.rollback();
      }
 catch (      IgniteCheckedException e) {
        U.error(log,"Failed to rollback transaction: " + tx,e);
      }
    }
    final GridDhtTxLocal<K,V> tx0=tx;
    fut.listenAsync(new CI1<IgniteFuture<IgniteTxEx<K,V>>>(){
      @Override public void apply(      IgniteFuture<IgniteTxEx<K,V>> txFut){
        try {
          txFut.get();
        }
 catch (        IgniteCheckedException e) {
          tx0.setRollbackOnly();
          if (!(e instanceof IgniteTxOptimisticException))           U.error(log,"Failed to prepare DHT transaction: " + tx0,e);
        }
      }
    }
);
    return fut;
  }
 else   return new GridFinishedFuture<>(ctx.kernalContext(),(IgniteTxEx<K,V>)null);
}
