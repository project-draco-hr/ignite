{
  if (debug)   log(ignite.log(),"Collecting partitions for cache: " + escapeName(cacheName));
  VisorCachePartitions parts=new VisorCachePartitions();
  GridCacheAdapter ca=ignite.context().cache().internalCache(cacheName);
  if (ca == null || !ca.context().started())   return parts;
  CacheConfiguration cfg=ca.configuration();
  CacheMode mode=cfg.getCacheMode();
  boolean partitioned=(mode == CacheMode.PARTITIONED || mode == CacheMode.REPLICATED) && ca.context().affinityNode();
  if (partitioned) {
    GridCacheSwapManager swap=ca.context().swap();
    GridDhtCacheAdapter dca=null;
    if (ca instanceof GridNearCacheAdapter)     dca=((GridNearCacheAdapter)ca).dht();
 else     if (ca instanceof GridDhtCacheAdapter)     dca=(GridDhtCacheAdapter)ca;
    if (dca != null) {
      GridDhtPartitionTopology top=dca.topology();
      List<GridDhtLocalPartition> locParts=top.localPartitions();
      try {
        for (        GridDhtLocalPartition part : locParts) {
          int p=part.id();
          int sz=part.publicSize();
          if (part.primary(AffinityTopologyVersion.NONE))           parts.addPrimary(p,sz,swap.offheapEntriesCount(p),swap.swapEntriesCount(p));
 else           if (part.state() == GridDhtPartitionState.OWNING && part.backup(AffinityTopologyVersion.NONE))           parts.addBackup(p,sz,swap.offheapEntriesCount(p),swap.swapEntriesCount(p));
        }
      }
 catch (      IgniteCheckedException e) {
        throw new IgniteException("Failed to collect keys distribution in partitions",e);
      }
    }
  }
  return parts;
}
