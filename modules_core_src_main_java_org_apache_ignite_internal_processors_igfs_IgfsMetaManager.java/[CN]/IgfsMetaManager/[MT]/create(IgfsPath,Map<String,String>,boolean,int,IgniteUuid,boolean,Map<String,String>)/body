{
  validTxState(false);
  while (true) {
    if (busyLock.enterBusy()) {
      try {
        IgfsPathIds pathIds=pathIds(path);
        Set<IgniteUuid> lockIds=new TreeSet<>(PATH_ID_SORTING_COMPARATOR);
        pathIds.addExistingIds(lockIds,relaxed);
        pathIds.addSurrogateIds(lockIds);
        IgniteUuid overwriteId=IgniteUuid.randomUuid();
        IgniteUuid trashId=IgfsUtils.randomTrashId();
        if (overwrite) {
          lockIds.add(overwriteId);
          if (pathIds.allExists())           lockIds.add(trashId);
        }
        try (IgniteInternalTx tx=startTx()){
          Map<IgniteUuid,IgfsEntryInfo> lockInfos=lockIds(lockIds);
          if (!pathIds.verifyIntegrity(lockInfos,relaxed))           continue;
          if (pathIds.allExists()) {
            IgfsEntryInfo oldInfo=lockInfos.get(pathIds.lastId());
            if (!oldInfo.isFile())             throw new IgfsPathIsDirectoryException("Failed to create a file: " + path);
            if (!overwrite)             throw new IgfsPathAlreadyExistsException("Failed to create a file: " + path);
            if (oldInfo.lockId() != null)             throw new IgfsException("File is already opened for write: " + path);
            IgniteUuid oldId=pathIds.lastId();
            id2InfoPrj.invoke(trashId,new IgfsMetaDirectoryListingAddProcessor(IgfsUtils.composeNameForTrash(path,oldId),new IgfsListingEntry(oldInfo)));
            String name=pathIds.lastPart();
            IgniteUuid parentId=pathIds.lastParentId();
            id2InfoPrj.invoke(parentId,new IgfsMetaDirectoryListingReplaceProcessor(name,overwriteId));
            long createTime=System.currentTimeMillis();
            IgfsEntryInfo newInfo=invokeAndGet(overwriteId,new IgfsMetaFileCreateProcessor(createTime,fileProps,blockSize,affKey,createFileLockId(false),evictExclude));
            tx.commit();
            IgfsUtils.sendEvents(igfsCtx.kernalContext(),path,EventType.EVT_IGFS_FILE_OPENED_WRITE);
            return newInfo;
          }
 else {
            IgfsPathsCreateResult res=createFile(pathIds,lockInfos,dirProps,fileProps,blockSize,affKey,evictExclude);
            if (res == null)             continue;
            tx.commit();
            generateCreateEvents(res.createdPaths(),true);
            return res.info();
          }
        }
       }
  finally {
        busyLock.leaveBusy();
      }
    }
 else     throw new IllegalStateException("Failed to mkdir because Grid is stopping. [path=" + path + ']');
  }
}
