{
  Collection<String> names=U.newHashSet(spis.length);
  for (  T spi : spis) {
    ctx.resource().inject(spi);
    inject(spi);
    try {
      Map<String,Object> retval=spi.getNodeAttributes();
      if (retval != null) {
        for (        Map.Entry<String,Object> e : retval.entrySet()) {
          if (ctx.hasNodeAttribute(e.getKey()))           throw new IgniteCheckedException("SPI attribute collision for attribute [spi=" + spi + ", attr="+ e.getKey()+ ']'+ ". Attribute set by one SPI implementation has the same name (name collision) as "+ "attribute set by other SPI implementation. Such overriding is not allowed. "+ "Please check your Ignite configuration and/or SPI implementation to avoid "+ "attribute name collisions.");
          ctx.addNodeAttribute(e.getKey(),e.getValue());
        }
      }
    }
 catch (    IgniteSpiException e) {
      throw new IgniteCheckedException("Failed to get SPI attributes.",e);
    }
    if (log.isDebugEnabled())     log.debug("Starting SPI: " + spi);
    if (names.contains(spi.getName()))     throw new IgniteCheckedException("Duplicate SPI name (need to explicitly configure 'setName()' property): " + spi.getName());
    names.add(spi.getName());
    if (log.isDebugEnabled())     log.debug("Starting SPI implementation: " + spi.getClass().getName());
    onBeforeSpiStart();
    try {
      spi.spiStart(ctx.gridName());
    }
 catch (    IgniteSpiException e) {
      throw new IgniteCheckedException("Failed to start SPI: " + spi,e);
    }
    onAfterSpiStart();
    if (log.isDebugEnabled())     log.debug("SPI module started OK: " + spi.getClass().getName());
  }
}
