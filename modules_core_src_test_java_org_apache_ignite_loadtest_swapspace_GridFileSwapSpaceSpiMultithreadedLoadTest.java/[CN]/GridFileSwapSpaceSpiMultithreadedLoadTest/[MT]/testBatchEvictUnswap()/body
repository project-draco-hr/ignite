{
  final AtomicInteger storedEntriesCnt=new AtomicInteger();
  final AtomicBoolean done=new AtomicBoolean();
  startDaemon(new Runnable(){
    @SuppressWarnings("BusyWait") @Override public void run(){
      int curCnt=storedEntriesCnt.get();
      GridCumulativeAverage avg=new GridCumulativeAverage();
      try {
        while (!done.get()) {
          Thread.sleep(1000);
          int newCnt=storedEntriesCnt.get();
          int entPerSec=newCnt - curCnt;
          X.println(">>> Storing " + entPerSec + " entries/second");
          avg.update(entPerSec);
          curCnt=newCnt;
        }
      }
 catch (      InterruptedException ignored) {
      }
 finally {
        X.println(">>> Average store speed: " + avg + " entries/second");
      }
    }
  }
);
  IgniteInternalFuture<?> evictFut=GridTestUtils.runMultiThreadedAsync(new Runnable(){
    @Override public void run(){
      try {
        ThreadLocalRandom8 rnd=ThreadLocalRandom8.current();
        Map<SwapKey,byte[]> entries=new HashMap<>(BATCH_SIZE);
        while (!done.get()) {
          long l=rnd.nextLong(0,MAX_ENTRIES);
          entries.put(new SwapKey(l),Long.toString(l).getBytes());
          if (entries.size() == BATCH_SIZE) {
            spi.storeAll(SPACE_NAME,entries,context());
            storedEntriesCnt.addAndGet(BATCH_SIZE);
            entries.clear();
          }
        }
      }
 catch (      IgniteSpiException e) {
        e.printStackTrace();
        throw new IgniteException(e);
      }
    }
  }
,N_THREADS,"store");
  final AtomicInteger readRmvKeys=new AtomicInteger();
  startDaemon(new Runnable(){
    @SuppressWarnings("BusyWait") @Override public void run(){
      int curCnt=readRmvKeys.get();
      GridCumulativeAverage avg=new GridCumulativeAverage();
      try {
        while (!done.get()) {
          Thread.sleep(1000);
          int newCnt=readRmvKeys.get();
          int entPerSec=newCnt - curCnt;
          X.println(">>> Read-and-removed " + entPerSec + " entries/second");
          avg.update(entPerSec);
          curCnt=newCnt;
        }
      }
 catch (      InterruptedException ignored) {
      }
 finally {
        X.println(">>> Average read-and-remove speed: " + avg + " entries/second");
      }
    }
  }
);
  IgniteInternalFuture<?> unswapFut=GridTestUtils.runMultiThreadedAsync(new Runnable(){
    @Override public void run(){
      try {
        ThreadLocalRandom8 rnd=ThreadLocalRandom8.current();
        Collection<SwapKey> keys=new ArrayList<>(BATCH_SIZE);
        while (!done.get()) {
          keys.add(new SwapKey(rnd.nextLong(0,MAX_ENTRIES)));
          if (keys.size() == BATCH_SIZE) {
            spi.readAll(SPACE_NAME,keys,context());
            spi.removeAll(SPACE_NAME,keys,null,context());
            readRmvKeys.addAndGet(BATCH_SIZE);
            keys.clear();
          }
        }
      }
 catch (      IgniteCheckedException e) {
        e.printStackTrace();
      }
    }
  }
,N_THREADS,"read-remove");
  Thread.sleep(DURATION);
  done.set(true);
  evictFut.get();
  unswapFut.get();
}
