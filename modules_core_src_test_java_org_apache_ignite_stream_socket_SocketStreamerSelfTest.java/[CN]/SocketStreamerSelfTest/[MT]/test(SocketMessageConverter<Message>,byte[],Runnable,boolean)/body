{
  SocketStreamer<Message,Integer,String> sockStmr=null;
  Ignite ignite=grid(0);
  IgniteCache<Integer,String> cache=ignite.cache(null);
  cache.clear();
  try (IgniteDataStreamer<Integer,String> stmr=ignite.dataStreamer(null)){
    stmr.allowOverwrite(true);
    stmr.autoFlushFrequency(10);
    sockStmr=new SocketStreamer<>();
    sockStmr.setIgnite(ignite);
    sockStmr.setStreamer(stmr);
    sockStmr.setPort(port);
    sockStmr.setDelimiter(delim);
    if (oneMessagePerTuple) {
      sockStmr.setTupleExtractor(new StreamTupleExtractor<Message,Integer,String>(){
        @Override public Map.Entry<Integer,String> extract(        Message msg){
          return new IgniteBiTuple<>(msg.key,msg.val);
        }
      }
);
    }
 else {
      sockStmr.setMultipleTupleExtractor(new StreamMultipleTupleExtractor<Message,Integer,String>(){
        @Override public Map<Integer,String> extract(        Message msg){
          Map<Integer,String> answer=new HashMap<>();
          for (          int value : msg.values) {
            answer.put(value,Integer.toString(value));
          }
          return answer;
        }
      }
);
    }
    if (converter != null)     sockStmr.setConverter(converter);
    final CountDownLatch latch=new CountDownLatch(CNT);
    IgniteBiPredicate<UUID,CacheEvent> locLsnr=new IgniteBiPredicate<UUID,CacheEvent>(){
      @Override public boolean apply(      UUID uuid,      CacheEvent evt){
        latch.countDown();
        return true;
      }
    }
;
    ignite.events(ignite.cluster().forCacheNodes(null)).remoteListen(locLsnr,null,EVT_CACHE_OBJECT_PUT);
    sockStmr.start();
    r.run();
    latch.await();
    for (int i=0; i < CNT; i++)     assertEquals(Integer.toString(i),cache.get(i));
    assertEquals(CNT,cache.size(CachePeekMode.PRIMARY));
  }
  finally {
    if (sockStmr != null)     sockStmr.stop();
  }
}
