{
  U.sleep(1000);
  int keyCnt=iterationCount() / 10;
  int threadCnt=8;
  final int range=keyCnt / threadCnt;
  for (int r=1; r < 5; r++) {
    final AtomicInteger rangeIdx=new AtomicInteger();
    info(">>>>>> Running iteration: " + r);
    GridTestUtils.runMultiThreaded(new Runnable(){
      @Override public void run(){
        try {
          int rangeStart=rangeIdx.getAndIncrement() * range;
          info("Got range [" + rangeStart + ", "+ (rangeStart + range)+ ")");
          for (int i=rangeStart; i < rangeStart + range; i++) {
            int idx=ThreadLocalRandom8.current().nextInt(gridCount());
            GridCacheProjection<Integer,Integer> cache=grid(idx).cache(null);
            cache=cache.flagsOn(GridCacheFlag.FORCE_TRANSFORM_BACKUP);
            cache.transform(i,new Transformer(i));
          }
        }
 catch (        GridException e) {
          throw new GridRuntimeException(e);
        }
      }
    }
,threadCnt,"runner");
    info("Finished run, checking values.");
    U.sleep(500);
    int total=0;
    for (int idx=0; idx < gridCount(); idx++) {
      GridCache<Integer,Integer> cache=grid(idx).cache(null);
      for (int i=0; i < keyCnt; i++) {
        Integer val=cache.peek(i);
        if (val != null) {
          assertEquals("Invalid value for key: " + i,(Integer)r,val);
          total++;
        }
      }
    }
    assertTrue("Total keys: " + total,total >= keyCnt * 2);
  }
}
