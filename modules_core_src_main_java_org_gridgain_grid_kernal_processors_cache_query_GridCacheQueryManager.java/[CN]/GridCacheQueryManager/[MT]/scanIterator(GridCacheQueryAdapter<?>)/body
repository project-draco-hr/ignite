{
  GridPredicate<GridCacheEntry<K,V>> filter=null;
  if (qry.projectionFilter() != null) {
    filter=new P1<GridCacheEntry<K,V>>(){
      @Override public boolean apply(      GridCacheEntry<K,V> e){
        return qry.projectionFilter().apply((GridCacheEntry<Object,Object>)e);
      }
    }
;
  }
  GridCacheProjection<K,V> prj0=filter != null ? cctx.cache().projection(filter) : cctx.cache();
  if (qry.keepPortable())   prj0=prj0.keepPortable();
  final GridCacheProjection<K,V> prj=prj0;
  final IgniteBiPredicate<K,V> keyValFilter=qry.scanFilter();
  injectResources(keyValFilter);
  GridIterator<GridIndexingKeyValueRow<K,V>> heapIt=new GridIteratorAdapter<GridIndexingKeyValueRow<K,V>>(){
    private GridIndexingKeyValueRow<K,V> next;
    private Iterator<K> iter=prj.keySet().iterator();
{
      advance();
    }
    @Override public boolean hasNextX(){
      return next != null;
    }
    @Override public GridIndexingKeyValueRow<K,V> nextX(){
      if (next == null)       throw new NoSuchElementException();
      GridIndexingKeyValueRow<K,V> next0=next;
      advance();
      return next0;
    }
    @Override public void removeX(){
      throw new UnsupportedOperationException();
    }
    private void advance(){
      IgniteBiTuple<K,V> next0=null;
      while (iter.hasNext()) {
        next0=null;
        K key=iter.next();
        V val=prj.peek(key);
        if (val != null) {
          next0=F.t(key,val);
          if (checkPredicate(next0))           break;
 else           next0=null;
        }
      }
      next=next0 != null ? new GridIndexingKeyValueRowAdapter<>(next0.getKey(),next0.getValue()) : null;
    }
    private boolean checkPredicate(    Map.Entry<K,V> e){
      if (keyValFilter != null) {
        Map.Entry<K,V> e0=(Map.Entry<K,V>)cctx.unwrapPortableIfNeeded(e,qry.keepPortable());
        return keyValFilter.apply(e0.getKey(),e0.getValue());
      }
      return true;
    }
  }
;
  final GridIterator<GridIndexingKeyValueRow<K,V>> it;
  if (cctx.isSwapOrOffheapEnabled()) {
    List<GridIterator<GridIndexingKeyValueRow<K,V>>> iters=new ArrayList<>(3);
    iters.add(heapIt);
    if (cctx.isOffHeapEnabled())     iters.add(offheapIterator(qry));
    if (cctx.swap().swapEnabled())     iters.add(swapIterator(qry));
    it=new CompoundIterator<>(iters);
  }
 else   it=heapIt;
  return new GridCloseableIteratorAdapter<GridIndexingKeyValueRow<K,V>>(){
    @Override protected boolean onHasNext(){
      return it.hasNext();
    }
    @Override protected GridIndexingKeyValueRow<K,V> onNext(){
      return it.next();
    }
    @Override protected void onRemove(){
      it.remove();
    }
  }
;
}
