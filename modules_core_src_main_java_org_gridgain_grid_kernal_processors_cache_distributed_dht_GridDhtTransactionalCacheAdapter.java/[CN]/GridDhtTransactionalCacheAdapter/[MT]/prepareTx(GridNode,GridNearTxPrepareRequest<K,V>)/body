{
  try {
    unmarshal(req);
  }
 catch (  GridException e) {
    return new GridFinishedFuture<>(ctx.kernalContext(),e);
  }
  GridFuture<Object> fut=ctx.preloader().request(F.viewReadOnly(F.concat(false,req.reads(),req.writes()),CU.<K,V>tx2key()),req.topologyVersion());
  return new GridEmbeddedFuture<>(ctx.kernalContext(),fut,new C2<Object,Exception,GridFuture<GridCacheTxEx<K,V>>>(){
    @Override public GridFuture<GridCacheTxEx<K,V>> apply(    Object o,    Exception ex){
      if (ex != null)       throw new GridClosureException(ex);
      GridDhtTxLocal<K,V> tx;
      GridCacheVersion mappedVer=ctx.tm().mappedVersion(req.version());
      if (mappedVer != null) {
        tx=ctx.tm().tx(mappedVer);
        if (tx == null)         U.warn(log,"Missing local transaction for mapped near version [nearVer=" + req.version() + ", mappedVer="+ mappedVer+ ']');
      }
 else {
        tx=new GridDhtTxLocal<>(nearNode.id(),req.version(),req.futureId(),req.miniId(),req.threadId(),false,false,ctx,req.concurrency(),req.isolation(),req.timeout(),req.isInvalidate(),req.syncCommit(),req.syncRollback(),false,req.txSize(),req.groupLockKey(),req.partitionLock(),req.transactionNodes(),req.subjectId(),req.taskNameHash());
        tx=ctx.tm().onCreated(tx);
        if (tx != null)         tx.topologyVersion(req.topologyVersion());
 else         U.warn(log,"Failed to create local transaction (was transaction rolled back?) [xid=" + tx.xid() + ", req="+ req+ ']');
      }
      if (tx != null) {
        GridFuture<GridCacheTxEx<K,V>> fut=tx.prepareAsync(req.reads(),req.writes(),req.dhtVersions(),req.messageId(),req.miniId(),req.transactionNodes(),req.last(),req.lastBackups());
        if (tx.isRollbackOnly())         try {
          tx.rollback();
        }
 catch (        GridException e) {
          U.error(log,"Failed to rollback transaction: " + tx,e);
        }
        return fut;
      }
 else       return new GridFinishedFuture<>(ctx.kernalContext(),(GridCacheTxEx<K,V>)null);
    }
  }
,new C2<GridCacheTxEx<K,V>,Exception,GridCacheTxEx<K,V>>(){
    @Nullable @Override public GridCacheTxEx<K,V> apply(    GridCacheTxEx<K,V> tx,    Exception e){
      if (e != null) {
        if (tx != null)         tx.setRollbackOnly();
        if (!(e instanceof GridCacheTxOptimisticException))         U.error(log,"Failed to prepare DHT transaction: " + tx,e);
      }
      return tx;
    }
  }
);
}
