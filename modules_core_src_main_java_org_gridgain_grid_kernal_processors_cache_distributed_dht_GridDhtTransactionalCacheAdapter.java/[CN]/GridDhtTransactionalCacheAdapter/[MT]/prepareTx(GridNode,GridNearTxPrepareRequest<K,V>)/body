{
  try {
    unmarshal(req);
  }
 catch (  GridException e) {
    return new GridFinishedFuture<>(ctx.kernalContext(),e);
  }
  GridDhtTxLocal<K,V> tx;
  GridCacheVersion mappedVer=ctx.tm().mappedVersion(req.version());
  if (mappedVer != null) {
    tx=ctx.tm().tx(mappedVer);
    if (tx == null)     U.warn(log,"Missing local transaction for mapped near version [nearVer=" + req.version() + ", mappedVer="+ mappedVer+ ']');
  }
 else {
    tx=new GridDhtTxLocal<>(nearNode.id(),req.version(),req.futureId(),req.miniId(),req.threadId(),false,false,ctx,req.concurrency(),req.isolation(),req.timeout(),req.isInvalidate(),req.syncCommit(),req.syncRollback(),false,req.txSize(),req.groupLockKey(),req.partitionLock(),req.transactionNodes(),req.subjectId());
    tx=ctx.tm().onCreated(tx);
    if (tx != null)     tx.topologyVersion(req.topologyVersion());
 else     U.warn(log,"Failed to create local transaction (was transaction rolled back?) [xid=" + tx.xid() + ", req="+ req+ ']');
  }
  if (tx != null) {
    GridFuture<GridCacheTxEx<K,V>> fut=tx.prepareAsync(req.reads(),req.writes(),req.dhtVersions(),req.messageId(),req.miniId(),req.transactionNodes(),req.last(),req.lastBackups());
    if (tx.isRollbackOnly()) {
      try {
        tx.rollback();
      }
 catch (      GridException e) {
        U.error(log,"Failed to rollback transaction: " + tx,e);
      }
    }
    final GridDhtTxLocal<K,V> tx0=tx;
    fut.listenAsync(new CI1<GridFuture<GridCacheTxEx<K,V>>>(){
      @Override public void apply(      GridFuture<GridCacheTxEx<K,V>> txFut){
        try {
          txFut.get();
        }
 catch (        GridException e) {
          tx0.setRollbackOnly();
          if (!(e instanceof GridCacheTxOptimisticException))           U.error(log,"Failed to prepare DHT transaction: " + tx0,e);
        }
      }
    }
);
    return fut;
  }
 else   return new GridFinishedFuture<>(ctx.kernalContext(),(GridCacheTxEx<K,V>)null);
}
