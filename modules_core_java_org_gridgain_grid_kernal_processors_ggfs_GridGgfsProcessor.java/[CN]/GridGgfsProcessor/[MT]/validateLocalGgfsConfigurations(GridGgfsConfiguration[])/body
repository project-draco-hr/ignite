{
  Collection<String> cfgNames=new HashSet<>();
  for (  GridGgfsConfiguration cfg : cfgs) {
    String name=cfg.getName();
    if (cfgNames.contains(name))     throw new GridException("Duplicate GGFS name found (check configuration and " + "assign unique name to each): " + name);
    GridCacheAdapter<Object,Object> dataCache=ctx.cache().internalCache(cfg.getDataCacheName());
    if (dataCache == null)     throw new GridException("Data cache is not configured locally for GGFS: " + cfg);
    if (ctx.cache().cache(cfg.getMetaCacheName()) == null)     throw new GridException("Metadata cache is not configured locally for GGFS: " + cfg);
    if (F.eq(cfg.getDataCacheName(),cfg.getMetaCacheName()))     throw new GridException("Cannot use same cache as both data and meta cache: " + cfg.getName());
    if (!(dataCache.configuration().getAffinityMapper() instanceof GridGgfsGroupDataBlocksKeyMapper))     throw new GridException("Invalid GGFS data cache configuration (key affinity mapper class should be " + GridGgfsGroupDataBlocksKeyMapper.class.getSimpleName() + "): "+ cfg);
    long maxSpaceSize=cfg.getMaxSpaceSize();
    if (maxSpaceSize > 0) {
      long maxHeapSize=Runtime.getRuntime().maxMemory();
      long offHeapSize=dataCache.configuration().getOffHeapMaxMemory();
      if (offHeapSize < 0 && maxSpaceSize > maxHeapSize)       throw new GridException("Maximum GGFS space size cannot be greater that size of available heap " + "memory [maxHeapSize=" + maxHeapSize + ", maxGgfsSpaceSize="+ maxSpaceSize+ ']');
 else       if (offHeapSize > 0 && maxSpaceSize > maxHeapSize + offHeapSize)       throw new GridException("Maximum GGFS space size cannot be greater than size of available heap " + "memory and offheap storage [maxHeapSize=" + maxHeapSize + ", offHeapSize="+ offHeapSize+ ", maxGgfsSpaceSize="+ maxSpaceSize+ ']');
    }
    if (dataCache.configuration().getCacheMode() == PARTITIONED) {
      int backups=dataCache.configuration().getBackups();
      if (backups != 0)       throw new GridException("GGFS data cache cannot be used with backups (set backup count " + "to 0 and restart the grid): " + cfg.getDataCacheName());
    }
    if (cfg.getMaxSpaceSize() == 0 && dataCache.configuration().getMemoryMode() == OFFHEAP_VALUES)     U.warn(log,"GGFS max space size is not specified but data cache values are stored off-heap (max " + "space will be limited to 80% of max JVM heap size): " + cfg.getName());
    boolean secondary=cfg.getDefaultMode() == PROXY;
    if (cfg.getPathModes() != null) {
      for (      Map.Entry<String,GridGgfsMode> mode : cfg.getPathModes().entrySet()) {
        if (mode.getValue() == PROXY)         secondary=true;
      }
    }
    if (secondary) {
      assertParameter(cfg.getSecondaryHadoopFileSystemUri() != null,"secondaryHadoopFileSystemUri cannot be null when mode is SECONDARY");
      assertParameter(cfg.getSecondaryHadoopFileSystemConfigPath() != null,"secondaryHadoopFileSystemConfigPath cannot be null when mode is SECONDARY");
    }
    if (cfg.getSecondaryHadoopFileSystemConfigPath() != null && cfg.getSecondaryHadoopFileSystemUri() == null)     throw new GridException("secondaryHadoopFileSystemUri cannot be null when " + "secondaryHadoopFileSystemConfigPath is set.");
    if (cfg.getSecondaryHadoopFileSystemConfigPath() == null && cfg.getSecondaryHadoopFileSystemUri() != null)     throw new GridException("secondaryHadoopFileSystemConfigPath cannot be null when " + "secondaryHadoopFileSystemUri is set.");
    cfgNames.add(name);
  }
}
