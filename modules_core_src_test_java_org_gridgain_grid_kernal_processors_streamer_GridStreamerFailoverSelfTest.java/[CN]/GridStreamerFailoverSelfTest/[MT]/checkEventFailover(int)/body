{
  router=new TestRandomRouter();
  maxConcurrentSess=max;
  startGrids(6);
  try {
    router.sourceNodeId(grid(0).localNode().id());
    router.destinationNodeId(grid(5).localNode().id());
    final AtomicBoolean done=new AtomicBoolean(false);
    IgniteFuture<?> fut=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        Random rnd=new Random();
        while (!done.get()) {
          int idx=rnd.nextInt(4) + 1;
          info(">>>>> Stopping grid " + grid(idx).localNode().id());
          stopGrid(idx,true);
          U.sleep(1000);
          startGrid(idx);
          info(">>>>>> Started grid " + grid(idx).localNode().id());
          U.sleep(500);
        }
        return null;
      }
    }
,1);
    final Collection<Object> failed=new ConcurrentLinkedQueue<>();
    IgniteStreamer streamer=grid(0).streamer(null);
    streamer.addStreamerFailureListener(new StreamerFailureListener(){
      @Override public void onFailure(      String stageName,      Collection<Object> evts,      Throwable err){
        info("Unable to failover events [stageName=" + stageName + ", err="+ err+ ']');
        failed.addAll(evts);
      }
    }
);
    final int evtsCnt=300000;
    for (int i=0; i < evtsCnt; i++) {
      if (i > 0 && i % 10000 == 0)       info("Processed: " + i);
      streamer.addEvent(i);
    }
    done.set(true);
    fut.get();
    G.stop(getTestGridName(0),false);
    ConcurrentMap<Integer,AtomicInteger> finSpace=grid(5).streamer(null).context().localSpace();
    for (int i=0; i < evtsCnt; i++) {
      AtomicInteger cnt=finSpace.get(i);
      if (cnt == null) {
        assertTrue("Missing counter for key both in result map and in failover failed map: " + i,failed.contains(i));
      }
 else       assertTrue(cnt.get() > 0);
    }
  }
  finally {
    stopAllGrids();
  }
}
