{
  final GridNearCacheAdapter near=cache();
  boolean allowLocRead=!forcePrimary || cctx.affinity().primary(cctx.localNode(),key,topVer);
  GridCacheEntryEx entry=allowLocRead ? near.peekEx(key) : null;
  while (true) {
    try {
      CacheObject v=null;
      boolean isNear=entry != null;
      if (isNear)       v=entry.innerGet(tx,false,false,true,true,true,!skipVals,false,subjId,null,taskName,expiryPlc);
      ClusterNode primary=null;
      if (v == null && allowLocRead && cctx.affinityNode()) {
        GridDhtCacheAdapter<K,V> dht=cache().dht();
        GridCacheEntryEx dhtEntry=null;
        try {
          dhtEntry=dht.context().isSwapOrOffheapEnabled() ? dht.entryEx(key) : dht.peekEx(key);
          if (dhtEntry != null) {
            boolean isNew=dhtEntry.isNewLocked() || !dhtEntry.valid(topVer);
            v=dhtEntry.innerGet(tx,true,false,true,true,false,!isNear && !skipVals,false,subjId,null,taskName,expiryPlc);
            if (v == null && isNew && dhtEntry.markObsoleteIfEmpty(ver))             dht.removeIfObsolete(key);
          }
          if (v != null) {
            if (cctx.cache().configuration().isStatisticsEnabled() && !skipVals)             near.metrics0().onRead(true);
          }
 else {
            primary=cctx.affinity().primary(key,topVer);
            if (primary == null) {
              onDone(new ClusterTopologyServerNotFoundException("Failed to map keys for cache " + "(all partition nodes left the grid)."));
              return savedVers;
            }
            if (!primary.isLocal() && cctx.cache().configuration().isStatisticsEnabled() && !skipVals)             near.metrics0().onRead(false);
          }
        }
 catch (        GridDhtInvalidPartitionException|GridCacheEntryRemovedException ignored) {
        }
 finally {
          if (dhtEntry != null && (tx == null || (!tx.implicit() && tx.isolation() == READ_COMMITTED))) {
            dht.context().evicts().touch(dhtEntry,topVer);
            entry=null;
          }
        }
      }
      if (v != null && !reload) {
        K key0=key.value(cctx.cacheObjectContext(),true);
        V val0=v.value(cctx.cacheObjectContext(),true);
        val0=(V)cctx.unwrapPortableIfNeeded(val0,!deserializePortable);
        key0=(K)cctx.unwrapPortableIfNeeded(key0,!deserializePortable);
        add(new GridFinishedFuture<>(Collections.singletonMap(key0,val0)));
      }
 else {
        if (primary == null) {
          primary=cctx.affinity().primary(key,topVer);
          if (primary == null) {
            onDone(new ClusterTopologyServerNotFoundException("Failed to map keys for cache " + "(all partition nodes left the grid)."));
            return savedVers;
          }
        }
        GridNearCacheEntry nearEntry=allowLocRead ? near.peekExx(key) : null;
        entry=nearEntry;
        if (savedVers == null)         savedVers=U.newHashMap(3);
        savedVers.put(key,nearEntry == null ? null : nearEntry.dhtVersion());
        LinkedHashMap<KeyCacheObject,Boolean> keys=mapped.get(primary);
        if (keys != null && keys.containsKey(key)) {
          if (remapCnt.incrementAndGet() > MAX_REMAP_CNT) {
            onDone(new ClusterTopologyCheckedException("Failed to remap key to a new node after " + MAX_REMAP_CNT + " attempts (key got remapped to the same node) "+ "[key="+ key+ ", node="+ U.toShortString(primary)+ ", mappings="+ mapped+ ']'));
            return savedVers;
          }
        }
        boolean addRdr=tx == null || tx.optimistic();
        if (!addRdr && tx.readCommitted() && !tx.writeSet().contains(cctx.txKey(key)))         addRdr=true;
        LinkedHashMap<KeyCacheObject,Boolean> old=mappings.get(primary);
        if (old == null)         mappings.put(primary,old=new LinkedHashMap<>(3,1f));
        old.put(key,addRdr);
      }
      break;
    }
 catch (    IgniteCheckedException e) {
      onDone(e);
      break;
    }
catch (    GridCacheEntryRemovedException ignored) {
      entry=allowLocRead ? near.peekEx(key) : null;
    }
catch (    GridCacheFilterFailedException e) {
      if (log.isDebugEnabled())       log.debug("Filter validation failed for entry: " + e);
      break;
    }
 finally {
      if (entry != null && !reload && tx == null)       cctx.evicts().touch(entry,topVer);
    }
  }
  return savedVers;
}
