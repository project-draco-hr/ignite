{
  boolean empty=F.isEmpty(keys);
  Map<K,V> map=empty ? Collections.<K,V>emptyMap() : new GridLeanMap<K,V>(keys.size());
  if (!empty) {
    boolean atomic=cctx.atomic();
    GridCacheVersion ver=atomic ? null : F.isEmpty(infos) ? null : cctx.versions().next();
    for (    GridCacheEntryInfo info : infos) {
      try {
        info.unmarshalValue(cctx,cctx.deploy().globalLoader());
        if (!cctx.affinity().localNode(info.key(),cctx.affinity().affinityTopologyVersion())) {
          GridNearCacheEntry entry=cache().entryExx(info.key(),topVer);
          GridCacheVersion saved=savedVers.get(info.key());
          entry.loadedValue(tx,nodeId,info.value(),atomic ? info.version() : ver,info.version(),saved,info.ttl(),info.expireTime(),true,topVer,subjId);
          cctx.evicts().touch(entry,topVer);
        }
        CacheObject val=info.value();
        KeyCacheObject key=info.key();
        cctx.addResult(map,key,val,skipVals,false,deserializePortable,false);
      }
 catch (      GridCacheEntryRemovedException ignore) {
        if (log.isDebugEnabled())         log.debug("Got removed entry while processing get response (will not retry).");
      }
catch (      Exception e) {
        onDone(e);
        return Collections.emptyMap();
      }
    }
  }
  return map;
}
