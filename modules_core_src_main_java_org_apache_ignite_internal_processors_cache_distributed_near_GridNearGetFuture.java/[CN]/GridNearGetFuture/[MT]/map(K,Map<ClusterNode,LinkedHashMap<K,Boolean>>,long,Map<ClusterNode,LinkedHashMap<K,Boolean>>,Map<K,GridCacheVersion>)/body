{
  final GridNearCacheAdapter<K,V> near=cache();
  boolean allowLocRead=!forcePrimary || cctx.affinity().primary(cctx.localNode(),key,topVer);
  GridCacheEntryEx<K,V> entry=allowLocRead ? near.peekEx(key) : null;
  while (true) {
    try {
      V v=null;
      boolean isNear=entry != null;
      if (isNear)       v=entry.innerGet(tx,false,false,true,true,true,true,false,subjId,null,taskName,expiryPlc);
      ClusterNode primary=null;
      if (v == null && allowLocRead) {
        GridDhtCacheAdapter<K,V> dht=cache().dht();
        try {
          entry=dht.context().isSwapOrOffheapEnabled() ? dht.entryEx(key) : dht.peekEx(key);
          if (entry != null) {
            boolean isNew=entry.isNewLocked() || !entry.valid(topVer);
            v=entry.innerGet(tx,true,false,true,true,false,!isNear,false,subjId,null,taskName,expiryPlc);
            if (v == null && isNew && entry.markObsoleteIfEmpty(ver))             dht.removeIfObsolete(key);
          }
          if (v != null)           near.metrics0().onRead(true);
 else {
            primary=cctx.affinity().primary(key,topVer);
            if (!primary.isLocal())             near.metrics0().onRead(false);
          }
        }
 catch (        GridDhtInvalidPartitionException ignored) {
        }
 finally {
          if (entry != null && (tx == null || (!tx.implicit() && tx.isolation() == READ_COMMITTED))) {
            dht.context().evicts().touch(entry,topVer);
            entry=null;
          }
        }
      }
      if (v != null && !reload) {
        if (cctx.portableEnabled())         v=(V)cctx.unwrapPortableIfNeeded(v,!deserializePortable);
        add(new GridFinishedFuture<>(cctx.kernalContext(),Collections.singletonMap(key,v)));
      }
 else {
        if (primary == null)         primary=cctx.affinity().primary(key,topVer);
        GridNearCacheEntry<K,V> nearEntry=allowLocRead ? near.peekExx(key) : null;
        entry=nearEntry;
        if (savedVers == null)         savedVers=U.newHashMap(3);
        savedVers.put(key,nearEntry == null ? null : nearEntry.dhtVersion());
        LinkedHashMap<K,Boolean> keys=mapped.get(primary);
        if (keys != null && keys.containsKey(key)) {
          if (remapCnt.incrementAndGet() > MAX_REMAP_CNT) {
            onDone(new ClusterTopologyException("Failed to remap key to a new node after " + MAX_REMAP_CNT + " attempts (key got remapped to the same node) [key="+ key+ ", node="+ U.toShortString(primary)+ ", mappings="+ mapped+ ']'));
            return savedVers;
          }
        }
        boolean addRdr=tx == null || tx.optimistic();
        if (!addRdr && tx.readCommitted() && !tx.writeSet().contains(cctx.txKey(key)))         addRdr=true;
        LinkedHashMap<K,Boolean> old=mappings.get(primary);
        if (old == null)         mappings.put(primary,old=new LinkedHashMap<>(3,1f));
        old.put(key,addRdr);
      }
      break;
    }
 catch (    IgniteCheckedException e) {
      onDone(e);
      break;
    }
catch (    GridCacheEntryRemovedException ignored) {
      entry=allowLocRead ? near.peekEx(key) : null;
    }
catch (    GridCacheFilterFailedException e) {
      if (log.isDebugEnabled())       log.debug("Filter validation failed for entry: " + e);
      break;
    }
 finally {
      if (entry != null && !reload && tx == null)       cctx.evicts().touch(entry,topVer);
    }
  }
  return savedVers;
}
