{
  final IgniteKernal kernal=(IgniteKernal)grid(0);
  CacheConfiguration ccfg=new CacheConfiguration();
  ccfg.setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC);
  ccfg.setName(DYNAMIC_CACHE_NAME);
  kernal.context().cache().dynamicStartCache(ccfg,null).get();
  info(">>>>>>> Deployed dynamic cache");
  startGrid(nodeCount());
  try {
    IgniteCache<Object,Object> cache=ignite(nodeCount()).jcache(DYNAMIC_CACHE_NAME);
    cache.put("1","1");
    for (int g=0; g < nodeCount() + 1; g++) {
      assertEquals("1",grid(g).jcache(DYNAMIC_CACHE_NAME).get("1"));
      assertEquals(nodeCount() + 1,grid(g).affinity(DYNAMIC_CACHE_NAME).mapKeyToPrimaryAndBackups(0).size());
    }
    kernal.context().cache().dynamicStopCache(DYNAMIC_CACHE_NAME).get();
    startGrid(nodeCount() + 1);
    for (int g=0; g < nodeCount() + 2; g++) {
      final IgniteKernal kernal0=(IgniteKernal)grid(g);
      for (      IgniteInternalFuture f : kernal0.context().cache().context().exchange().exchangeFutures())       f.get();
      GridTestUtils.assertThrows(log,new Callable<Object>(){
        @Override public Object call() throws Exception {
          return kernal0.jcache(DYNAMIC_CACHE_NAME);
        }
      }
,IllegalArgumentException.class,null);
    }
  }
  finally {
    stopGrid(nodeCount() + 1);
    stopGrid(nodeCount());
  }
}
