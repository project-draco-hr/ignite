{
  if (locCb == null)   throw new IllegalStateException("Mandatory local callback is not set for the query: " + this);
  ctx.checkSecurity(GridSecurityPermission.CACHE_READ);
  if (prj == null)   prj=ctx.grid();
  prj=prj.forCacheNodes(ctx.name());
  if (prj.nodes().isEmpty())   throw new ClusterTopologyCheckedException("Failed to continuous execute query (projection is empty): " + this);
  boolean skipPrimaryCheck=false;
  Collection<ClusterNode> nodes=prj.nodes();
  if (nodes.isEmpty())   throw new ClusterTopologyCheckedException("Failed to execute continuous query (empty projection is " + "provided): " + this);
switch (ctx.config().getCacheMode()) {
case LOCAL:
    if (!nodes.contains(ctx.localNode()))     throw new ClusterTopologyCheckedException("Continuous query for LOCAL cache can be executed " + "only locally (provided projection contains remote nodes only): " + this);
 else     if (nodes.size() > 1)     U.warn(log,"Continuous query for LOCAL cache will be executed locally (provided projection is " + "ignored): " + this);
  prj=prj.forNode(ctx.localNode());
break;
case REPLICATED:
if (nodes.size() == 1 && F.first(nodes).equals(ctx.localNode())) {
CacheDistributionMode distributionMode=ctx.config().getDistributionMode();
if (distributionMode == PARTITIONED_ONLY || distributionMode == NEAR_PARTITIONED) skipPrimaryCheck=true;
}
break;
}
closeLock.lock();
try {
if (routineId != null) throw new IllegalStateException("Continuous query can't be executed twice.");
guard.block();
int taskNameHash=ctx.kernalContext().security().enabled() ? ctx.kernalContext().job().currentTaskNameHash() : 0;
GridContinuousHandler hnd=new GridCacheContinuousQueryHandler<>(ctx.name(),topic,locCb,rmtFilter,prjPred,internal,entryLsnr,sync,oldVal,skipPrimaryCheck,taskNameHash,keepPortable);
routineId=ctx.kernalContext().continuous().startRoutine(hnd,bufSize,timeInterval,autoUnsubscribe,prj.predicate()).get();
}
  finally {
closeLock.unlock();
}
}
