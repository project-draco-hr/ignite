{
  if (map != null && keyCheck)   validateCacheKeys(map.keySet());
  ctx.checkSecurity(GridSecurityPermission.CACHE_PUT);
  GridCacheProjectionImpl<K,V> prj=ctx.projectionPerCall();
  UUID subjId=ctx.subjectIdPerCall(null,prj);
  int taskNameHash=ctx.kernalContext().job().currentTaskNameHash();
  final GridNearAtomicUpdateFuture<K,V> updateFut=new GridNearAtomicUpdateFuture<>(ctx,this,ctx.config().getWriteSynchronizationMode(),transformMap != null ? TRANSFORM : UPDATE,map != null ? map.keySet() : transformMap != null ? transformMap.keySet() : drPutMap != null ? drPutMap.keySet() : drRmvMap.keySet(),map != null ? map.values() : transformMap != null ? transformMap.values() : null,invokeArgs,drPutMap != null ? drPutMap.values() : null,drRmvMap != null ? drRmvMap.values() : null,retval,rawRetval,cached,prj != null ? prj.expiry() : null,filter,subjId,taskNameHash);
  return asyncOp(new CO<IgniteFuture<Object>>(){
    @Override public IgniteFuture<Object> apply(){
      updateFut.map();
      return updateFut;
    }
  }
);
}
