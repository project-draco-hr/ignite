{
  if (log.isDebugEnabled())   log.debug("Processing dht atomic update request [nodeId=" + nodeId + ", req="+ req+ ']');
  GridCacheVersion ver=req.writeVersion();
  GridDhtAtomicUpdateResponse<K,V> res=new GridDhtAtomicUpdateResponse<>(req.futureVersion());
  Boolean replicate=ctx.isDrEnabled();
  boolean intercept=req.forceTransformBackups() && ctx.config().getInterceptor() != null;
  for (int i=0; i < req.size(); i++) {
    K key=req.key(i);
    try {
      while (true) {
        GridDhtCacheEntry<K,V> entry=null;
        try {
          entry=entryExx(key);
          V val=req.value(i);
          byte[] valBytes=req.valueBytes(i);
          GridClosure<V,V> transform=req.transformClosure(i);
          GridCacheOperation op=transform != null ? TRANSFORM : (val != null || valBytes != null) ? UPDATE : DELETE;
          GridCacheUpdateAtomicResult<K,V> updRes=entry.innerUpdate(ver,nodeId,nodeId,op,op == TRANSFORM ? transform : val,valBytes,false,false,req.ttl(),true,true,false,!req.forceTransformBackups(),CU.<K,V>empty(),replicate ? DR_BACKUP : DR_NONE,req.drTtl(i),req.drExpireTime(i),req.drVersion(i),false,intercept,req.subjectId());
          if (updRes.removeVersion() != null)           ctx.onDeferredDelete(entry,updRes.removeVersion());
          entry.onUnlock();
          break;
        }
 catch (        GridCacheEntryRemovedException ignored) {
          if (log.isDebugEnabled())           log.debug("Got removed entry while updating backup value (will retry): " + key);
          entry=null;
        }
 finally {
          if (entry != null)           ctx.evicts().touch(entry,req.topologyVersion());
        }
      }
    }
 catch (    GridDhtInvalidPartitionException ignored) {
    }
catch (    GridException e) {
      res.addFailedKey(key,new GridException("Failed to update key on backup node: " + key,e));
    }
  }
  if (isNearEnabled(cacheCfg))   ((GridNearAtomicCache<K,V>)near()).processDhtAtomicUpdateRequest(nodeId,req,res);
  try {
    if (res.failedKeys() != null || res.nearEvicted() != null || req.writeSynchronizationMode() == FULL_SYNC)     ctx.io().send(nodeId,res);
 else {
      sendDeferredUpdateResponse(nodeId,req.futureVersion());
    }
  }
 catch (  GridTopologyException ignored) {
    U.warn(log,"Failed to send DHT atomic update response to node because it left grid: " + req.nodeId());
  }
catch (  GridException e) {
    U.error(log,"Failed to send DHT atomic update response (did node leave grid?) [nodeId=" + nodeId + ", req="+ req+ ']',e);
  }
}
