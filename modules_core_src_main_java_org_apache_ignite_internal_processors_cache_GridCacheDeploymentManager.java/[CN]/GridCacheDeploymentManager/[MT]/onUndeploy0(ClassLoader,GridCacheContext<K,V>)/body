{
  GridCacheAdapter<K,V> cache=cacheCtx.cache();
  Collection<KeyCacheObject> keys=new ArrayList<>();
  addEntries(ldr,keys,cache);
  if (cache.isNear())   addEntries(ldr,keys,(((GridNearCacheAdapter)cache).dht()));
  if (log.isDebugEnabled())   log.debug("Finished searching keys for undeploy [keysCnt=" + keys.size() + ']');
  cache.clearLocally(keys,true);
  if (cacheCtx.isNear())   cacheCtx.near().dht().clearLocally(keys,true);
  GridCacheQueryManager<K,V> qryMgr=cacheCtx.queries();
  if (qryMgr != null)   qryMgr.onUndeploy(ldr);
  int swapUndeployCnt=cacheCtx.isNear() ? cacheCtx.near().dht().context().swap().onUndeploy(ldr) : cacheCtx.swap().onUndeploy(ldr);
  if (cacheCtx.userCache()) {
    U.quietAndWarn(log,"");
    U.quietAndWarn(log,"Cleared all cache entries for undeployed class loader [[cacheName=" + cacheCtx.namexx() + ", undeployCnt="+ keys.size()+ ", swapUndeployCnt="+ swapUndeployCnt+ ", clsLdr="+ ldr.getClass().getName()+ ']',"Cleared all cache entries for undeployed class loader for cache: " + cacheCtx.namexx());
    U.quietAndWarn(log,"  ^-- Cache auto-undeployment happens in SHARED deployment mode (to turn off, switch to CONTINUOUS mode)");
    U.quietAndWarn(log,"");
  }
  globalLdr=new CacheClassLoader();
}
