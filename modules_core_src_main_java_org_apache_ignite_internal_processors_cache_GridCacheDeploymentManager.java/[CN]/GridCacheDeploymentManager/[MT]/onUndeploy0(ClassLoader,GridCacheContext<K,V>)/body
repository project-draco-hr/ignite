{
  GridCacheAdapter<K,V> cache=cacheCtx.cache();
  Collection<K> keys=new ArrayList<>();
  for (  Cache.Entry<K,V> e : cache.entrySet()) {
    boolean undeploy=cacheCtx.isNear() ? undeploy(ldr,e,cacheCtx.near()) || undeploy(ldr,e,cacheCtx.near().dht()) : undeploy(ldr,e,cacheCtx.cache());
    if (undeploy)     keys.add(e.getKey());
  }
  if (log.isDebugEnabled())   log.debug("Finished searching keys for undeploy [keysCnt=" + keys.size() + ']');
  for (  K k : keys)   cache.clearLocally(k);
  if (cacheCtx.isNear())   for (  K k : keys)   cacheCtx.near().dht().clearLocally(k);
  GridCacheQueryManager<K,V> qryMgr=cacheCtx.queries();
  if (qryMgr != null)   qryMgr.onUndeploy(ldr);
  int swapUndeployCnt=cacheCtx.isNear() ? cacheCtx.near().dht().context().swap().onUndeploy(ldr) : cacheCtx.swap().onUndeploy(ldr);
  if (!cacheCtx.system()) {
    U.quietAndWarn(log,"");
    U.quietAndWarn(log,"Cleared all cache entries for undeployed class loader [[cacheName=" + cacheCtx.namexx() + ", undeployCnt="+ keys.size()+ ", swapUndeployCnt="+ swapUndeployCnt+ ", clsLdr="+ ldr.getClass().getName()+ ']',"Cleared all cache entries for undeployed class loader for cache: " + cacheCtx.namexx());
    U.quietAndWarn(log,"  ^-- Cache auto-undeployment happens in SHARED deployment mode (to turn off, switch to CONTINUOUS mode)");
    U.quietAndWarn(log,"");
  }
  globalLdr=new CacheClassLoader();
}
