{
  if (log.isDebugEnabled())   log.debug("Before acquiring transaction lock on keys [passedKeys=" + passedKeys + ", skipped="+ skipped+ ']');
  if (passedKeys.isEmpty())   return new GridFinishedFuture<>(cctx.kernalContext(),ret);
  GridFuture<Boolean> fut=cctx.dht().lockAllAsyncInternal(passedKeys,lockTimeout(),this,isInvalidate(),read,false,isolation,CU.<K,V>empty());
  return new GridEmbeddedFuture<>(fut,new PLC1<GridCacheReturn<V>>(ret){
    @Override protected GridCacheReturn<V> postLock(    GridCacheReturn<V> ret) throws GridException {
      if (log.isDebugEnabled())       log.debug("Acquired transaction lock on keys: " + passedKeys);
      postLockWrite(passedKeys,skipped,null,null,ret,false,false,filter == null ? CU.<K,V>empty() : filter);
      return ret;
    }
  }
,cctx.kernalContext());
}
