{
  if (tx.optimistic()) {
    GridDhtTopologyFuture topFut=topologyReadLock();
    try {
      if (topFut.isDone()) {
        try {
          if (!tx.state(PREPARING)) {
            if (tx.setRollbackOnly()) {
              if (tx.timedOut())               onError(null,null,new IgniteTxTimeoutException("Transaction timed out and " + "was rolled back: " + this));
 else               onError(null,null,new IgniteCheckedException("Invalid transaction state for prepare " + "[state=" + tx.state() + ", tx="+ this+ ']'));
            }
 else             onError(null,null,new IgniteTxRollbackException("Invalid transaction state for " + "prepare [state=" + tx.state() + ", tx="+ this+ ']'));
            return;
          }
          GridDiscoveryTopologySnapshot snapshot=topFut.topologySnapshot();
          tx.topologyVersion(snapshot.topologyVersion());
          tx.topologySnapshot(snapshot);
          cctx.mvcc().addFuture(this);
          prepare0();
        }
 catch (        IgniteTxTimeoutException|IgniteTxOptimisticException e) {
          onError(cctx.localNodeId(),null,e);
        }
catch (        IgniteCheckedException e) {
          tx.setRollbackOnly();
          String msg="Failed to prepare transaction (will attempt rollback): " + this;
          U.error(log,msg,e);
          tx.rollbackAsync();
          onError(null,null,new IgniteTxRollbackException(msg,e));
        }
      }
 else {
        topFut.syncNotify(false);
        topFut.listenAsync(new CI1<IgniteFuture<Long>>(){
          @Override public void apply(          IgniteFuture<Long> t){
            prepare();
          }
        }
);
      }
    }
  finally {
      topologyReadUnlock();
    }
  }
 else   preparePessimistic();
}
