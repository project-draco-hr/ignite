{
  if (tx.activeCacheIds().isEmpty())   return cctx.exchange().lastTopologyFuture();
  GridCacheContext<K,V> nonLocCtx=null;
  for (  int cacheId : tx.activeCacheIds()) {
    GridCacheContext<K,V> cacheCtx=cctx.cacheContext(cacheId);
    if (!cacheCtx.isLocal()) {
      nonLocCtx=cacheCtx;
      break;
    }
  }
  if (nonLocCtx == null)   return cctx.exchange().lastTopologyFuture();
  nonLocCtx.topology().readLock();
  if (nonLocCtx.topology().stopping()) {
    onDone(new IgniteCheckedException("Failed to perform cache operation (cache is stopped): " + nonLocCtx.name()));
    return null;
  }
  return nonLocCtx.topology().topologyVersionFuture();
}
