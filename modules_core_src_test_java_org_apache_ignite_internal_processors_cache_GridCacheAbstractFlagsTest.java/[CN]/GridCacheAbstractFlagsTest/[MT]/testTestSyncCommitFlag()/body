{
  for (int i=0; i < 10; i++) {
    final String key="k" + i;
    final Integer val=i;
    final CountDownLatch l=new CountDownLatch(1);
    final AtomicInteger cntr=new AtomicInteger();
    IgniteInternalFuture<?> f=multithreadedAsync(new Callable(){
      @Override public Object call() throws Exception {
        int idx=cntr.getAndIncrement() % gridCount();
        IgniteCache<String,Integer> c=jcache(idx);
        l.await();
        assertEquals(val,c.get(key));
        return null;
      }
    }
,gridCount() * 3);
    ((IgniteCacheProxy)jcache(0)).flagOn(CacheFlag.SYNC_COMMIT).put(key,val);
    l.countDown();
    f.get();
  }
}
