{
  delay=-1;
  Grid g0=startGrid(0);
  int cnt=KEY_CNT;
  GridCache<String,Integer> c0=g0.cache(null);
  for (int i=0; i < cnt; i++)   c0.put(Integer.toString(i),i);
  Grid g1=startGrid(1);
  Grid g2=startGrid(2);
  GridCache<String,Integer> c1=g1.cache(null);
  GridCache<String,Integer> c2=g2.cache(null);
  for (int i=0; i < cnt; i++)   assertNull(c1.peek(Integer.toString(i)));
  for (int i=0; i < cnt; i++)   assertNull(c2.peek(Integer.toString(i)));
  final CountDownLatch l1=new CountDownLatch(1);
  final CountDownLatch l2=new CountDownLatch(1);
  g1.events().localListen(new GridPredicate<GridEvent>(){
    @Override public boolean apply(    GridEvent evt){
      l1.countDown();
      return true;
    }
  }
,GridEventType.EVT_CACHE_PRELOAD_STOPPED);
  g2.events().localListen(new GridPredicate<GridEvent>(){
    @Override public boolean apply(    GridEvent evt){
      l2.countDown();
      return true;
    }
  }
,GridEventType.EVT_CACHE_PRELOAD_STOPPED);
  info("Beginning to wait for cache1 repartition.");
  GridDhtCache<String,Integer> d0=dht(0);
  GridDhtCache<String,Integer> d1=dht(1);
  GridDhtCache<String,Integer> d2=dht(2);
  U.sleep(1000);
  info("Partition map for node 0: " + d0.topology().partitionMap(false).toFullString());
  info("Partition map for node 1: " + d1.topology().partitionMap(false).toFullString());
  info("Partition map for node 2: " + d2.topology().partitionMap(false).toFullString());
  checkMaps(false,d0.topology().partitionMap(true),d1.topology().partitionMap(true),d2.topology().partitionMap(true));
  c1.forceRepartition();
  l1.await();
  info("Cache1 is repartitioned.");
  U.sleep(1000);
  info("Partition map for node 0: " + d0.topology().partitionMap(false).toFullString());
  info("Partition map for node 1: " + d1.topology().partitionMap(false).toFullString());
  info("Partition map for node 2: " + d2.topology().partitionMap(false).toFullString());
  checkMaps(false,d0.topology().partitionMap(true),d1.topology().partitionMap(true),d2.topology().partitionMap(true));
  info("Beginning to wait for cache2 repartition.");
  c2.forceRepartition();
  l2.await();
  info("Cache2 is repartitioned.");
  Thread.sleep(1000);
  info("Partition map for node 0: " + d0.topology().partitionMap(false).toFullString());
  info("Partition map for node 1: " + d1.topology().partitionMap(false).toFullString());
  info("Partition map for node 2: " + d2.topology().partitionMap(false).toFullString());
  checkMaps(true,d0.topology().partitionMap(true),d1.topology().partitionMap(true),d2.topology().partitionMap(true));
  checkCache(c0,cnt);
  checkCache(c1,cnt);
  checkCache(c2,cnt);
}
