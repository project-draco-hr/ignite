{
  TransactionState state=state();
  if (state != ROLLING_BACK && state != ROLLED_BACK) {
    setRollbackOnly();
    throw new IgniteCheckedException("Invalid transaction state for rollback [state=" + state + ", tx="+ this+ ']',commitErr.get());
  }
  if (doneFlag.compareAndSet(false,true)) {
    try {
      if (near())       for (      IgniteTxEntry e : allEntries())       evictNearEntry(e,false);
      cctx.tm().rollbackTx(this);
      Collection<CacheStoreManager> stores=stores();
      if (stores != null && !stores.isEmpty() && (near() || F.first(stores).isWriteToStoreFromDht())) {
        if (!internal() || groupLock()) {
          for (          CacheStoreManager store : stores)           store.sessionEnd(this,false);
        }
      }
    }
 catch (    Error|IgniteCheckedException|RuntimeException e) {
      U.addLastCause(e,commitErr.get(),log);
      throw e;
    }
  }
}
