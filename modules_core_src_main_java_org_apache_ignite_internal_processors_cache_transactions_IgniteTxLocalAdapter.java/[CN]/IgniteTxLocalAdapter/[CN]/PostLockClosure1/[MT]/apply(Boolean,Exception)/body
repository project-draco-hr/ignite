{
  TransactionDeadlockException deadlockErr=X.cause(e,TransactionDeadlockException.class);
  if (e != null && deadlockErr == null) {
    setRollbackOnly();
    if (commit && commitAfterLock())     return rollbackAsync().chain(new C1<IgniteInternalFuture<IgniteInternalTx>,T>(){
      @Override public T apply(      IgniteInternalFuture<IgniteInternalTx> f){
        throw new GridClosureException(e);
      }
    }
);
    throw new GridClosureException(e);
  }
  if (deadlockErr != null || !locked) {
    setRollbackOnly();
    final GridClosureException ex=new GridClosureException(new IgniteTxTimeoutCheckedException("Failed to acquire lock within provided timeout " + "for transaction [timeout=" + timeout() + ", tx="+ this+ ']',deadlockErr));
    if (commit && commitAfterLock())     return rollbackAsync().chain(new C1<IgniteInternalFuture<IgniteInternalTx>,T>(){
      @Override public T apply(      IgniteInternalFuture<IgniteInternalTx> f){
        throw ex;
      }
    }
);
    throw ex;
  }
  boolean rollback=true;
  try {
    final T r=postLock(arg);
    if (commit && commitAfterLock()) {
      rollback=false;
      return commitAsync().chain(new CX1<IgniteInternalFuture<IgniteInternalTx>,T>(){
        @Override public T applyx(        IgniteInternalFuture<IgniteInternalTx> f) throws IgniteCheckedException {
          f.get();
          return r;
        }
      }
);
    }
    rollback=false;
    return new GridFinishedFuture<>(r);
  }
 catch (  final IgniteCheckedException ex) {
    if (commit && commitAfterLock())     return rollbackAsync().chain(new C1<IgniteInternalFuture<IgniteInternalTx>,T>(){
      @Override public T apply(      IgniteInternalFuture<IgniteInternalTx> f){
        throw new GridClosureException(ex);
      }
    }
);
    throw new GridClosureException(ex);
  }
 finally {
    if (rollback)     setRollbackOnly();
  }
}
