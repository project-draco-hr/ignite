{
  for (  Map.Entry<UUID,Collection<UUID>> entry : txNodes.entrySet()) {
    UUID nodeId=entry.getKey();
    if (!nodes.containsKey(nodeId) && nodeId.equals(cctx.localNodeId()))     continue;
    if (nodeId.equals(failedNodeId)) {
      for (      UUID id : entry.getValue()) {
        if (txNodes.containsKey(id) || id.equals(cctx.localNodeId()))         continue;
        MiniFuture fut=new MiniFuture(id);
        add(fut);
        GridCacheTxRecoveryRequest req=new GridCacheTxRecoveryRequest(tx,nodeTransactions(id),false,futureId(),fut.futureId());
        try {
          cctx.io().send(id,req,tx.ioPolicy());
        }
 catch (        ClusterTopologyCheckedException ignored) {
          fut.onNodeLeft();
        }
catch (        IgniteCheckedException e) {
          fut.onError(e);
          break;
        }
      }
    }
 else {
      MiniFuture fut=new MiniFuture(nodeId);
      add(fut);
      GridCacheTxRecoveryRequest req=new GridCacheTxRecoveryRequest(tx,nodeTransactions(nodeId),false,futureId(),fut.futureId());
      try {
        cctx.io().send(nodeId,req,tx.ioPolicy());
      }
 catch (      ClusterTopologyCheckedException ignored) {
        fut.onNodeLeft();
      }
catch (      IgniteCheckedException e) {
        fut.onError(e);
        break;
      }
    }
  }
  markInitialized();
}
