{
  GridCacheVersion clearVer=cctx.versions().next();
  boolean swap=cctx.isSwapOrOffheapEnabled();
  boolean rec=cctx.events().isRecordable(EVT_CACHE_PRELOAD_OBJECT_UNLOADED);
  boolean locStore=cctx.store().isLocalStore();
  for (Iterator<GridDhtCacheEntry<K,V>> it=map.values().iterator(); it.hasNext(); ) {
    GridDhtCacheEntry<K,V> cached=it.next();
    try {
      if (cached.clearInternal(clearVer,swap)) {
        it.remove();
        if (locStore)         cctx.store().removeFromStore(null,cached.key());
        if (!cached.isInternal()) {
          mapPubSize.decrement();
          if (rec)           cctx.events().addEvent(cached.partition(),cached.key(),cctx.localNodeId(),(IgniteUuid)null,null,EVT_CACHE_PRELOAD_OBJECT_UNLOADED,null,false,cached.rawGet(),cached.hasValue(),null,null,null);
        }
      }
    }
 catch (    IgniteCheckedException e) {
      U.error(log,"Failed to clear cache entry for evicted partition: " + cached,e);
    }
  }
}
