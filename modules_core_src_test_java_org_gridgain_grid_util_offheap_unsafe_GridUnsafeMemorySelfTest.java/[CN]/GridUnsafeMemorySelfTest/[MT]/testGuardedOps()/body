{
  final AtomicReferenceArray<CmpMem> ptrs=new AtomicReferenceArray<>(4);
  final AtomicBoolean finished=new AtomicBoolean();
  final LongAdder cntr=new LongAdder();
  final GridUnsafeGuard guard=new GridUnsafeGuard();
  GridFuture<?> fut=multithreadedAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      Random rnd=new GridRandom();
      while (!finished.get()) {
        int idx=rnd.nextInt(ptrs.length());
        guard.begin();
        try {
          final CmpMem old;
          CmpMem ptr=null;
switch (rnd.nextInt(10)) {
case 0:
            ptr=new CmpMem(cntr);
case 1:
          old=ptrs.getAndSet(idx,ptr);
        if (old != null) {
          guard.finalizeLater(new Runnable(){
            @Override public void run(){
              old.deallocate();
            }
          }
);
        }
      break;
case 2:
    if (rnd.nextBoolean())     ptr=new CmpMem(cntr);
  old=ptrs.getAndSet(idx,ptr);
if (old != null) guard.releaseLater(old);
break;
default :
old=ptrs.get(idx);
if (old != null) old.touch();
}
}
  finally {
guard.end();
}
}
return null;
}
}
,37);
Thread.sleep(60000);
finished.set(true);
fut.get();
for (int i=0; i < ptrs.length(); i++) {
CmpMem ptr=ptrs.get(i);
if (ptr != null) {
ptr.touch();
ptr.deallocate();
}
}
assertEquals(0,cntr.sum());
}
