{
  try {
    long topVer;
    do {
      topVer=ctx.affinity().affinityTopologyVersion();
      Collection<ClusterNode> nodes=ctx.grid().forCache(name()).nodes();
      IgniteFuture<Object> fut=null;
      if (!nodes.isEmpty())       fut=ctx.closures().callAsyncNoFailover(BROADCAST,new GlobalRemoveAllCallable<>(name(),topVer,REMOVE_ALL_BATCH_SIZE),nodes,true);
      if (fut != null)       fut.get();
    }
 while (ctx.affinity().affinityTopologyVersion() > topVer);
  }
 catch (  ClusterGroupEmptyException ignore) {
    if (log.isDebugEnabled())     log.debug("All remote nodes left while cache remove [cacheName=" + name() + "]");
  }
catch (  ComputeTaskTimeoutException e) {
    U.warn(log,"Timed out waiting for remote nodes to finish cache remove (consider increasing " + "'networkTimeout' configuration property) [cacheName=" + name() + "]");
    throw e;
  }
}
