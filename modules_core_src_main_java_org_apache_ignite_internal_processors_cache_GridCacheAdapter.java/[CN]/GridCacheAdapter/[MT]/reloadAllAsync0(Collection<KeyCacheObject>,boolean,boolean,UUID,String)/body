{
  final AffinityTopologyVersion topVer=ctx.affinity().affinityTopologyVersion();
  if (!F.isEmpty(keys)) {
    final Map<KeyCacheObject,GridCacheVersion> keyVers=new HashMap();
    for (    KeyCacheObject key : keys) {
      if (key == null)       continue;
      if (ctx.isNear() && ctx.affinity().localNode(key,topVer))       continue;
      while (true) {
        try {
          GridCacheEntryEx entry=entryExSafe(key,topVer);
          if (entry == null)           break;
          GridCacheVersion ver=entry.version();
          keyVers.put(key,ver);
          break;
        }
 catch (        GridCacheEntryRemovedException ignore) {
          if (log.isDebugEnabled())           log.debug("Got removed entry for reload (will retry): " + key);
        }
catch (        GridDhtInvalidPartitionException ignore) {
          if (log.isDebugEnabled())           log.debug("Got invalid partition for key (will skip): " + key);
          break;
        }
      }
    }
    final Map<KeyCacheObject,CacheObject> map=ret ? U.<KeyCacheObject,CacheObject>newHashMap(keys.size()) : null;
    final Collection<KeyCacheObject> absentKeys=F.view(keyVers.keySet());
    final Collection<KeyCacheObject> loadedKeys=new GridConcurrentHashSet<>();
    IgniteInternalFuture<Object> readFut=readThroughAllAsync(absentKeys,true,skipVals,null,subjId,taskName,new CI2<KeyCacheObject,Object>(){
      /** 
 * Version for all loaded entries. 
 */
      private GridCacheVersion nextVer=ctx.versions().next();
      /** 
 * {@inheritDoc} 
 */
      @Override public void apply(      KeyCacheObject key,      Object val){
        loadedKeys.add(key);
        GridCacheEntryEx entry=peekEx(key);
        if (entry != null) {
          try {
            GridCacheVersion curVer=keyVers.get(key);
            if (curVer != null) {
              boolean wasNew=entry.isNewLocked();
              entry.unswap();
              CacheObject cacheVal=ctx.toCacheObject(val);
              boolean set=entry.versionedValue(cacheVal,curVer,nextVer);
              ctx.evicts().touch(entry,topVer);
              if (map != null) {
                if (set || wasNew)                 map.put(key,cacheVal);
 else {
                  CacheObject v=entry.peek(true,false,false,null);
                  if (v != null)                   map.put(key,v);
                }
              }
              if (log.isDebugEnabled()) {
                log.debug("Set value loaded from store into entry [set=" + set + ", "+ "newVer="+ nextVer+ ", entry="+ entry+ ']');
              }
            }
 else {
              if (log.isDebugEnabled()) {
                log.debug("Current version was not found (either entry was removed or " + "validation was not passed: " + entry);
              }
            }
          }
 catch (          GridCacheEntryRemovedException ignore) {
            if (log.isDebugEnabled()) {
              log.debug("Got removed entry for reload (will not store reloaded entry) " + "[entry=" + entry + ']');
            }
          }
catch (          IgniteCheckedException e) {
            throw new IgniteException(e);
          }
        }
      }
    }
);
    return readFut.chain(new CX1<IgniteInternalFuture<Object>,Map<KeyCacheObject,CacheObject>>(){
      @Override public Map<KeyCacheObject,CacheObject> applyx(      IgniteInternalFuture<Object> e) throws IgniteCheckedException {
        for (        KeyCacheObject key : absentKeys) {
          if (!loadedKeys.contains(key)) {
            GridCacheEntryEx entry=peekEx(key);
            if (entry != null)             ctx.evicts().touch(entry,topVer);
          }
        }
        e.get();
        return map;
      }
    }
);
  }
  return new GridFinishedFuture<>(Collections.<KeyCacheObject,CacheObject>emptyMap());
}
