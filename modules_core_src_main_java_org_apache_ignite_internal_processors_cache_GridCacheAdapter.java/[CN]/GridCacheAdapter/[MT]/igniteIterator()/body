{
  GridCacheContext ctx0=ctx.isNear() ? ctx.near().dht().context() : ctx;
  if (!ctx0.isSwapOrOffheapEnabled() && ctx0.kernalContext().discovery().size() == 1)   return localIteratorHonorExpirePolicy();
  final GridCacheProjectionImpl<K,V> prj=ctx.projectionPerCall();
  CacheQueryFuture<Map.Entry<K,V>> fut=queries().createScanQuery(null).keepAll(false).execute();
  return ctx.itHolder().iterator(fut,new CacheIteratorConverter<Cache.Entry<K,V>,Map.Entry<K,V>>(){
    @Override protected Cache.Entry<K,V> convert(    Map.Entry<K,V> e){
      return new CacheEntryImpl<>(e.getKey(),e.getValue());
    }
    @Override protected void remove(    Cache.Entry<K,V> item){
      GridCacheProjectionImpl<K,V> prev=ctx.gate().enter(prj);
      try {
        GridCacheAdapter.this.remove(item.getKey());
      }
 catch (      IgniteCheckedException e) {
        throw CU.convertToCacheException(e);
      }
 finally {
        ctx.gate().leave(prev);
      }
    }
  }
);
}
