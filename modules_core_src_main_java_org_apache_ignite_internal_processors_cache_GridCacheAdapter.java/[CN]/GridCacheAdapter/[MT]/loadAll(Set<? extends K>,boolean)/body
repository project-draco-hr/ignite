{
  A.notNull(keys,"keys");
  for (  Object key : keys)   A.notNull(key,"key");
  if (!ctx.store().configured())   return new GridFinishedFuture<>(ctx.kernalContext());
  GridCacheProjectionImpl<K,V> prj=ctx.projectionPerCall();
  ExpiryPolicy plc=prj != null ? prj.expiry() : null;
  final Collection<? extends K> keys0;
  if (ctx.portableEnabled() && !ctx.store().convertPortable()) {
    keys0=F.viewReadOnly(keys,new C1<K,K>(){
      @Override public K apply(      K k){
        return (K)ctx.marshalToPortable(k);
      }
    }
);
  }
 else   keys0=keys;
  if (replaceExisting) {
    if (ctx.store().isLocalStore()) {
      Collection<ClusterNode> nodes=ctx.grid().forDataNodes(name()).nodes();
      if (nodes.isEmpty())       return new GridFinishedFuture<>(ctx.kernalContext());
      return ctx.closures().callAsyncNoFailover(BROADCAST,new LoadKeysCallable<>(ctx.name(),keys0,true,plc),nodes,true);
    }
 else {
      return ctx.closures().callLocalSafe(new Callable<Void>(){
        @Override public Void call() throws Exception {
          localLoadAndUpdate(keys0);
          return null;
        }
      }
);
    }
  }
 else {
    Collection<ClusterNode> nodes=ctx.grid().forDataNodes(name()).nodes();
    if (nodes.isEmpty())     return new GridFinishedFuture<>(ctx.kernalContext());
    return ctx.closures().callAsyncNoFailover(BROADCAST,new LoadKeysCallable<>(ctx.name(),keys,false,plc),nodes,true);
  }
}
