{
  A.notNull(keys,"keys");
  for (  Object key : keys)   A.notNull(key,"key");
  if (!ctx.store().configured())   return new GridFinishedFuture<>();
  CacheProjectionContext<K,V> prj=ctx.projectionPerCall();
  ExpiryPolicy plc=prj != null ? prj.expiry() : null;
  if (replaceExisting) {
    if (ctx.store().isLocal()) {
      Collection<ClusterNode> nodes=ctx.grid().cluster().forDataNodes(name()).nodes();
      if (nodes.isEmpty())       return new GridFinishedFuture<>();
      return ctx.closures().callAsyncNoFailover(BROADCAST,new LoadKeysCallable<>(ctx.name(),keys,true,plc),nodes,true);
    }
 else {
      return ctx.closures().callLocalSafe(new Callable<Void>(){
        @Override public Void call() throws Exception {
          localLoadAndUpdate(keys);
          return null;
        }
      }
);
    }
  }
 else {
    Collection<ClusterNode> nodes=ctx.grid().cluster().forDataNodes(name()).nodes();
    if (nodes.isEmpty())     return new GridFinishedFuture<>();
    return ctx.closures().callAsyncNoFailover(BROADCAST,new LoadKeysCallable<>(ctx.name(),keys,false,plc),nodes,true);
  }
}
