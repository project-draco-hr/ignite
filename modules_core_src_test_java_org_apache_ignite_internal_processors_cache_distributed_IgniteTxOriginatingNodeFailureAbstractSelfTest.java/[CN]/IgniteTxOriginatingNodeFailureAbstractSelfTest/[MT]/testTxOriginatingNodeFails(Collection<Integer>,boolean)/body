{
  assertFalse(keys.isEmpty());
  final Collection<IgniteKernal> grids=new ArrayList<>();
  ClusterNode txNode=grid(originatingNode()).localNode();
  for (int i=1; i < gridCount(); i++)   grids.add((IgniteKernal)grid(i));
  final Map<Integer,String> map=new HashMap<>();
  final String initVal="initialValue";
  for (  Integer key : keys) {
    grid(originatingNode()).cache(null).put(key,initVal);
    map.put(key,String.valueOf(key));
  }
  Map<Integer,Collection<ClusterNode>> nodeMap=new HashMap<>();
  GridCacheAdapter<Integer,String> cache=((IgniteKernal)grid(1)).internalCache();
  info("Node being checked: " + grid(1).localNode().id());
  for (  Integer key : keys) {
    Collection<ClusterNode> nodes=new ArrayList<>();
    nodes.addAll(cache.affinity().mapKeyToPrimaryAndBackups(key));
    nodes.remove(txNode);
    nodeMap.put(key,nodes);
  }
  info("Starting tx [values=" + map + ", topVer="+ ((IgniteKernal)grid(1)).context().discovery().topologyVersion()+ ']');
  if (partial)   ignoreMessages(grid(1).localNode().id(),ignoreMessageClass());
  final Ignite txIgniteNode=G.ignite(txNode.id());
  GridTestUtils.runAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      IgniteCache<Integer,String> cache=txIgniteNode.cache(null);
      assertNotNull(cache);
      TransactionProxyImpl tx=(TransactionProxyImpl)txIgniteNode.transactions().txStart();
      IgniteInternalTx txEx=GridTestUtils.getFieldValue(tx,"tx");
      cache.putAll(map);
      try {
        txEx.prepareAsync().get(3,TimeUnit.SECONDS);
      }
 catch (      IgniteFutureTimeoutCheckedException ignored) {
        info("Failed to wait for prepare future completion: " + partial);
      }
      return null;
    }
  }
).get();
  info("Stopping originating node " + txNode);
  G.stop(G.ignite(txNode.id()).name(),true);
  info("Stopped grid, waiting for transactions to complete.");
  boolean txFinished=GridTestUtils.waitForCondition(new GridAbsPredicate(){
    @Override public boolean apply(){
      for (      IgniteKernal g : grids) {
        GridCacheSharedContext<Object,Object> ctx=g.context().cache().context();
        int txNum=ctx.tm().idMapSize();
        if (txNum != 0)         return false;
      }
      return true;
    }
  }
,10000);
  assertTrue(txFinished);
  info("Transactions finished.");
  for (  Map.Entry<Integer,Collection<ClusterNode>> e : nodeMap.entrySet()) {
    final Integer key=e.getKey();
    final String val=map.get(key);
    assertFalse(e.getValue().isEmpty());
    for (    ClusterNode node : e.getValue()) {
      compute(G.ignite(node.id()).cluster().forNode(node)).call(new IgniteCallable<Void>(){
        /** 
 */
        @IgniteInstanceResource private Ignite ignite;
        @Override public Void call() throws Exception {
          IgniteCache<Integer,String> cache=ignite.cache(null);
          assertNotNull(cache);
          assertEquals(partial ? initVal : val,cache.localPeek(key,CachePeekMode.ONHEAP));
          return null;
        }
      }
);
    }
  }
  for (  Map.Entry<Integer,String> e : map.entrySet()) {
    for (    Ignite g : G.allGrids()) {
      UUID locNodeId=g.cluster().localNode().id();
      assertEquals("Check failed for node: " + locNodeId,partial ? initVal : e.getValue(),g.cache(null).get(e.getKey()));
    }
  }
}
