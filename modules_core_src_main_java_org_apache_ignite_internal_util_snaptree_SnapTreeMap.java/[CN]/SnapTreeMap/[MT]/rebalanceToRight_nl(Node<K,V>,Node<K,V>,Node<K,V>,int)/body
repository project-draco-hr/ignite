{
synchronized (nL) {
    final int hL=nL.height;
    if (hL - hR0 <= 1) {
      return n;
    }
 else {
      final Node<K,V> nLR=nL.unsharedRight();
      final int hLL0=height(nL.left);
      final int hLR0=height(nLR);
      if (hLL0 >= hLR0) {
        return rotateRight_nl(nParent,n,nL,hR0,hLL0,nLR,hLR0);
      }
 else {
synchronized (nLR) {
          final int hLR=nLR.height;
          if (hLL0 >= hLR) {
            return rotateRight_nl(nParent,n,nL,hR0,hLL0,nLR,hLR);
          }
 else {
            final int hLRL=height(nLR.left);
            final int b=hLL0 - hLRL;
            if (b >= -1 && b <= 1 && !((hLL0 == 0 || hLRL == 0) && nL.vOpt == null)) {
              return rotateRightOverLeft_nl(nParent,n,nL,hR0,hLL0,nLR,hLRL);
            }
          }
        }
        return rebalanceToLeft_nl(n,nL,nLR,hLL0);
      }
    }
  }
}
