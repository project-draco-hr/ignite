{
  try {
    startGrids(gridCount());
    awaitPartitionMapExchange();
    for (int i=0; i < gridCount(); i++)     info("Grid " + i + ": "+ ignite(i).cluster().localNode().id());
    final Ignite ignite=ignite(0);
    final IgniteCache<Object,Object> cache=ignite.cache(null).withNoRetries();
    final int key=generateKey(ignite,backup);
    IgniteEx backupNode=(IgniteEx)backupNode(key,null);
    assertNotNull(backupNode);
    final CountDownLatch commitLatch=new CountDownLatch(1);
    if (!commit)     communication(1).bannedClasses(Collections.<Class>singletonList(GridDhtTxPrepareRequest.class));
 else {
      if (!backup) {
        communication(2).bannedClasses(Collections.<Class>singletonList(GridDhtTxPrepareResponse.class));
        communication(3).bannedClasses(Collections.<Class>singletonList(GridDhtTxPrepareResponse.class));
      }
 else       communication(0).bannedClasses(Collections.<Class>singletonList(GridDhtTxPrepareResponse.class));
    }
    IgniteInternalFuture<Object> fut=GridTestUtils.runAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        if (conc != null) {
          try (Transaction tx=ignite.transactions().txStart(conc,REPEATABLE_READ)){
            cache.put(key,key);
            Transaction asyncTx=(Transaction)tx.withAsync();
            asyncTx.commit();
            commitLatch.countDown();
            try {
              IgniteFuture<Object> fut=asyncTx.future();
              fut.get();
              if (!commit) {
                error("Transaction has been committed");
                fail("Transaction has been committed: " + tx);
              }
            }
 catch (            TransactionRollbackException e) {
              if (commit) {
                error(e.getMessage(),e);
                fail("Failed to commit: " + e);
              }
 else               assertTrue(X.hasCause(e,TransactionRollbackException.class));
            }
          }
         }
 else {
          IgniteCache<Object,Object> cache0=cache.withAsync();
          cache0.put(key,key);
          Thread.sleep(1000);
          commitLatch.countDown();
          try {
            cache0.future().get();
            if (!commit) {
              error("Transaction has been committed");
              fail("Transaction has been committed.");
            }
          }
 catch (          CacheException e) {
            if (commit) {
              error(e.getMessage(),e);
              fail("Failed to commit: " + e);
            }
 else             assertTrue(X.hasCause(e,TransactionRollbackException.class));
          }
        }
        return null;
      }
    }
,"tx-thread");
    commitLatch.await();
    stopGrid(1);
    fut.get();
    awaitPartitionMapExchange();
    assertEquals(0,((IgniteEx)ignite(0)).context().cache().context().tm().idMapSize());
    assertEquals(0,((IgniteEx)ignite(2)).context().cache().context().tm().idMapSize());
    assertEquals(0,((IgniteEx)ignite(3)).context().cache().context().tm().idMapSize());
    dataCheck((IgniteKernal)ignite(0),(IgniteKernal)backupNode,key,commit);
  }
  finally {
    stopAllGrids();
  }
}
