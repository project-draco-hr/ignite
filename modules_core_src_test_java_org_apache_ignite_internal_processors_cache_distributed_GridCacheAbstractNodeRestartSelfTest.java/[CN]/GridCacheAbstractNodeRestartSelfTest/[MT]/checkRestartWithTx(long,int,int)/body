{
  final long endTime=System.currentTimeMillis() + duration;
  final AtomicReference<Throwable> err=new AtomicReference<>();
  startGrids();
  Collection<Thread> threads=new LinkedList<>();
  try {
    final int logFreq=20;
    final AtomicInteger txCntr=new AtomicInteger();
    final CyclicBarrier barrier=new CyclicBarrier(putThreads + restartThreads);
    final int txKeys=3;
    for (int i=0; i < putThreads; i++) {
      final int gridIdx=i;
      Thread t=new Thread(new Runnable(){
        @Override public void run(){
          try {
            barrier.await();
            info("Starting put thread...");
            Ignite ignite=grid(gridIdx);
            UUID locNodeId=ignite.cluster().localNode().id();
            GridCache<Integer,String> cache=ignite.cache(CACHE_NAME);
            List<Integer> keys=new ArrayList<>(txKeys);
            while (System.currentTimeMillis() < endTime && err.get() == null) {
              keys.clear();
              for (int i=0; i < txKeys; i++)               keys.add(RAND.nextInt(keyCnt));
              Collections.sort(keys);
              int c=0;
              try {
                try (IgniteTx tx=cache.txStart(txConcurrency(),REPEATABLE_READ)){
                  c=txCntr.incrementAndGet();
                  if (c % logFreq == 0)                   info(">>> Tx iteration started [cnt=" + c + ", keys="+ keys+ ", "+ "locNodeId="+ locNodeId+ ']');
                  for (                  int key : keys) {
                    int op=cacheOp();
                    if (op == 1)                     cache.put(key,Integer.toString(key));
 else                     if (op == 2)                     cache.remove(key);
 else                     cache.get(key);
                  }
                  tx.commit();
                }
 catch (                ClusterTopologyCheckedException ignored) {
                }
              }
 catch (              ClusterTopologyCheckedException ignored) {
              }
              if (c % logFreq == 0)               info(">>> Tx iteration finished [cnt=" + c + ", keys="+ keys+ ", "+ "locNodeId="+ locNodeId+ ']');
            }
            info(">>> " + Thread.currentThread().getName() + " finished.");
          }
 catch (          Exception e) {
            err.compareAndSet(null,e);
            error("Failed to put value in cache.",e);
          }
        }
      }
,"put-worker-" + i);
      t.start();
      threads.add(t);
    }
    for (int i=0; i < restartThreads; i++) {
      final int gridIdx=i + putThreads;
      Thread t=new Thread(new Runnable(){
        @Override public void run(){
          try {
            barrier.await();
            info("Starting restart thread...");
            int cnt=0;
            while (System.currentTimeMillis() < endTime && err.get() == null) {
              stopGrid(gridIdx);
              startGrid(gridIdx);
              int c=++cnt;
              if (c % logFreq == 0)               info(">>> Restart iteration: " + c);
            }
            info(">>> " + Thread.currentThread().getName() + " finished.");
          }
 catch (          Exception e) {
            err.compareAndSet(null,e);
            error("Failed to restart grid node.",e);
          }
        }
      }
,"restart-worker-" + i);
      t.start();
      threads.add(t);
    }
    for (    Thread t : threads)     t.join();
    if (err.get() != null)     throw err.get();
  }
  finally {
    stopAllGrids();
  }
}
