{
  int endSize=nearEnabled ? 0 : plcMax;
  int endPlcSize=nearEnabled ? 0 : plcMax;
  startGridsMultiThreaded(gridCnt);
  try {
    Random rand=new Random();
    int cnt=500;
    for (int i=0; i < cnt; i++) {
      IgniteCache<Integer,String> cache=grid(rand.nextInt(2)).cache(null);
      int key=rand.nextInt(100);
      String val=Integer.toString(key);
      cache.put(key,val);
      if (i % 100 == 0)       info("Stored cache object for key [key=" + key + ", idx="+ i+ ']');
    }
    if (nearEnabled) {
      for (int i=0; i < gridCnt; i++)       assertEquals(endSize,near(i).nearSize());
      if (endPlcSize >= 0)       checkNearPolicies(endPlcSize);
    }
 else {
      if (plcMaxMemSize > 0) {
        for (int i=0; i < gridCnt; i++) {
          GridDhtColocatedCache<Object,Object> cache=colocated(i);
          int memSize=0;
          for (          Cache.Entry<Object,Object> entry : cache.entrySet())           memSize+=entry.unwrap(EvictableEntry.class).size();
          EvictionPolicyProxy plc=proxy(policy(i));
          assertTrue(plc.getCurrentMemSize() <= memSize);
        }
      }
      if (plcMax > 0) {
        for (int i=0; i < gridCnt; i++) {
          int actual=colocated(i).size();
          assertTrue("Cache size is greater then policy size [expected=" + endSize + ", actual="+ actual+ ']',actual <= endSize + (plcMaxMemSize > 0 ? 1 : plcBatchSize));
        }
      }
      checkPolicies();
    }
  }
  finally {
    stopAllGrids();
  }
}
