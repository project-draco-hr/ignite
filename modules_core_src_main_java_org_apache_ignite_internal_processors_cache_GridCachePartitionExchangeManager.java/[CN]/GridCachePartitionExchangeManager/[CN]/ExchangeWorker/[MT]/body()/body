{
  long timeout=cctx.gridConfig().getNetworkTimeout();
  boolean startEvtFired=false;
  int cnt=0;
  IgniteInternalFuture asyncStartFut=null;
  while (!isCancelled()) {
    GridDhtPartitionsExchangeFuture exchFut=null;
    cnt++;
    try {
      boolean preloadFinished=true;
      for (      GridCacheContext cacheCtx : cctx.cacheContexts()) {
        preloadFinished&=cacheCtx.preloader().syncFuture().isDone();
        if (!preloadFinished)         break;
      }
      if (!cctx.kernalContext().clientNode() && futQ.isEmpty() && preloadFinished) {
        refreshPartitions(timeout);
        timeout=cctx.gridConfig().getNetworkTimeout();
      }
      if (log.isDebugEnabled())       log.debug("Before waiting for exchange futures [futs" + F.view(exchFuts.values(),F.unfinishedFutures()) + ", worker="+ this+ ']');
      exchFut=poll(futQ,timeout,this);
      if (exchFut == null)       continue;
      busy=true;
      Map<Integer,GridDhtPreloaderAssignments> assignsMap=null;
      boolean dummyReassign=exchFut.dummyReassign();
      boolean forcePreload=exchFut.forcePreload();
      try {
        if (isCancelled())         break;
        if (!exchFut.dummy() && !exchFut.forcePreload()) {
          lastInitializedFut=exchFut;
          exchFut.init();
          exchFut.get();
          if (log.isDebugEnabled())           log.debug("After waiting for exchange future [exchFut=" + exchFut + ", worker="+ this+ ']');
          if (exchFut.exchangeId().nodeId().equals(cctx.localNodeId()))           lastRefresh.compareAndSet(-1,U.currentTimeMillis());
          boolean changed=false;
          for (          GridCacheContext cacheCtx : cctx.cacheContexts()) {
            if (cacheCtx.isLocal())             continue;
            changed|=cacheCtx.topology().afterExchange(exchFut);
            if (!exchFut.skipPreload() && cacheCtx.events().isRecordable(EVT_CACHE_REBALANCE_STARTED)) {
              if (!cacheCtx.isReplicated() || !startEvtFired) {
                DiscoveryEvent discoEvt=exchFut.discoveryEvent();
                cacheCtx.events().addPreloadEvent(-1,EVT_CACHE_REBALANCE_STARTED,discoEvt.eventNode(),discoEvt.type(),discoEvt.timestamp());
              }
            }
          }
          startEvtFired=true;
          if (!cctx.kernalContext().clientNode() && changed && futQ.isEmpty())           refreshPartitions();
        }
 else {
          if (log.isDebugEnabled())           log.debug("Got dummy exchange (will reassign)");
          if (!dummyReassign) {
            timeout=0;
            continue;
          }
        }
        if (!exchFut.skipPreload()) {
          assignsMap=new HashMap<>();
          for (          GridCacheContext cacheCtx : cctx.cacheContexts()) {
            long delay=cacheCtx.config().getRebalanceDelay();
            GridDhtPreloaderAssignments assigns=null;
            if (delay == 0 || forcePreload)             assigns=cacheCtx.preloader().assign(exchFut);
            assignsMap.put(cacheCtx.cacheId(),assigns);
          }
        }
      }
  finally {
        busy=false;
      }
      if (assignsMap != null) {
        int size=assignsMap.size();
        rebalanceQ.clear();
        NavigableMap<Integer,List<Integer>> orderMap=new TreeMap<>();
        for (        Map.Entry<Integer,GridDhtPreloaderAssignments> e : assignsMap.entrySet()) {
          int cacheId=e.getKey();
          GridCacheContext<K,V> cacheCtx=cctx.cacheContext(cacheId);
          int order=cacheCtx.config().getRebalanceOrder();
          if (orderMap.get(order) == null)           orderMap.put(order,new ArrayList<Integer>(size));
          orderMap.get(order).add(cacheId);
        }
        Callable<Boolean> marshR=null;
        List<Callable<Boolean>> orderedRs=new ArrayList<>(size);
        for (        Integer order : orderMap.keySet()) {
          for (          Integer cacheId : orderMap.get(order)) {
            GridCacheContext<K,V> cacheCtx=cctx.cacheContext(cacheId);
            List<String> waitList=new ArrayList<>(size - 1);
            for (            List<Integer> cIds : orderMap.headMap(order).values()) {
              for (              Integer cId : cIds)               waitList.add(cctx.cacheContext(cId).name());
            }
            Callable<Boolean> r=cacheCtx.preloader().addAssignments(assignsMap.get(cacheId),forcePreload,waitList,cnt);
            if (r != null) {
              U.log(log,"Cache rebalancing scheduled: [cache=" + cacheCtx.name() + ", waitList="+ waitList.toString()+ "]");
              if (cacheId == CU.cacheId(GridCacheUtils.MARSH_CACHE_NAME))               marshR=r;
 else               orderedRs.add(r);
            }
          }
        }
        if (asyncStartFut != null)         asyncStartFut.get();
        rebalanceQ.addAll(orderedRs);
        if (marshR != null || !rebalanceQ.isEmpty()) {
          if (futQ.isEmpty()) {
            U.log(log,"Rebalancing required" + "[top=" + exchFut.topologyVersion() + ", evt="+ exchFut.discoveryEvent().name()+ ", node="+ exchFut.discoveryEvent().eventNode().id()+ ']');
            if (marshR != null) {
              try {
                marshR.call();
              }
 catch (              Exception ex) {
                if (log.isDebugEnabled())                 log.debug("Failed to send initial demand request to node");
                continue;
              }
            }
            final GridFutureAdapter fut=new GridFutureAdapter();
            asyncStartFut=fut;
            cctx.kernalContext().closure().callLocalSafe(new GPC<Boolean>(){
              @Override public Boolean call(){
                try {
                  while (true) {
                    Callable<Boolean> r=rebalanceQ.poll();
                    if (r == null)                     return false;
                    if (!r.call())                     return false;
                  }
                }
 catch (                Exception ex) {
                  if (log.isDebugEnabled())                   log.debug("Failed to send initial demand request to node");
                  return false;
                }
 finally {
                  fut.onDone();
                }
              }
            }
,true);
          }
 else {
            U.log(log,"Skipping rebalancing (obsolete exchange ID) " + "[top=" + exchFut.topologyVersion() + ", evt="+ exchFut.discoveryEvent().name()+ ", node="+ exchFut.discoveryEvent().eventNode().id()+ ']');
          }
        }
 else {
          U.log(log,"Skipping rebalancing (nothing scheduled) " + "[top=" + exchFut.topologyVersion() + ", evt="+ exchFut.discoveryEvent().name()+ ", node="+ exchFut.discoveryEvent().eventNode().id()+ ']');
        }
      }
    }
 catch (    IgniteInterruptedCheckedException e) {
      throw e;
    }
catch (    IgniteClientDisconnectedCheckedException e) {
      return;
    }
catch (    IgniteCheckedException e) {
      U.error(log,"Failed to wait for completion of partition map exchange " + "(preloading will not start): " + exchFut,e);
    }
  }
}
