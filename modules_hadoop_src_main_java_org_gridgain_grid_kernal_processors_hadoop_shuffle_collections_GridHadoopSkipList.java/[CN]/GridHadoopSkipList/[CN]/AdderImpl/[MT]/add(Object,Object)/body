{
  long valPtr=0;
  if (val != null) {
    valPtr=write(12,val,valSer);
    int valSize=writtenSize() - 12;
    valueSize(valPtr,valSize);
  }
  long keyPtr=0;
  long newMeta=0;
  int newMetaLevel=-1;
  int top=topLevel.get();
  long prevMeta=0;
  long meta=heads.get(top);
  for (int level=top; ; ) {
    while (meta == 0 && level > 0)     meta=nextMeta(prevMeta,--level);
    if (meta == 0 || level < 0) {
      if (keyPtr == 0) {
        keyPtr=writeKey(key);
        newMetaLevel=randomLevel(rnd);
        newMeta=createMeta(keyPtr,valPtr,newMetaLevel,meta);
      }
      if (casNextMeta(prevMeta,0,meta,newMeta)) {
        laceUp(newMeta,newMetaLevel);
        return newMeta;
      }
 else {
        meta=nextMeta(prevMeta,0);
        continue;
      }
    }
    Object k=keyReader.readKey(meta);
    int res=cmp.compare(key,k);
    if (res == 0) {
      if (newMeta != 0)       localDeallocate(keyPtr);
      if (valPtr == 0)       return meta;
      for (; ; ) {
        long nextVal=value(meta);
        nextValue(valPtr,nextVal);
        if (casValue(meta,nextVal,valPtr))         return meta;
      }
    }
    if (res > 0) {
      prevMeta=meta;
      meta=nextMeta(meta,level);
    }
 else     --level;
  }
}
