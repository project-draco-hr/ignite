{
  final int ENTRY_CNT=500;
  Map<Integer,Map<Key,Person>> entries=new HashMap<>();
  for (int i=0; i < ENTRY_CNT; i++) {
    Key key=new Key(i);
    Person val=new Person("p-" + i,i);
    int part=cache.context().affinity().partition(key);
    cache.getAndPut(key,val);
    Map<Key,Person> partEntries=entries.get(part);
    if (partEntries == null)     entries.put(part,partEntries=new HashMap<>());
    partEntries.put(key,val);
  }
  try {
    int partitions=scanPartitions ? cache.context().affinity().partitions() : 1;
    for (int i=0; i < partitions; i++) {
      CacheQuery<Map.Entry<Key,Person>> qry=cache.context().queries().createScanQuery(new IgniteBiPredicate<Key,Person>(){
        @Override public boolean apply(        Key key,        Person p){
          assertEquals(key.id,(Integer)p.salary);
          return key.id % 2 == 0;
        }
      }
,(scanPartitions ? i : null),false);
      Collection<Map.Entry<Key,Person>> res=qry.execute().get();
      if (!scanPartitions)       assertEquals(ENTRY_CNT / 2,res.size());
      for (      Map.Entry<Key,Person> e : res) {
        Key k=e.getKey();
        Person p=e.getValue();
        assertEquals(k.id,(Integer)p.salary);
        assertEquals(0,k.id % 2);
        if (scanPartitions) {
          Map<Key,Person> partEntries=entries.get(i);
          assertEquals(p,partEntries.get(k));
        }
      }
      qry=cache.context().queries().createScanQuery(null,(scanPartitions ? i : null),false);
      res=qry.execute().get();
      if (!scanPartitions)       assertEquals(ENTRY_CNT,res.size());
    }
    testMultithreaded(cache,ENTRY_CNT / 2);
  }
  finally {
    for (int i=0; i < ENTRY_CNT; i++)     assertTrue(cache.remove(new Key(i)));
  }
}
