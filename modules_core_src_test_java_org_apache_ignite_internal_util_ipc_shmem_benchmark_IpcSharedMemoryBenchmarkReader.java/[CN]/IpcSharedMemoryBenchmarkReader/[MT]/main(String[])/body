{
  IpcSharedMemoryNativeLoader.load();
  int nThreads=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  final AtomicLong transferCntr=new AtomicLong();
  Thread collector=new Thread(new Runnable(){
    @SuppressWarnings("BusyWait") @Override public void run(){
      try {
        while (!done) {
          Thread.sleep(5000);
          X.println("Transfer rate: " + transferCntr.getAndSet(0) / (1024 * 1024 * 5) + " MB/sec");
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
);
  collector.start();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      System.out.println("Shutting down...");
      done=true;
    }
  }
);
  try (IpcSharedMemoryServerEndpoint srv=new IpcSharedMemoryServerEndpoint()){
    new IgniteTestResources().inject(srv);
    srv.start();
    for (int i=0; i < nThreads; i++) {
      final IpcEndpoint endPnt=srv.accept();
      new Thread(new Runnable(){
        @Override public void run(){
          InputStream space=null;
          try {
            space=endPnt.inputStream();
            byte[] buf=new byte[DST_BUFFER_SIZE];
            int pos=0;
            while (!done) {
              int maxRead=Math.min(buf.length - pos,DFLT_BUF_SIZE);
              int read=space.read(buf,pos,maxRead);
              if (read == -1) {
                X.println("Space has been closed");
                return;
              }
              transferCntr.addAndGet(read);
              pos+=read;
              if (pos >= buf.length)               pos=0;
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
 finally {
            U.closeQuiet(space);
          }
        }
      }
).start();
    }
  }
   JOptionPane.showMessageDialog(null,"Press OK to stop READER.");
  done=true;
}
