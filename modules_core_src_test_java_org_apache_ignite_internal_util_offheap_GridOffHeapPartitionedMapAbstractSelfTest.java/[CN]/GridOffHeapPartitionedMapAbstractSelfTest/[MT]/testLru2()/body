{
  mem=1000 + 64 * 16 * parts;
  lruStripes=6;
  concurrency=8;
  final AtomicInteger evictCnt=new AtomicInteger();
  for (int p=0; p < parts; p++) {
    evictLsnr=new GridOffHeapEvictListener(){
      @Override public void onEvict(      int part,      int hash,      byte[] k,      byte[] v){
        evictCnt.incrementAndGet();
      }
    }
;
    map=newMap();
    for (int i=0; i < 10000; i++) {
      String key=string();
      byte[] keyBytes=key.getBytes();
      byte[] valBytes=bytes(100);
      map.insert(p,hash(key),keyBytes,valBytes);
    }
    assertTrue(evictCnt.get() > 10 * parts);
    assertTrue("Invalid map free size [size=" + map.freeSize() + ", evictCnt="+ evictCnt+ ']',map.freeSize() >= 0);
  }
}
