{
  U.sleep(1000);
  int keyCnt=iterationCount() / 10;
  int threadCnt=8;
  final int range=keyCnt / threadCnt;
  for (int r=1; r < 5; r++) {
    final AtomicInteger rangeIdx=new AtomicInteger();
    info(">>>>>> Running iteration: " + r);
    GridTestUtils.runMultiThreaded(new Runnable(){
      @Override public void run(){
        try {
          int rangeStart=rangeIdx.getAndIncrement() * range;
          info("Got range [" + rangeStart + ", "+ (rangeStart + range)+ ")");
          for (int i=rangeStart; i < rangeStart + range; i++) {
            int idx=ThreadLocalRandom8.current().nextInt(gridCount());
            IgniteCache<Integer,Integer> cache=grid(idx).jcache(null);
            cache=((IgniteCacheProxy<Integer,Integer>)cache).flagOn(FORCE_TRANSFORM_BACKUP);
            cache.invoke(i,new Transformer(i));
          }
        }
 catch (        Exception e) {
          throw new IgniteException(e);
        }
      }
    }
,threadCnt,"runner");
    info("Finished run, checking values.");
    U.sleep(500);
    int total=0;
    for (int idx=0; idx < gridCount(); idx++) {
      IgniteCache<Integer,Integer> cache=grid(idx).jcache(null);
      for (int i=0; i < keyCnt; i++) {
        Integer val=cache.localPeek(i,CachePeekMode.ONHEAP);
        if (val != null) {
          assertEquals("Invalid value for key: " + i,(Integer)r,val);
          total++;
        }
      }
    }
    assertTrue("Total keys: " + total,total >= keyCnt * 2);
  }
}
