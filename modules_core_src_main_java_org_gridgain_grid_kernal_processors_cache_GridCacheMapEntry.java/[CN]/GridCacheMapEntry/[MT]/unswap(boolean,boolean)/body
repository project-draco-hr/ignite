{
  boolean swapEnabled=cctx.swap().swapEnabled() && (ignoreFlags || !cctx.hasFlag(SKIP_SWAP));
  if (!swapEnabled && !cctx.isOffHeapEnabled())   return null;
synchronized (this) {
    if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) {
      GridCacheSwapEntry<V> e;
      if (cctx.offheapTiered()) {
        e=cctx.swap().readOffheapPointer(this);
        if (e != null && e.offheapPointer() > 0) {
          valPtr=e.offheapPointer();
          if (needVal) {
            V val=unmarshalOffheap(false);
            e.value(val);
          }
        }
 else         valPtr=0;
      }
 else       e=detached() ? cctx.swap().read(this) : cctx.swap().readAndRemove(this);
      if (log.isDebugEnabled())       log.debug("Read swap entry [swapEntry=" + e + ", cacheEntry="+ this+ ']');
      flags|=IS_UNSWAPPED_MASK;
      if (e != null) {
        long delta=e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis();
        if (delta >= 0) {
          V val=e.value();
          if (cctx.portableEnabled())           val=(V)cctx.kernalContext().portable().detachPortable(val);
          update(val,e.valueBytes(),e.expireTime(),e.ttl(),e.version());
          return val;
        }
 else         clearIndex(e.value());
      }
    }
  }
  return null;
}
