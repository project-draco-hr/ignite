{
  if (log.isDebugEnabled())   log.debug("Scheduling asynchronous refresh for entry: " + this);
  cctx.closures().runLocalSafe(new GPR(){
    @SuppressWarnings({"unchecked"}) @Override public void run(){
      if (log.isDebugEnabled())       log.debug("Refreshing-ahead entry: " + GridCacheMapEntry.this);
synchronized (GridCacheMapEntry.this) {
        if (!matchVer.equals(ver)) {
          refreshingLocked(false);
          if (log.isDebugEnabled())           log.debug("Will not refresh value as entry has been recently updated: " + GridCacheMapEntry.this);
          return;
        }
      }
      V val=null;
      try {
        val=cctx.store().loadFromStore(null,key);
      }
 catch (      IgniteCheckedException e) {
        U.error(log,"Failed to refresh-ahead entry: " + GridCacheMapEntry.this,e);
      }
 finally {
synchronized (GridCacheMapEntry.this) {
          refreshingLocked(false);
          if (val != null && matchVer.equals(ver)) {
            try {
              V prev=rawGetOrUnmarshalUnlocked(false);
              long ttl=ttlExtras();
              long expTime=toExpireTime(ttl);
              if (cctx.portableEnabled())               val=(V)cctx.kernalContext().portable().detachPortable(val);
              updateIndex(val,null,expTime,ver,prev);
              update(val,null,expTime,ttl,ver);
            }
 catch (            IgniteCheckedException e) {
              U.error(log,"Failed to update cache index: " + GridCacheMapEntry.this,e);
            }
          }
        }
      }
    }
  }
,true);
}
