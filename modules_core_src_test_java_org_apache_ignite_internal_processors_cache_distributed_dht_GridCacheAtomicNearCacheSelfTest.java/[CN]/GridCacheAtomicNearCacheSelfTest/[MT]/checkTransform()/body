{
  log.info("Check transform.");
  Ignite ignite0=grid(0);
  IgniteCache<Integer,Integer> cache0=ignite0.jcache(null);
  CacheAffinity<Object> aff=ignite0.affinity(null);
  UUID id0=ignite0.cluster().localNode().id();
  Integer primaryKey=key(ignite0,PRIMARY);
  log.info("Transform from primary.");
  cache0.invoke(primaryKey,new Processor(primaryKey));
  for (int i=0; i < GRID_CNT; i++)   checkEntry(grid(i),primaryKey,primaryKey,false);
  if (backups > 0) {
    Integer backupKey=key(ignite0,BACKUP);
    log.info("Transform from backup.");
    cache0.invoke(backupKey,new Processor(backupKey));
    for (int i=0; i < GRID_CNT; i++)     checkEntry(grid(i),backupKey,backupKey,false);
  }
  Integer nearKey=key(ignite0,NOT_PRIMARY_AND_BACKUP);
  log.info("Transform from near.");
  cache0.invoke(nearKey,new Processor(nearKey));
  for (int i=0; i < GRID_CNT; i++) {
    UUID[] expReaders=aff.isPrimary(grid(i).localNode(),nearKey) ? new UUID[]{id0} : new UUID[]{};
    checkEntry(grid(i),nearKey,nearKey,i == 0,expReaders);
  }
  Collection<UUID> readers=new HashSet<>();
  readers.add(id0);
  int val=nearKey + 1;
  for (int i=0; i < GRID_CNT; i++) {
    delay();
    IgniteCache<Integer,Integer> cache=grid(i).jcache(null);
    log.info("Transform [grid=" + grid(i).name() + ", val="+ val+ ']');
    cache.invoke(nearKey,new Processor(val));
    if (!aff.isPrimaryOrBackup(grid(i).localNode(),nearKey))     readers.add(grid(i).localNode().id());
    for (int j=0; j < GRID_CNT; j++) {
      boolean primaryNode=aff.isPrimary(grid(j).localNode(),nearKey);
      UUID[] expReaders=primaryNode ? U.toArray(readers,new UUID[readers.size()]) : new UUID[]{};
      checkEntry(grid(j),nearKey,val,readers.contains(grid(j).localNode().id()),expReaders);
    }
    val++;
  }
}
