{
  log.info("Check transformAll.");
  Ignite ignite0=grid(0);
  IgniteCache<Integer,Integer> cache0=ignite0.jcache(null);
  CacheAffinity<Object> aff=ignite0.cache(null).affinity();
  UUID id0=ignite0.cluster().localNode().id();
  Set<Integer> primaryKeys=new HashSet<>();
  for (int i=0; i < 10; i++)   primaryKeys.add(key(ignite0,PRIMARY));
  log.info("TransformAll from primary.");
  cache0.invokeAll(primaryKeys,new Processor(1));
  for (int i=0; i < GRID_CNT; i++) {
    for (    Integer primaryKey : primaryKeys)     checkEntry(grid(i),primaryKey,1,false);
  }
  if (backups > 0) {
    Set<Integer> backupKeys=new HashSet<>();
    for (int i=0; i < 10; i++)     backupKeys.add(key(ignite0,BACKUP));
    log.info("TransformAll from backup.");
    cache0.invokeAll(backupKeys,new Processor(2));
    for (int i=0; i < GRID_CNT; i++) {
      for (      Integer backupKey : backupKeys)       checkEntry(grid(i),backupKey,2,false);
    }
  }
  Set<Integer> nearKeys=new HashSet<>();
  for (int i=0; i < 30; i++)   nearKeys.add(key(ignite0,NOT_PRIMARY_AND_BACKUP));
  log.info("TransformAll from near.");
  cache0.invokeAll(nearKeys,new Processor(3));
  for (int i=0; i < GRID_CNT; i++) {
    for (    Integer nearKey : nearKeys) {
      UUID[] expReaders=aff.isPrimary(grid(i).localNode(),nearKey) ? new UUID[]{id0} : new UUID[]{};
      checkEntry(grid(i),nearKey,3,i == 0,expReaders);
    }
  }
  Map<Integer,Collection<UUID>> readersMap=new HashMap<>();
  for (  Integer key : nearKeys)   readersMap.put(key,new HashSet<UUID>());
  int val=4;
  for (int i=0; i < GRID_CNT; i++) {
    delay();
    IgniteCache<Integer,Integer> cache=grid(i).jcache(null);
    for (    Integer key : nearKeys)     nearKeys.add(key);
    log.info("TransformAll [grid=" + grid(i).name() + ", val="+ val+ ']');
    cache.invokeAll(nearKeys,new Processor(val));
    for (    Integer key : nearKeys) {
      if (!aff.isPrimaryOrBackup(grid(i).localNode(),key))       readersMap.get(key).add(grid(i).localNode().id());
    }
    for (int j=0; j < GRID_CNT; j++) {
      for (      Integer key : nearKeys) {
        boolean primaryNode=aff.isPrimary(grid(j).localNode(),key);
        Collection<UUID> readers=readersMap.get(key);
        UUID[] expReaders=primaryNode ? U.toArray(readers,new UUID[readers.size()]) : new UUID[]{};
        checkEntry(grid(j),key,val,readers.contains(grid(j).localNode().id()),expReaders);
      }
    }
    val++;
  }
}
