{
  GridCacheAttributes[] rmtAttrs=U.cacheAttributes(rmt);
  GridCacheAttributes[] locAttrs=U.cacheAttributes(ctx.discovery().localNode());
  if (F.isEmpty(rmtAttrs) || F.isEmpty(locAttrs))   return;
  GridDeploymentMode locDepMode=ctx.config().getDeploymentMode();
  GridDeploymentMode rmtDepMode=rmt.attribute(GridNodeAttributes.ATTR_DEPLOYMENT_MODE);
  for (  GridCacheAttributes rmtAttr : rmtAttrs) {
    for (    GridCacheAttributes locAttr : locAttrs) {
      if (F.eq(rmtAttr.cacheName(),locAttr.cacheName())) {
        CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"cacheMode","Cache mode",locAttr.cacheMode(),rmtAttr.cacheMode(),true);
        if (rmtAttr.cacheMode() != LOCAL) {
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"atomicityMode","Cache atomicity mode",locAttr.atomicityMode(),rmtAttr.atomicityMode(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"cachePreloadMode","Cache preload mode",locAttr.cachePreloadMode(),rmtAttr.cachePreloadMode(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"cacheAffinity","Cache affinity",locAttr.cacheAffinityClassName(),rmtAttr.cacheAffinityClassName(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"cacheAffinityMapper","Cache affinity mapper",locAttr.cacheAffinityMapperClassName(),rmtAttr.cacheAffinityMapperClassName(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"affinityPartitionsCount","Affinity partitions count",locAttr.affinityPartitionsCount(),rmtAttr.affinityPartitionsCount(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"evictionFilter","Eviction filter",locAttr.evictionFilterClassName(),rmtAttr.evictionFilterClassName(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"evictionPolicy","Eviction policy",locAttr.evictionPolicyClassName(),rmtAttr.evictionPolicyClassName(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"store","Cache store",locAttr.storeClassName(),rmtAttr.storeClassName(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"cloner","Cache cloner",locAttr.clonerClassName(),rmtAttr.clonerClassName(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"transactionManagerLookup","Transaction manager lookup",locAttr.transactionManagerLookupClassName(),rmtAttr.transactionManagerLookupClassName(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"atomicSequenceReserveSize","Atomic sequence reserve size",locAttr.sequenceReserveSize(),rmtAttr.sequenceReserveSize(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"batchUpdateOnCommit","Batch update on commit",locAttr.txBatchUpdate(),rmtAttr.txBatchUpdate(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"defaultLockTimeout","Default lock timeout",locAttr.defaultLockTimeout(),rmtAttr.defaultLockTimeout(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"defaultQueryTimeout","Default query timeout",locAttr.defaultQueryTimeout(),rmtAttr.defaultQueryTimeout(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"dgcFrequency","Distributed garbage collector frequency",locAttr.dgcFrequency(),rmtAttr.dgcFrequency(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"defaultTimeToLive","Default time to live",locAttr.defaultTimeToLive(),rmtAttr.defaultTimeToLive(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"defaultTxConcurrency","Default transaction concurrency",locAttr.defaultConcurrency(),rmtAttr.defaultConcurrency(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"defaultTxIsolation","Default transaction isolation",locAttr.defaultIsolation(),rmtAttr.defaultIsolation(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"defaultTxTimeout","Default transaction timeout",locAttr.defaultTxTimeout(),rmtAttr.defaultTxTimeout(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"dgcFrequency","Distributed garbage collector frequency",locAttr.dgcFrequency(),rmtAttr.dgcFrequency(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"dgcRemoveLocks","Distributed garbage collector remove locks",locAttr.dgcRemoveLocks(),rmtAttr.dgcRemoveLocks(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"dgcSuspectLockTimeout","Distributed garbage collector suspect lock timeout",locAttr.dgcSuspectLockTimeout(),rmtAttr.dgcSuspectLockTimeout(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"preloadBatchSize","Preload batch size",locAttr.preloadBatchSize(),rmtAttr.preloadBatchSize(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"swapEnabled","Swap enabled",locAttr.swapEnabled(),rmtAttr.swapEnabled(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"writeSynchronizationMode","Write synchronization mode",locAttr.writeSynchronization(),rmtAttr.writeSynchronization(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"writeBehindBatchSize","Write behind batch size",locAttr.writeBehindBatchSize(),rmtAttr.writeBehindBatchSize(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"writeBehindEnabled","Write behind enabled",locAttr.writeBehindEnabled(),rmtAttr.writeBehindEnabled(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"writeBehindFlushFrequency","Write behind flush frequency",locAttr.writeBehindFlushFrequency(),rmtAttr.writeBehindFlushFrequency(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"writeBehindFlushSize","Write behind flush size",locAttr.writeBehindFlushSize(),rmtAttr.writeBehindFlushSize(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"writeBehindFlushThreadCount","Write behind flush thread count",locAttr.writeBehindFlushThreadCount(),rmtAttr.writeBehindFlushThreadCount(),false);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"evictMaxOverflowRatio","Eviction max overflow ratio",locAttr.evictMaxOverflowRatio(),rmtAttr.evictMaxOverflowRatio(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"indexingSpiName","IndexingSpiName",locAttr.indexingSpiName(),rmtAttr.indexingSpiName(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"queryIndexEnabled","Query index enabled",locAttr.queryIndexEnabled(),rmtAttr.queryIndexEnabled(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"storeEnabled","Store enabled",locAttr.storeEnabled(),rmtAttr.storeEnabled(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"storeValueBytes","Store value bytes",locAttr.storeValueBytes(),rmtAttr.storeValueBytes(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"txSerializableEnabled","Transaction serializable enabled",locAttr.txSerializableEnabled(),rmtAttr.txSerializableEnabled(),true);
          CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"queryIndexEnabled","Query index enabled",locAttr.queryIndexEnabled(),rmtAttr.queryIndexEnabled(),true);
          if (locAttr.cacheMode() == PARTITIONED) {
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"evictSynchronized","Eviction synchronized",locAttr.evictSynchronized(),rmtAttr.evictSynchronized(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"evictNearSynchronized","Eviction near synchronized",locAttr.evictNearSynchronized(),rmtAttr.evictNearSynchronized(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"nearEvictionPolicy","Near eviction policy",locAttr.nearEvictionPolicyClassName(),rmtAttr.nearEvictionPolicyClassName(),false);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"affinityIncludeNeighbors","Affinity include neighbors",locAttr.affinityIncludeNeighbors(),rmtAttr.affinityIncludeNeighbors(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"affinityKeyBackups","Affinity key backups",locAttr.affinityKeyBackups(),rmtAttr.affinityKeyBackups(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"affinityReplicas","Affinity replicas",locAttr.affinityReplicas(),rmtAttr.affinityReplicas(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"affinityReplicaCountAttrName","Affinity replica count attribute name",locAttr.affinityReplicaCountAttrName(),rmtAttr.affinityReplicaCountAttrName(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"cacheAffinity.hashIdResolver","Partitioned cache affinity hash ID resolver class",locAttr.affinityHashIdResolverClassName(),rmtAttr.affinityHashIdResolverClassName(),true);
          }
          GridCacheDrSendAttributes locSndAttrs=locAttr.drSendAttributes();
          GridCacheDrSendAttributes rmtSndAttrs=rmtAttr.drSendAttributes();
          if (locSndAttrs != null && rmtSndAttrs != null) {
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"replicationMode","Replication mode",locSndAttrs.mode(),rmtSndAttrs.mode(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"entryFilterClassName","Class name for replication cache entry filter",locSndAttrs.entryFilterClassName(),rmtSndAttrs.entryFilterClassName(),true);
          }
 else           if (!(locSndAttrs == null && rmtSndAttrs == null)) {
            UUID nullAttrNode=locSndAttrs == null ? ctx.discovery().localNode().id() : rmt.id();
            throw new GridException("Replication sender cache should be enabled for all nodes or " + "disabled for all of them (configuration is not set for nodeId=" + nullAttrNode + ").");
          }
          GridCacheDrReceiveAttributes locRcvAttrs=locAttr.drReceiveAttributes();
          GridCacheDrReceiveAttributes rmtRcvAttrs=rmtAttr.drReceiveAttributes();
          if (locRcvAttrs != null && rmtRcvAttrs != null) {
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"conflictResolverPolicy","Policy for conflict resolver",locRcvAttrs.conflictResolverMode(),rmtRcvAttrs.conflictResolverMode(),true);
            CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"conflictResolverClassName","Class name for conflict resolver",locRcvAttrs.conflictResolverClassName(),rmtRcvAttrs.conflictResolverClassName(),true);
          }
 else           if (!(locRcvAttrs == null && rmtRcvAttrs == null)) {
            UUID nullAttrNode=locRcvAttrs == null ? ctx.discovery().localNode().id() : rmt.id();
            throw new GridException("DR receiver cache should be enabled for all nodes or " + "disabled for all of them (configuration is not set for nodeId=" + nullAttrNode + ").");
          }
          if (locAttr.atomicityMode() == ATOMIC && locAttr.nearCacheEnabled() && rmt.version().compareTo(GridNearAtomicCache.SINCE_VER) < 0)           throw new GridException("Cannot use ATOMIC cache with near cache enabled because " + "grid contains nodes that do not support such configuration [rmtNodeId=" + rmt.id() + ", rmtVer="+ rmt.version()+ ", supportedSince="+ GridNearAtomicCache.SINCE_VER+ ", locVer="+ ctx.product().version()+ ']');
        }
      }
      CU.checkAttributeMismatch(log,rmtAttr.cacheName(),rmt,"deploymentMode","Deployment mode",locDepMode,rmtDepMode,true);
    }
  }
}
