{
  if (cc.getCacheMode() == REPLICATED) {
    if (cc.getAffinity() instanceof GridCachePartitionFairAffinity)     throw new IgniteCheckedException("REPLICATED cache can not be started with GridCachePartitionFairAffinity" + " [cacheName=" + cc.getName() + ']');
    if (cc.getAffinity() instanceof GridCacheConsistentHashAffinityFunction) {
      GridCacheConsistentHashAffinityFunction aff=(GridCacheConsistentHashAffinityFunction)cc.getAffinity();
      if (aff.isExcludeNeighbors())       throw new IgniteCheckedException("For REPLICATED cache flag 'excludeNeighbors' in " + "GridCacheConsistentHashAffinityFunction cannot be set [cacheName=" + cc.getName() + ']');
    }
    if (cc.getAffinity() instanceof GridCacheRendezvousAffinityFunction) {
      GridCacheRendezvousAffinityFunction aff=(GridCacheRendezvousAffinityFunction)cc.getAffinity();
      if (aff.isExcludeNeighbors())       throw new IgniteCheckedException("For REPLICATED cache flag 'excludeNeighbors' in " + "GridCacheRendezvousAffinityFunction cannot be set [cacheName=" + cc.getName() + ']');
    }
    if (cc.getDistributionMode() == NEAR_PARTITIONED) {
      U.warn(log,"NEAR_PARTITIONED distribution mode cannot be used with REPLICATED cache, " + "will be changed to PARTITIONED_ONLY [cacheName=" + cc.getName() + ']');
      cc.setDistributionMode(PARTITIONED_ONLY);
    }
  }
  if (cc.getCacheMode() == LOCAL && !cc.getAffinity().getClass().equals(LocalAffinityFunction.class))   U.warn(log,"GridCacheAffinityFunction configuration parameter will be ignored for local cache [cacheName=" + cc.getName() + ']');
  if (cc.getPreloadMode() != GridCachePreloadMode.NONE) {
    assertParameter(cc.getPreloadThreadPoolSize() > 0,"preloadThreadPoolSize > 0");
    assertParameter(cc.getPreloadBatchSize() > 0,"preloadBatchSize > 0");
  }
  if (cc.getCacheMode() == PARTITIONED || cc.getCacheMode() == REPLICATED) {
    if (cc.getAtomicityMode() == ATOMIC && cc.getWriteSynchronizationMode() == FULL_ASYNC)     U.warn(log,"Cache write synchronization mode is set to FULL_ASYNC. All single-key 'put' and " + "'remove' operations will return 'null', all 'putx' and 'removex' operations will return" + " 'true' [cacheName=" + cc.getName() + ']');
  }
  IgniteDeploymentMode depMode=c.getDeploymentMode();
  if (c.isPeerClassLoadingEnabled() && (depMode == PRIVATE || depMode == ISOLATED) && !CU.isSystemCache(cc.getName()))   throw new IgniteCheckedException("Cannot start cache in PRIVATE or ISOLATED deployment mode: " + ctx.config().getDeploymentMode());
  if (!c.getTransactionsConfiguration().isTxSerializableEnabled() && c.getTransactionsConfiguration().getDefaultTxIsolation() == SERIALIZABLE)   U.warn(log,"Serializable transactions are disabled while default transaction isolation is SERIALIZABLE " + "(most likely misconfiguration - either update 'isTxSerializableEnabled' or " + "'defaultTxIsolationLevel' properties) for cache: "+ cc.getName(),"Serializable transactions are disabled while default transaction isolation is SERIALIZABLE " + "for cache: " + cc.getName());
  if (cc.isWriteBehindEnabled()) {
    if (cfgStore == null)     throw new IgniteCheckedException("Cannot enable write-behind (writer or store is not provided) " + "for cache: " + cc.getName());
    assertParameter(cc.getWriteBehindBatchSize() > 0,"writeBehindBatchSize > 0");
    assertParameter(cc.getWriteBehindFlushSize() >= 0,"writeBehindFlushSize >= 0");
    assertParameter(cc.getWriteBehindFlushFrequency() >= 0,"writeBehindFlushFrequency >= 0");
    assertParameter(cc.getWriteBehindFlushThreadCount() > 0,"writeBehindFlushThreadCount > 0");
    if (cc.getWriteBehindFlushSize() == 0 && cc.getWriteBehindFlushFrequency() == 0)     throw new IgniteCheckedException("Cannot set both 'writeBehindFlushFrequency' and " + "'writeBehindFlushSize' parameters to 0 for cache: " + cc.getName());
  }
  if (cc.isReadThrough() && cfgStore == null)   throw new IgniteCheckedException("Cannot enable read-through (loader or store is not provided) " + "for cache: " + cc.getName());
  if (cc.isWriteThrough() && cfgStore == null)   throw new IgniteCheckedException("Cannot enable read-through (writer or store is not provided) " + "for cache: " + cc.getName());
  long delay=cc.getPreloadPartitionedDelay();
  if (delay != 0) {
    if (cc.getCacheMode() != PARTITIONED)     U.warn(log,"Preload delay is supported only for partitioned caches (will ignore): " + cc.getName(),"Will ignore preload delay for cache: " + cc.getName());
 else     if (cc.getPreloadMode() == SYNC) {
      if (delay < 0) {
        U.warn(log,"Ignoring SYNC preload mode with manual preload start (node will not wait for " + "preloading to be finished): " + cc.getName(),"Node will not wait for preload in SYNC mode: " + cc.getName());
      }
 else {
        U.warn(log,"Using SYNC preload mode with preload delay (node will wait until preloading is " + "initiated for " + delay + "ms) for cache: "+ cc.getName(),"Node will wait until preloading is initiated for " + delay + "ms for cache: "+ cc.getName());
      }
    }
  }
  ctx.ggfsHelper().validateCacheConfiguration(cc);
switch (cc.getMemoryMode()) {
case OFFHEAP_VALUES:
{
      if (cc.getOffHeapMaxMemory() < 0)       cc.setOffHeapMaxMemory(0);
      break;
    }
case OFFHEAP_TIERED:
{
    if (cc.getOffHeapMaxMemory() < 0)     cc.setOffHeapMaxMemory(0);
    break;
  }
case ONHEAP_TIERED:
if (!systemCache(cc.getName()) && cc.getEvictionPolicy() == null && cc.getOffHeapMaxMemory() >= 0) U.quietAndWarn(log,"Eviction policy not enabled with ONHEAP_TIERED mode for cache " + "(entries will not be moved to off-heap store): " + cc.getName());
break;
default :
throw new IllegalStateException("Unknown memory mode: " + cc.getMemoryMode());
}
if (cc.getMemoryMode() == GridCacheMemoryMode.OFFHEAP_VALUES) {
if (cc.isQueryIndexEnabled()) throw new IgniteCheckedException("Cannot have query indexing enabled while values are stored off-heap. " + "You must either disable query indexing or disable off-heap values only flag for cache: " + cc.getName());
}
boolean ggfsCache=CU.isGgfsCache(c,cc.getName());
boolean utilityCache=CU.isUtilityCache(cc.getName());
if (!ggfsCache && !utilityCache && !cc.isQueryIndexEnabled()) U.warn(log,"Query indexing is disabled (queries will not work) for cache: '" + cc.getName() + "'. "+ "To enable change GridCacheConfiguration.isQueryIndexEnabled() property.","Query indexing is disabled (queries will not work) for cache: " + cc.getName());
if (cc.getAtomicityMode() == ATOMIC) assertParameter(cc.getTransactionManagerLookupClassName() == null,"transaction manager can not be used with ATOMIC cache");
if (cc.isPortableEnabled() && !ctx.isEnterprise()) throw new IgniteCheckedException("Portable mode for cache is supported only in Enterprise edition " + "(set 'portableEnabled' property to 'false') [cacheName=" + cc.getName() + ']');
}
