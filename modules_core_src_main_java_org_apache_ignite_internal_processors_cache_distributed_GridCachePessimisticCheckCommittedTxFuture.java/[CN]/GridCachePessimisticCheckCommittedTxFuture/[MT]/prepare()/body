{
  if (log.isDebugEnabled())   log.debug("Checking if transaction was committed on remote nodes: " + tx);
  long originatingThreadId=tx.threadId();
  if (tx instanceof IgniteTxRemoteEx)   originatingThreadId=((IgniteTxRemoteEx)tx).remoteThreadId();
  GridCacheCommittedTxInfo<K,V> txInfo=cctx.tm().txCommitted(tx.nearXidVersion(),tx.eventNodeId(),originatingThreadId);
  if (txInfo != null) {
    onDone(txInfo);
    markInitialized();
    return;
  }
  Collection<ClusterNode> checkNodes=CU.remoteNodes(cctx,tx.topologyVersion());
  if (tx instanceof GridDhtTxRemote) {
    if (tx.nodeId().equals(failedNodeId) && !tx.eventNodeId().equals(failedNodeId)) {
      nearCheck=true;
      ClusterNode nearNode=cctx.discovery().node(tx.eventNodeId());
      if (nearNode == null) {
        onDone(new ClusterTopologyException("Failed to check near transaction state (near node left grid): " + tx.eventNodeId()));
        return;
      }
      checkNodes=Collections.singletonList(nearNode);
    }
  }
  for (  ClusterNode rmtNode : checkNodes) {
    if (rmtNode.id().equals(failedNodeId))     continue;
    GridCachePessimisticCheckCommittedTxRequest<K,V> req=new GridCachePessimisticCheckCommittedTxRequest<>(tx,originatingThreadId,futureId(),nearCheck);
    if (rmtNode.isLocal())     add(cctx.tm().checkPessimisticTxCommitted(req));
 else {
      MiniFuture fut=new MiniFuture(rmtNode.id());
      req.miniId(fut.futureId());
      add(fut);
      try {
        cctx.io().send(rmtNode.id(),req);
      }
 catch (      ClusterTopologyException ignored) {
        fut.onNodeLeft();
      }
catch (      IgniteCheckedException e) {
        fut.onError(e);
        break;
      }
    }
  }
  markInitialized();
}
