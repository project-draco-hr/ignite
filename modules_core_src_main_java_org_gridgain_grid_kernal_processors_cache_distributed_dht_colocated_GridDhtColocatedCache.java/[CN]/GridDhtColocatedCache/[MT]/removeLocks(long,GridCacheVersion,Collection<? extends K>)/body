{
  if (keys.isEmpty())   return;
  try {
    int keyCnt=-1;
    Map<GridNode,GridNearUnlockRequest<K,V>> map=null;
    Collection<K> locKeys=new LinkedList<>();
    for (    K key : keys) {
      GridCacheMvccCandidate<K> lock=ctx.mvcc().removeExplicitLock(threadId,key,ver);
      if (lock != null) {
        long topVer=lock.topologyVersion();
        if (map == null) {
          Collection<GridNode> affNodes=CU.allNodes(ctx,topVer);
          keyCnt=(int)Math.ceil((double)keys.size() / affNodes.size());
          map=U.newHashMap(affNodes.size());
        }
        GridNode primary=ctx.affinity().primary(key,topVer);
        if (!primary.isLocal()) {
          GridNearUnlockRequest<K,V> req=map.get(primary);
          if (req == null) {
            map.put(primary,req=new GridNearUnlockRequest<>(ctx.cacheId(),keyCnt));
            req.version(ver);
          }
          GridCacheEntryEx<K,V> entry=peekEx(key);
          byte[] keyBytes=entry != null ? entry.getOrMarshalKeyBytes() : CU.marshal(ctx.shared(),key);
          req.addKey(key,keyBytes,ctx);
        }
 else         locKeys.add(key);
      }
    }
    if (!locKeys.isEmpty())     removeLocks(ctx.localNodeId(),ver,locKeys,true);
    if (map == null || map.isEmpty())     return;
    Collection<GridCacheVersion> committed=ctx.tm().committedVersions(ver);
    Collection<GridCacheVersion> rolledback=ctx.tm().rolledbackVersions(ver);
    for (    Map.Entry<GridNode,GridNearUnlockRequest<K,V>> mapping : map.entrySet()) {
      GridNode n=mapping.getKey();
      GridDistributedUnlockRequest<K,V> req=mapping.getValue();
      if (!F.isEmpty(req.keyBytes()) || !F.isEmpty(req.keys())) {
        req.completedVersions(committed,rolledback);
        ctx.io().send(n,req);
      }
    }
  }
 catch (  GridException ex) {
    U.error(log,"Failed to unlock the lock for keys: " + keys,ex);
  }
}
