{
  try {
    return CU.outTx(retryTopologySafe(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        try (IgniteInternalTx tx=CU.txStartInternal(ctx,semView,PESSIMISTIC,REPEATABLE_READ)){
          GridCacheSemaphoreState val=semView.get(key);
          if (val == null)           throw new IgniteCheckedException("Failed to find semaphore with given name: " + name);
          boolean retVal=val.getCount() == expVal;
          if (retVal) {
            if (!draining) {
              UUID nodeID=ctx.localNodeId();
              Map<UUID,Integer> map=val.getWaiters();
              int waitingCnt=expVal - newVal;
              if (map.containsKey(nodeID))               waitingCnt+=map.get(nodeID);
              map.put(nodeID,waitingCnt);
              val.setWaiters(map);
            }
            val.setCount(newVal);
            semView.put(key,val);
            tx.commit();
          }
          return retVal;
        }
 catch (        Error|Exception e) {
          if (!ctx.kernalContext().isStopping())           U.error(log,"Failed to compare and set: " + this,e);
          throw e;
        }
      }
    }
),ctx);
  }
 catch (  IgniteCheckedException e) {
    if (ctx.kernalContext().isStopping()) {
      if (log.isDebugEnabled())       log.debug("Ignoring failure in semaphore on node left handler (node is stopping): " + e);
      return true;
    }
 else     throw U.convertException(e);
  }
}
