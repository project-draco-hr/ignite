{
  final Ignite client=ignite(serverCount());
  assertTrue(client.cluster().localNode().isClient());
  long topVer=4;
  IgniteCluster cluster=client.cluster();
  cluster.nodeLocalMap().put("locMapKey",10);
  Map<Integer,Integer> nodeCnt=new HashMap<>();
  nodeCnt.put(1,1);
  nodeCnt.put(2,2);
  nodeCnt.put(3,3);
  nodeCnt.put(4,4);
  for (  Map.Entry<Integer,Integer> e : nodeCnt.entrySet()) {
    Collection<ClusterNode> nodes=cluster.topology(e.getKey());
    assertNotNull("No nodes for topology: " + e.getKey(),nodes);
    assertEquals((int)e.getValue(),nodes.size());
  }
  ClusterNode locNode=cluster.localNode();
  assertEquals(topVer,locNode.order());
  TestTcpDiscoverySpi srvSpi=spi(clientRouter(client));
  final CountDownLatch reconnectLatch=new CountDownLatch(1);
  client.events().localListen(new IgnitePredicate<Event>(){
    @Override public boolean apply(    Event evt){
      if (evt.type() == EVT_CLIENT_NODE_DISCONNECTED) {
        info("Disconnected: " + evt);
        IgniteFuture<?> fut=client.cluster().clientReconnectFuture();
        assertNotNull(fut);
        assertFalse(fut.isDone());
      }
 else       if (evt.type() == EVT_CLIENT_NODE_RECONNECTED) {
        info("Reconnected: " + evt);
        reconnectLatch.countDown();
      }
      return true;
    }
  }
,EVT_CLIENT_NODE_DISCONNECTED,EVT_CLIENT_NODE_RECONNECTED);
  srvSpi.failNode(client.cluster().localNode().id(),null);
  waitReconnectEvent(reconnectLatch);
  topVer+=2;
  locNode=cluster.localNode();
  assertEquals(topVer,locNode.order());
  assertEquals(topVer,cluster.topologyVersion());
  nodeCnt.put(5,3);
  nodeCnt.put(6,4);
  for (  Map.Entry<Integer,Integer> e : nodeCnt.entrySet()) {
    Collection<ClusterNode> nodes=cluster.topology(e.getKey());
    assertNotNull("No nodes for topology: " + e.getKey(),nodes);
    assertEquals((int)e.getValue(),nodes.size());
  }
  assertEquals(10,cluster.nodeLocalMap().get("locMapKey"));
}
