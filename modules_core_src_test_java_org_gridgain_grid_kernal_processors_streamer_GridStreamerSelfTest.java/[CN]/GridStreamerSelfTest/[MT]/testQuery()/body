{
  atLeastOnce=true;
  router=new GridStreamerRandomEventRouter();
  p2pEnabled=false;
  final int evtCnt=1000;
  final CountDownLatch finishLatch=new CountDownLatch(evtCnt);
  SC stage=new SC(){
    @SuppressWarnings("unchecked") @Override public Map<String,Collection<?>> applyx(    String stageName,    StreamerContext ctx,    Collection<Object> evts){
      ConcurrentMap<String,AtomicInteger> space=ctx.localSpace();
      AtomicInteger cntr=space.get(stageName);
      if (cntr == null)       cntr=F.addIfAbsent(space,stageName,new AtomicInteger());
      for (      Object val : evts)       cntr.addAndGet((Integer)val);
      String next=ctx.nextStageName();
      if (next == null) {
        finishLatch.countDown();
        return null;
      }
      return (Map)F.asMap(next,evts);
    }
  }
;
  stages=F.asList((StreamerStage)new GridTestStage("a",stage),new GridTestStage("b",stage),new GridTestStage("c",stage),new GridTestStage("d",stage));
  startGrids(4);
  try {
    int sum=0;
    int range=1000;
    Random rnd=new Random();
    for (int i=0; i < evtCnt; i++) {
      int val=rnd.nextInt(range);
      grid(0).streamer(null).addEvent(val);
      sum+=val;
    }
    finishLatch.await();
    Map<String,Integer> stagesSum=new HashMap<>(4);
    final String[] stages={"a","b","c","d"};
    for (int i=0; i < 4; i++) {
      Ignite ignite=grid(i);
      ConcurrentMap<String,AtomicInteger> locSpace=ignite.streamer(null).context().localSpace();
      for (      String stageName : stages) {
        AtomicInteger val=locSpace.get(stageName);
        assertNotNull(val);
        info(">>>>> grid=" + ignite.cluster().localNode().id() + ", s="+ stageName+ ", val="+ val.get());
        Integer old=stagesSum.get(stageName);
        if (old == null)         stagesSum.put(stageName,val.get());
 else         stagesSum.put(stageName,old + val.get());
      }
    }
    for (    String s : stages)     assertEquals((Integer)sum,stagesSum.get(s));
    StreamerContext streamerCtx=grid(0).streamer(null).context();
    for (    final String s : stages) {
      Collection<Integer> res=streamerCtx.query(new C1<StreamerContext,Integer>(){
        @Override public Integer apply(        StreamerContext ctx){
          AtomicInteger cntr=ctx.<String,AtomicInteger>localSpace().get(s);
          return cntr.get();
        }
      }
);
      assertEquals(sum,F.sumInt(res));
    }
    streamerCtx.broadcast(new CI1<StreamerContext>(){
      @Override public void apply(      StreamerContext ctx){
        int sum=0;
        ConcurrentMap<String,AtomicInteger> space=ctx.localSpace();
        for (        String s : stages) {
          AtomicInteger cntr=space.get(s);
          sum+=cntr.get();
        }
        space.put("bcast",new AtomicInteger(sum));
      }
    }
);
    int bcastSum=0;
    for (int i=0; i < 4; i++) {
      Ignite ignite=grid(i);
      ConcurrentMap<String,AtomicInteger> locSpace=ignite.streamer(null).context().localSpace();
      bcastSum+=locSpace.get("bcast").get();
    }
    assertEquals(sum * stages.length,bcastSum);
    for (    final String s : stages) {
      Integer res=streamerCtx.reduce(new C1<StreamerContext,Integer>(){
        @Override public Integer apply(        StreamerContext ctx){
          AtomicInteger cntr=ctx.<String,AtomicInteger>localSpace().get(s);
          return cntr.get();
        }
      }
,F.sumIntReducer());
      assertEquals((Integer)sum,res);
    }
  }
  finally {
    stopAllGrids(false);
  }
}
