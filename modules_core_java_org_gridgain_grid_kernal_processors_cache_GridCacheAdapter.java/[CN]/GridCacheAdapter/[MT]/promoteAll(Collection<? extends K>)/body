{
  ctx.denyOnFlags(F.asList(READ,SKIP_SWAP));
  if (F.isEmpty(keys))   return;
  validateCacheKeys(keys);
  Collection<K> unswap=new ArrayList<>(keys.size());
  long topVer=ctx.affinity().affinityTopologyVersion();
  for (  K key : keys) {
    GridCacheEntryEx<K,V> entry=peekEx(key);
    try {
      if (entry == null || entry.obsolete() || entry.isNewLocked(topVer))       unswap.add(key);
    }
 catch (    GridCacheEntryRemovedException ignored) {
    }
  }
  Collection<GridCacheBatchSwapEntry<K,V>> swapped=ctx.swap().readAndRemove(unswap);
  for (  GridCacheBatchSwapEntry<K,V> swapEntry : swapped) {
    K key=swapEntry.key();
    GridCacheEntryEx<K,V> entry=entryEx(key);
    try {
      entry.initialValue(key,topVer,swapEntry);
    }
 catch (    GridCacheEntryRemovedException ignored) {
      if (log.isDebugEnabled())       log.debug("Entry has been concurrently removed.");
    }
  }
}
