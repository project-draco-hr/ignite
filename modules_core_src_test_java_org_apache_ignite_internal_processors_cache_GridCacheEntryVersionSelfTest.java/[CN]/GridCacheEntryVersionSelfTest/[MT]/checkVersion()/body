{
  startGridsMultiThreaded(3);
  try {
    Map<Integer,Integer> map=F.asMap(1,1,2,2,3,3);
    for (    Integer key : map.keySet()) {
      info("Affinity nodes [key=" + key + ", nodes="+ F.viewReadOnly(grid(0).cache(null).affinity().mapKeyToPrimaryAndBackups(key),F.node2id())+ ']');
    }
    grid(0).cache(null).putAll(map);
    for (int g=0; g < 3; g++) {
      GridKernal grid=(GridKernal)grid(g);
      for (      Integer key : map.keySet()) {
        GridCacheAdapter<Object,Object> cache=grid.internalCache();
        GridCacheEntryEx<Object,Object> entry=cache.peekEx(key);
        if (entry != null) {
          GridCacheVersion ver=entry.version();
          long order=cache.affinity().mapKeyToNode(key).order();
          assertEquals(3,ver.topologyVersion() - (grid.context().discovery().gridStartTime() - TOP_VER_BASE_TIME) / 1000);
          assertEquals("Failed for key: " + key,order,ver.nodeOrder());
        }
      }
    }
    startGrid(3);
    grid(0).cache(null).putAll(map);
    for (int g=0; g < 4; g++) {
      GridKernal grid=(GridKernal)grid(g);
      for (      Integer key : map.keySet()) {
        GridCacheAdapter<Object,Object> cache=grid.internalCache();
        GridCacheEntryEx<Object,Object> entry=cache.peekEx(key);
        if (entry != null) {
          GridCacheVersion ver=entry.version();
          long order=cache.affinity().mapKeyToNode(key).order();
          assertEquals(4,ver.topologyVersion() - (grid.context().discovery().gridStartTime() - TOP_VER_BASE_TIME) / 1000);
          assertEquals("Failed for key: " + key,order,ver.nodeOrder());
        }
      }
    }
  }
  finally {
    stopAllGrids();
  }
}
