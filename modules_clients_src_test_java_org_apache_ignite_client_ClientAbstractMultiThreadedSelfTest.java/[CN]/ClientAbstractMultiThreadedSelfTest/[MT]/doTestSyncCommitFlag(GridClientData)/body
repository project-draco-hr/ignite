{
  final String key="k0";
  Collection<UUID> affNodesIds=F.viewReadOnly(grid(0).cache(data.cacheName()).affinity().mapKeyToPrimaryAndBackups(key),F.node2id());
  final GridClientData dataFirst=data.pinNodes(F.first(client.compute().nodes()));
  List<GridClientNode> affNodes=new ArrayList<>();
  for (  GridClientNode node : client.compute().nodes()) {
    if (affNodesIds.contains(node.nodeId()))     affNodes.add(node);
  }
  Assert.assertFalse(affNodes.isEmpty());
  Iterator<? extends GridClientNode> it=affNodes.iterator();
  final GridClientData dataOthers=data.pinNodes(it.next(),toArray(it));
  for (int i=0; i < syncCommitIterCount(); i++) {
    final CountDownLatch l=new CountDownLatch(1);
    final String val="v" + i;
    IgniteInternalFuture<?> f=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        l.await();
        assertEquals(val,dataOthers.get(key));
        return null;
      }
    }
,THREAD_CNT);
    dataFirst.flagsOn(GridClientCacheFlag.SYNC_COMMIT).put(key,val);
    l.countDown();
    f.get();
  }
}
