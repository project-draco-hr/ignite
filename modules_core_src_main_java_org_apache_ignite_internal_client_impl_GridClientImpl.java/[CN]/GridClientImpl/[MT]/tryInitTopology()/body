{
  boolean hasSrvs=routers.isEmpty();
  final Collection<InetSocketAddress> connSrvs=(hasSrvs) ? new LinkedHashSet<>(srvs) : routers;
  if (hasSrvs) {
    try {
      for (      GridClientNodeImpl node : top.nodes()) {
        Collection<InetSocketAddress> endpoints=node.availableAddresses(cfg.getProtocol(),true);
        List<InetSocketAddress> resolvedEndpoints=new ArrayList<>(endpoints.size());
        for (        InetSocketAddress endpoint : endpoints)         if (!endpoint.isUnresolved())         resolvedEndpoints.add(endpoint);
        boolean sameHost=node.attributes().isEmpty() || F.containsAny(U.allLocalMACs(),node.attribute(ATTR_MACS).toString().split(", "));
        if (sameHost) {
          Collections.sort(resolvedEndpoints,U.inetAddressesComparator(true));
          connSrvs.addAll(resolvedEndpoints);
        }
 else {
          for (          InetSocketAddress endpoint : resolvedEndpoints)           if (!endpoint.getAddress().isLoopbackAddress())           connSrvs.add(endpoint);
        }
      }
    }
 catch (    GridClientDisconnectedException ignored) {
    }
  }
  connMgr.init(connSrvs);
  Map<String,GridClientCacheMode> overallCaches=new HashMap<>();
  for (  GridClientNodeImpl node : top.nodes())   overallCaches.putAll(node.caches());
  for (  Map.Entry<String,GridClientCacheMode> entry : overallCaches.entrySet()) {
    GridClientDataAffinity affinity=affinity(entry.getKey());
    if (affinity instanceof GridClientPartitionAffinity && entry.getValue() != GridClientCacheMode.PARTITIONED)     log.warning(GridClientPartitionAffinity.class.getSimpleName() + " is used for a cache configured " + "for non-partitioned mode [cacheName="+ entry.getKey()+ ", cacheMode="+ entry.getValue()+ ']');
  }
}
