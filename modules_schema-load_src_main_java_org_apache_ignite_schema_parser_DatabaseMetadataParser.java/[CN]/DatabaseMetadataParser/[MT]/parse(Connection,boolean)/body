{
  DatabaseMetadataDialect dialect;
  try {
    String dbProductName=conn.getMetaData().getDatabaseProductName();
    if ("Oracle".equals(dbProductName))     dialect=new OracleMetadataDialect();
 else     if (dbProductName.startsWith("DB2/"))     dialect=new DB2MetadataDialect();
 else     dialect=new JdbcMetadataDialect();
  }
 catch (  SQLException e) {
    System.err.println("Failed to resolve dialect (JdbcMetaDataDialect will be used.");
    e.printStackTrace();
    dialect=new JdbcMetadataDialect();
  }
  Map<String,PojoDescriptor> parents=new HashMap<>();
  Map<String,Collection<PojoDescriptor>> childrens=new HashMap<>();
  for (  DbTable tbl : dialect.tables(conn,tblsOnly)) {
    String schema=tbl.schema();
    PojoDescriptor parent=parents.get(schema);
    Collection<PojoDescriptor> children=childrens.get(schema);
    if (parent == null) {
      parent=new PojoDescriptor(null,new DbTable(schema,"",Collections.<DbColumn>emptyList()));
      children=new ArrayList<>();
      parents.put(schema,parent);
      childrens.put(schema,children);
    }
    children.add(new PojoDescriptor(parent,tbl));
  }
  List<PojoDescriptor> res=new ArrayList<>();
  for (  String schema : parents.keySet()) {
    PojoDescriptor parent=parents.get(schema);
    Collection<PojoDescriptor> children=childrens.get(schema);
    if (!children.isEmpty()) {
      parent.children(children);
      res.add(parent);
      res.addAll(children);
    }
  }
  Collections.sort(res,new Comparator<PojoDescriptor>(){
    @Override public int compare(    PojoDescriptor o1,    PojoDescriptor o2){
      return o1.fullDbName().compareTo(o2.fullDbName());
    }
  }
);
  return FXCollections.observableList(res);
}
