{
  TreeSet<FileWithId> checkPoints=files(CheckPointWorker.FILE_EXTENSION);
  Iterator<FileWithId> iter=checkPoints.descendingIterator();
  while (iter.hasNext()) {
    FileWithId f=iter.next();
    try {
      ObjectInputStream in=new ObjectInputStream(new BufferedInputStream(Files.newInputStream(f.file)));
      checkMagic(in);
      int streamsNum=in.readInt();
      DataCenterStream[] arr=new DataCenterStream[streamsNum];
      for (int i=0; i < streamsNum; i++) {
        byte id=in.readByte();
        long fileId=in.readLong();
        LogFile logFile=fileById(fileId);
        long filePos=in.readLong();
        LogPos p=new LogPos(logFile,filePos);
        long redoLogSize=in.readLong();
        checkMagic(in);
        DataCenterStream stream=new DataCenterStream(id,p);
        stream.position(p);
        stream.redoLogSize.set(redoLogSize);
        arr[i]=stream;
      }
      for (      DataCenterStream stream : arr) {
        if (streamById[stream.id & 0xff] != null)         throw new IOException("Duplicate data center id.");
        streamById[stream.id & 0xff]=stream;
      }
synchronized (streamById) {
      }
      if (log.isInfoEnabled())       log.info("DR Store initialized from: " + f.file);
      break;
    }
 catch (    IOException ex) {
      if (log.isInfoEnabled())       log.info("Checkpoint file is corrupted:[id=" + f.id + ", msg="+ ex.getMessage()+ "]");
      iter.remove();
      Files.delete(f.file);
    }
  }
  if (checkPoints.isEmpty())   return Collections.emptyList();
  Collection<Path> res=new ArrayList<>(checkPoints.size());
  for (  FileWithId f : checkPoints)   res.add(f.file);
  return res;
}
