{
  if (log.isDebugEnabled())   log.debug("Processing dht atomic update request [nodeId=" + nodeId + ", req="+ req+ ']');
  GridCacheVersion ver=req.writeVersion();
  GridDhtAtomicUpdateResponse<K,V> res=new GridDhtAtomicUpdateResponse<>(ctx.cacheId(),req.futureVersion());
  Boolean replicate=ctx.isDrEnabled();
  boolean intercept=req.forceTransformBackups() && ctx.config().getInterceptor() != null;
  String taskName=ctx.kernalContext().task().resolveTaskName(req.taskNameHash());
  for (int i=0; i < req.size(); i++) {
    K key=req.key(i);
    try {
      while (true) {
        GridDhtCacheEntry<K,V> entry=null;
        try {
          entry=entryExx(key);
          V val=req.value(i);
          byte[] valBytes=req.valueBytes(i);
          EntryProcessor<K,V,?> entryProcessor=req.entryProcessor(i);
          GridCacheOperation op=entryProcessor != null ? TRANSFORM : (val != null || valBytes != null) ? UPDATE : DELETE;
          long ttl=req.ttl(i);
          long expireTime=req.conflictExpireTime(i);
          if (ttl != -1L && expireTime == -1L)           expireTime=CU.toExpireTime(ttl);
          GridCacheUpdateAtomicResult<K,V> updRes=entry.innerUpdate(ver,nodeId,nodeId,op,op == TRANSFORM ? entryProcessor : val,valBytes,op == TRANSFORM ? req.invokeArguments() : null,false,false,null,true,true,false,!req.forceTransformBackups(),CU.<K,V>empty(),replicate ? DR_BACKUP : DR_NONE,ttl,expireTime,req.conflictVersion(i),false,intercept,req.subjectId(),taskName);
          if (updRes.removeVersion() != null)           ctx.onDeferredDelete(entry,updRes.removeVersion());
          entry.onUnlock();
          break;
        }
 catch (        GridCacheEntryRemovedException ignored) {
          if (log.isDebugEnabled())           log.debug("Got removed entry while updating backup value (will retry): " + key);
          entry=null;
        }
 finally {
          if (entry != null)           ctx.evicts().touch(entry,req.topologyVersion());
        }
      }
    }
 catch (    GridDhtInvalidPartitionException ignored) {
    }
catch (    IgniteCheckedException e) {
      res.addFailedKey(key,new IgniteCheckedException("Failed to update key on backup node: " + key,e));
    }
  }
  if (isNearEnabled(cacheCfg))   ((GridNearAtomicCache<K,V>)near()).processDhtAtomicUpdateRequest(nodeId,req,res);
  try {
    if (res.failedKeys() != null || res.nearEvicted() != null || req.writeSynchronizationMode() == FULL_SYNC)     ctx.io().send(nodeId,res,ctx.ioPolicy());
 else {
      sendDeferredUpdateResponse(nodeId,req.futureVersion());
    }
  }
 catch (  ClusterTopologyCheckedException ignored) {
    U.warn(log,"Failed to send DHT atomic update response to node because it left grid: " + req.nodeId());
  }
catch (  IgniteCheckedException e) {
    U.error(log,"Failed to send DHT atomic update response (did node leave grid?) [nodeId=" + nodeId + ", req="+ req+ ']',e);
  }
}
