{
  if (map != null && keyCheck)   validateCacheKeys(map.keySet());
  ctx.checkSecurity(GridSecurityPermission.CACHE_PUT);
  GridCacheProjectionImpl<K,V> prj=ctx.projectionPerCall();
  UUID subjId=ctx.subjectIdPerCall(null,prj);
  int taskNameHash=ctx.kernalContext().job().currentTaskNameHash();
  final GridNearAtomicUpdateFuture<K,V> updateFut=new GridNearAtomicUpdateFuture<>(ctx,this,ctx.config().getWriteSynchronizationMode(),invokeMap != null ? TRANSFORM : UPDATE,map != null ? map.keySet() : invokeMap != null ? invokeMap.keySet() : conflictPutMap != null ? conflictPutMap.keySet() : conflictRmvMap.keySet(),map != null ? map.values() : invokeMap != null ? invokeMap.values() : null,invokeArgs,conflictPutMap != null ? conflictPutMap.values() : null,conflictRmvMap != null ? conflictRmvMap.values() : null,retval,rawRetval,cached,prj != null ? prj.expiry() : null,filter,subjId,taskNameHash);
  return asyncOp(new CO<IgniteInternalFuture<Object>>(){
    @Override public IgniteInternalFuture<Object> apply(){
      updateFut.map();
      return updateFut;
    }
  }
);
}
