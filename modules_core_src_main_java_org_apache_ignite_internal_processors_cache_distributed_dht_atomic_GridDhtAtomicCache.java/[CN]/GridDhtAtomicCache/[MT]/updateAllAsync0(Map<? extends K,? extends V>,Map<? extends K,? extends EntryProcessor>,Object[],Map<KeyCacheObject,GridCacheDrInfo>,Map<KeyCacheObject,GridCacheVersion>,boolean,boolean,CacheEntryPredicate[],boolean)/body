{
  if (map != null && keyCheck)   validateCacheKeys(map.keySet());
  ctx.checkSecurity(SecurityPermission.CACHE_PUT);
  CacheProjectionContext prj=ctx.projectionPerCall();
  UUID subjId=ctx.subjectIdPerCall(null,prj);
  int taskNameHash=ctx.kernalContext().job().currentTaskNameHash();
  final GridNearAtomicUpdateFuture updateFut=new GridNearAtomicUpdateFuture(ctx,this,ctx.config().getWriteSynchronizationMode(),invokeMap != null ? TRANSFORM : UPDATE,map != null ? map.keySet() : invokeMap != null ? invokeMap.keySet() : conflictPutMap != null ? conflictPutMap.keySet() : conflictRmvMap.keySet(),map != null ? map.values() : invokeMap != null ? invokeMap.values() : null,invokeArgs,(Collection)(conflictPutMap != null ? conflictPutMap.values() : null),conflictRmvMap != null ? conflictRmvMap.values() : null,retval,rawRetval,prj != null ? prj.expiry() : null,filter,subjId,taskNameHash);
  return asyncOp(new CO<IgniteInternalFuture<Object>>(){
    @Override public IgniteInternalFuture<Object> apply(){
      updateFut.map(waitTopFut);
      return updateFut;
    }
  }
);
}
