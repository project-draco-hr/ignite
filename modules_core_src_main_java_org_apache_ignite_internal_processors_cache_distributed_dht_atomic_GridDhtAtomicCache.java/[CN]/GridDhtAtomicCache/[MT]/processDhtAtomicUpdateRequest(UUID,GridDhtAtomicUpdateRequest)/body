{
  if (log.isDebugEnabled())   log.debug("Processing dht atomic update request [nodeId=" + nodeId + ", req="+ req+ ']');
  GridCacheVersion ver=req.writeVersion();
  GridDhtAtomicUpdateResponse res=new GridDhtAtomicUpdateResponse(ctx.cacheId(),req.futureVersion(),ctx.deploymentEnabled());
  Boolean replicate=ctx.isDrEnabled();
  boolean intercept=req.forceTransformBackups() && ctx.config().getInterceptor() != null;
  String taskName=ctx.kernalContext().task().resolveTaskName(req.taskNameHash());
  boolean initLsnrs=false;
  Map<UUID,CacheContinuousQueryListener> lsnrs=null;
  boolean internal=false;
  for (int i=0; i < req.size(); i++) {
    KeyCacheObject key=req.key(i);
    try {
      while (true) {
        GridDhtCacheEntry entry=null;
        try {
          entry=entryExx(key);
          CacheObject val=req.value(i);
          CacheObject prevVal=req.previousValue(i);
          EntryProcessor<Object,Object,Object> entryProcessor=req.entryProcessor(i);
          Long updateIdx=req.updateCounter(i);
          GridCacheOperation op=entryProcessor != null ? TRANSFORM : (val != null) ? UPDATE : DELETE;
          long ttl=req.ttl(i);
          long expireTime=req.conflictExpireTime(i);
          if (!initLsnrs) {
            internal=entry.isInternal() || !context().userCache();
            lsnrs=ctx.continuousQueries().updateListeners(internal,false);
            initLsnrs=true;
          }
          GridCacheUpdateAtomicResult updRes=entry.innerUpdate(ver,nodeId,nodeId,op,op == TRANSFORM ? entryProcessor : val,op == TRANSFORM ? req.invokeArguments() : null,false,false,lsnrs != null,req.keepBinary(),null,true,true,false,!req.forceTransformBackups(),req.topologyVersion(),CU.empty0(),replicate ? DR_BACKUP : DR_NONE,ttl,expireTime,req.conflictVersion(i),false,intercept,req.subjectId(),taskName,prevVal,updateIdx);
          if (updRes.removeVersion() != null)           ctx.onDeferredDelete(entry,updRes.removeVersion());
          if (lsnrs != null && updRes.updateCounter() != 0) {
            ctx.continuousQueries().onEntryUpdated(lsnrs,entry.key(),updRes.newValue(),updRes.oldValue(),internal,entry.partition(),false,false,updRes.updateCounter(),req.topologyVersion());
          }
          entry.onUnlock();
          break;
        }
 catch (        GridCacheEntryRemovedException ignored) {
          if (log.isDebugEnabled())           log.debug("Got removed entry while updating backup value (will retry): " + key);
          entry=null;
        }
 finally {
          if (entry != null)           ctx.evicts().touch(entry,req.topologyVersion());
        }
      }
    }
 catch (    GridDhtInvalidPartitionException ignored) {
    }
catch (    IgniteCheckedException e) {
      res.addFailedKey(key,new IgniteCheckedException("Failed to update key on backup node: " + key,e));
    }
  }
  if (isNearEnabled(cacheCfg))   ((GridNearAtomicCache<K,V>)near()).processDhtAtomicUpdateRequest(nodeId,req,res);
  try {
    if (res.failedKeys() != null || res.nearEvicted() != null || req.writeSynchronizationMode() == FULL_SYNC)     ctx.io().send(nodeId,res,ctx.ioPolicy());
 else {
      sendDeferredUpdateResponse(nodeId,req.futureVersion());
    }
  }
 catch (  ClusterTopologyCheckedException ignored) {
    U.warn(log,"Failed to send DHT atomic update response to node because it left grid: " + req.nodeId());
  }
catch (  IgniteCheckedException e) {
    U.error(log,"Failed to send DHT atomic update response (did node leave grid?) [nodeId=" + nodeId + ", req="+ req+ ']',e);
  }
}
