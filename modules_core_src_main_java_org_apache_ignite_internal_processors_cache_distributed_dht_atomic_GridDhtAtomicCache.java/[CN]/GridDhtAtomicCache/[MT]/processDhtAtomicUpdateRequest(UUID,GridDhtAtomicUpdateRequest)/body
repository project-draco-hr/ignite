{
  if (msgLog.isDebugEnabled()) {
    msgLog.debug("Received DHT atomic update request [futId=" + req.futureVersion() + ", writeVer="+ req.writeVersion()+ ", node="+ nodeId+ ']');
  }
  GridCacheVersion ver=req.writeVersion();
  GridDhtAtomicUpdateResponse res=new GridDhtAtomicUpdateResponse(ctx.cacheId(),req.futureVersion(),ctx.deploymentEnabled());
  Boolean replicate=ctx.isDrEnabled();
  boolean intercept=req.forceTransformBackups() && ctx.config().getInterceptor() != null;
  String taskName=ctx.kernalContext().task().resolveTaskName(req.taskNameHash());
  for (int i=0; i < req.size(); i++) {
    KeyCacheObject key=req.key(i);
    try {
      while (true) {
        GridDhtCacheEntry entry=null;
        try {
          entry=entryExx(key);
          CacheObject val=req.value(i);
          CacheObject prevVal=req.previousValue(i);
          EntryProcessor<Object,Object,Object> entryProcessor=req.entryProcessor(i);
          Long updateIdx=req.updateCounter(i);
          GridCacheOperation op=entryProcessor != null ? TRANSFORM : (val != null) ? UPDATE : DELETE;
          long ttl=req.ttl(i);
          long expireTime=req.conflictExpireTime(i);
          GridCacheUpdateAtomicResult updRes=entry.innerUpdate(ver,nodeId,nodeId,op,op == TRANSFORM ? entryProcessor : val,op == TRANSFORM ? req.invokeArguments() : null,(ctx.store().isLocal() && !ctx.shared().localStorePrimaryOnly()) && writeThrough() && !req.skipStore(),false,false,req.keepBinary(),null,true,true,false,!req.forceTransformBackups(),req.topologyVersion(),CU.empty0(),replicate ? DR_BACKUP : DR_NONE,ttl,expireTime,req.conflictVersion(i),false,intercept,req.subjectId(),taskName,prevVal,updateIdx,null);
          if (updRes.removeVersion() != null)           ctx.onDeferredDelete(entry,updRes.removeVersion());
          entry.onUnlock();
          break;
        }
 catch (        GridCacheEntryRemovedException ignored) {
          if (log.isDebugEnabled())           log.debug("Got removed entry while updating backup value (will retry): " + key);
          entry=null;
        }
 finally {
          if (entry != null)           ctx.evicts().touch(entry,req.topologyVersion());
        }
      }
    }
 catch (    GridDhtInvalidPartitionException ignored) {
    }
catch (    IgniteCheckedException e) {
      res.addFailedKey(key,new IgniteCheckedException("Failed to update key on backup node: " + key,e));
    }
  }
  if (isNearEnabled(cacheCfg))   ((GridNearAtomicCache<K,V>)near()).processDhtAtomicUpdateRequest(nodeId,req,res);
  try {
    if (res.failedKeys() != null || res.nearEvicted() != null || req.writeSynchronizationMode() == FULL_SYNC) {
      ctx.io().send(nodeId,res,ctx.ioPolicy());
      if (msgLog.isDebugEnabled()) {
        msgLog.debug("Sent DHT atomic update response [futId=" + req.futureVersion() + ", writeVer="+ req.writeVersion()+ ", node="+ nodeId+ ']');
      }
    }
 else {
      if (msgLog.isDebugEnabled()) {
        msgLog.debug("Will send deferred DHT atomic update response [futId=" + req.futureVersion() + ", writeVer="+ req.writeVersion()+ ", node="+ nodeId+ ']');
      }
      sendDeferredUpdateResponse(nodeId,req.futureVersion());
    }
  }
 catch (  ClusterTopologyCheckedException ignored) {
    U.warn(msgLog,"Failed to send DHT atomic update response, node left [futId=" + req.futureVersion() + ", node="+ req.nodeId()+ ']');
  }
catch (  IgniteCheckedException e) {
    U.error(msgLog,"Failed to send DHT atomic update response [futId=" + req.futureVersion() + ", node="+ nodeId+ ", res="+ res+ ']',e);
  }
}
