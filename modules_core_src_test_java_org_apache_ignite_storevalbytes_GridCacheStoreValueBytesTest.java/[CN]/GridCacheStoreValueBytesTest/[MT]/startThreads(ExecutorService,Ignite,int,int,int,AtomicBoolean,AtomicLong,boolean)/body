{
  final Semaphore sem=new Semaphore(concurrentGetNum);
  final IgniteInClosure<Object> lsnr=new CI1<Object>(){
    @Override public void apply(    Object t){
      sem.release();
    }
  }
;
  finish.set(false);
  cntr.set(0);
  Collection<Future<?>> futs=new ArrayList<>(threadsNum);
  for (int i=0; i < threadsNum; i++) {
    futs.add(exec.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        IgniteCache<Integer,String> cache=ignite.jcache(null);
        Random random=new Random();
        while (!finish.get()) {
          Set<Integer> keys=new TreeSet<>();
          for (int i=0; i < KEYS_NUM; i++) {
            Integer key=KEYS[randomGet ? random.nextInt(KEYS_NUM) : i];
            keys.add(key);
            if (keys.size() == getKeyNum) {
              sem.acquire();
              IgniteCache<Integer,String> asyncCache=cache.withAsync();
              asyncCache.getAll(keys);
              IgniteFuture<Object> f=asyncCache.future();
              f.listenAsync(lsnr);
              cntr.incrementAndGet();
              keys.clear();
            }
          }
        }
        return null;
      }
    }
));
  }
  return futs;
}
