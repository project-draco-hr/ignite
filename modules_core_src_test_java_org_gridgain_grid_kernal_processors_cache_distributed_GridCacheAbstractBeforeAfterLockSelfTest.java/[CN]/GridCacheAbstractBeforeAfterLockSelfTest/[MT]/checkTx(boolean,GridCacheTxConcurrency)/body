{
  CollectBeforeLockClosure[] closures=new CollectBeforeLockClosure[gridCount()];
  CollectAfterUnlockClosure[] inClosures=new CollectAfterUnlockClosure[gridCount()];
  for (int i=0; i < gridCount(); i++) {
    closures[i]=new CollectBeforeLockClosure();
    inClosures[i]=new CollectAfterUnlockClosure();
    GridCacheAdapter<Object,Object> cache=((GridKernal)grid(i)).context().cache().internalCache();
    cache.beforePessimisticLock(closures[i]);
    cache.afterPessimisticUnlock(inClosures[i]);
  }
  GridCache<String,String> cache=grid(0).cache(null);
  if (commit && concurrency == PESSIMISTIC) {
    for (int i=0; i < 10; i++)     cache.put("key" + i,"val" + i);
  }
  cache.get("non-lock");
  GridCacheTx tx=cache.txStart(concurrency,READ_COMMITTED);
  try {
    cache.get("non-lock");
    for (int k=10; k < 30; k++)     cache.put("key" + k,"val" + k);
    if (commit)     tx.commit();
  }
  finally {
    tx.close();
  }
  tx=cache.txStart(concurrency,REPEATABLE_READ);
  try {
    for (int k=30; k < 50; k++)     cache.get("key" + k);
    if (commit)     tx.commit();
  }
  finally {
    tx.close();
  }
  Collection<Object> allLocked=new HashSet<>(50,1.0f);
  for (int i=0; i < gridCount(); i++) {
    Collection<Object> locked=new ArrayList<>(closures[i].events());
    Collection<Object> unlocked=new ArrayList<>(inClosures[i].events());
    assertTrue("Different lock and unlock sets [idx=" + i + ", locked="+ locked+ ", unlocked="+ unlocked,locked.containsAll(unlocked) && unlocked.containsAll(locked));
    for (    Object o : locked)     assertFalse("non-lock".equals(o));
    allLocked.addAll(locked);
  }
  if (concurrency == PESSIMISTIC) {
    for (int k=commit ? 0 : 10; k < 50; k++)     assertTrue("Missing locked key: " + k,allLocked.contains("key" + k));
  }
 else   assertTrue(allLocked.isEmpty());
}
