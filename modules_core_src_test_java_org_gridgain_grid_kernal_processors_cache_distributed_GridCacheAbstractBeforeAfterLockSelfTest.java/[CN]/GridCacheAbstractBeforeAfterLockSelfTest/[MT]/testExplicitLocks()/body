{
  CollectBeforeLockClosure[] closures=new CollectBeforeLockClosure[gridCount()];
  CollectAfterUnlockClosure[] inClosures=new CollectAfterUnlockClosure[gridCount()];
  for (int i=0; i < gridCount(); i++) {
    closures[i]=new CollectBeforeLockClosure();
    inClosures[i]=new CollectAfterUnlockClosure();
    GridCacheAdapter<Object,Object> cache=((GridKernal)grid(i)).context().cache().internalCache();
    cache.beforePessimisticLock(closures[i]);
    cache.afterPessimisticUnlock(inClosures[i]);
  }
  GridCache<String,String> cache=grid(0).cache(null);
  for (int i=0; i < 10; i++)   cache.lock("key" + i,0L);
  try {
    cache.get("non-lock");
  }
  finally {
    for (int i=0; i < 10; i++)     cache.unlock("key" + i);
  }
  U.sleep(1000);
  Collection<Object> allLocked=new HashSet<>(10,1.0f);
  for (int i=0; i < gridCount(); i++) {
    Collection<Object> locked=new ArrayList<>(closures[i].events());
    Collection<Object> unlocked=new ArrayList<>(inClosures[i].events());
    assertTrue("Different lock and unlock sets [idx=" + i + ", locked="+ locked+ ", unlocked="+ unlocked+ ']',locked.containsAll(unlocked) && unlocked.containsAll(locked));
    for (    Object o : locked)     assertFalse("non-lock".equals(o));
    allLocked.addAll(locked);
  }
  for (int k=0; k < 10; k++)   assertTrue("Missing locked key: " + k,allLocked.contains("key" + k));
}
