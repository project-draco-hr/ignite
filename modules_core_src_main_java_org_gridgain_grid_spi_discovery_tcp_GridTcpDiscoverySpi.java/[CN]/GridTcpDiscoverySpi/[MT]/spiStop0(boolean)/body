{
  if (ctxInitLatch.getCount() > 0)   ctxInitLatch.countDown();
  if (log.isDebugEnabled()) {
    if (disconnect)     log.debug("Disconnecting SPI.");
 else     log.debug("Preparing to start local node stop procedure.");
  }
  if (disconnect) {
synchronized (mux) {
      spiState=DISCONNECTING;
    }
  }
  if (msgWorker != null && msgWorker.isAlive() && !disconnect) {
    msgWorker.addMessage(new GridTcpDiscoveryNodeLeftMessage(locNodeId));
synchronized (mux) {
      long threshold=U.currentTimeMillis() + netTimeout;
      long timeout=netTimeout;
      while (spiState != LEFT && timeout > 0) {
        try {
          mux.wait(timeout);
          timeout=threshold - U.currentTimeMillis();
        }
 catch (        InterruptedException ignored) {
          Thread.currentThread().interrupt();
          break;
        }
      }
      if (spiState == LEFT) {
        if (log.isDebugEnabled())         log.debug("Verification for local node leave has been received from coordinator" + " (continuing stop procedure).");
      }
 else       if (log.isInfoEnabled()) {
        log.info("No verification for local node leave has been received from coordinator" + " (will stop node anyway).");
      }
    }
  }
  U.interrupt(tcpSrvr);
  U.join(tcpSrvr,log);
  Collection<SocketReader> tmp;
synchronized (mux) {
    tmp=new ArrayList<>(readers);
  }
  U.interrupt(tmp);
  U.joinThreads(tmp,log);
  U.interrupt(hbsSnd);
  U.join(hbsSnd,log);
  U.interrupt(chkStatusSnd);
  U.join(chkStatusSnd,log);
  U.interrupt(ipFinderCleaner);
  U.join(ipFinderCleaner,log);
  U.interrupt(msgWorker);
  U.join(msgWorker,log);
  U.interrupt(sockTimeoutWorker);
  U.join(sockTimeoutWorker,log);
  U.interrupt(statsPrinter);
  U.join(statsPrinter,log);
  if (ipFinder != null)   ipFinder.close();
  Collection<GridTcpDiscoveryNode> rmts=null;
  if (!disconnect) {
    unregisterMBean();
    if (log.isDebugEnabled())     log.debug(stopInfo());
  }
 else {
    getSpiContext().deregisterPorts();
    rmts=ring.remoteNodes();
  }
  long topVer=ring.topologyVersion();
  ring.clear();
  if (rmts != null && !rmts.isEmpty()) {
    GridDiscoverySpiListener lsnr=this.lsnr;
    if (lsnr != null) {
      Collection<GridNode> processed=new LinkedList<>();
      for (      GridTcpDiscoveryNode n : rmts) {
        processed.add(n);
        if (n.visible()) {
          Collection<GridNode> top=F.viewReadOnly(rmts,F.<GridNode>identity(),F.and(F.notIn(processed),VISIBLE_NODES));
          topVer++;
          Map<Long,Collection<GridNode>> hist=updateTopologyHistory(topVer,top);
          lsnr.onDiscovery(EVT_NODE_FAILED,topVer,n,top,hist);
        }
      }
    }
  }
  printStatistics();
  stats.clear();
synchronized (mux) {
    leavingNodes.clear();
    failedNodes.clear();
    spiState=DISCONNECTED;
  }
}
