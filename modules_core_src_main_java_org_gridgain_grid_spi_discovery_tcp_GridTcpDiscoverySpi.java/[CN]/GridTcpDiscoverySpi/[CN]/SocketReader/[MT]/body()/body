{
  try {
    InputStream in;
    try {
      sock.setKeepAlive(true);
      sock.setTcpNoDelay(true);
      int timeout=sock.getSoTimeout();
      sock.setSoTimeout((int)netTimeout);
      in=new BufferedInputStream(sock.getInputStream());
      byte[] buf=new byte[4];
      int read=0;
      while (read < buf.length) {
        int r=in.read(buf,read,buf.length - read);
        if (r >= 0)         read+=r;
 else {
          if (log.isDebugEnabled())           log.debug("Failed to read magic header (too few bytes received) " + "[rmtAddr=" + sock.getRemoteSocketAddress() + ", locAddr="+ sock.getLocalSocketAddress()+ ']');
          LT.warn(log,null,"Failed to read magic header (too few bytes received) [rmtAddr=" + sock.getRemoteSocketAddress() + ", locAddr="+ sock.getLocalSocketAddress()+ ']');
          return;
        }
      }
      if (!U.bytesEqual(buf,0,U.GG_HEADER,0,4)) {
        if (log.isDebugEnabled())         log.debug("Unknown connection detected (is some other software connecting to " + "this GridGain port?) " + "[rmtAddr=" + sock.getRemoteSocketAddress() + ", locAddr="+ sock.getLocalSocketAddress()+ ']');
        LT.warn(log,null,"Unknown connection detected (is some other software connecting to " + "this GridGain port?) [rmtAddr=" + sock.getRemoteSocketAddress() + ", locAddr="+ sock.getLocalSocketAddress()+ ']');
        return;
      }
      sock.setSoTimeout(timeout);
      GridTcpDiscoveryHandshakeRequest req=readMessage(sock,in,netTimeout);
      UUID nodeId=req.creatorNodeId();
      this.nodeId=nodeId;
      GridTcpDiscoveryHandshakeResponse res=new GridTcpDiscoveryHandshakeResponse(locNodeId,locNode.internalOrder());
      writeToSocket(sock,res);
      if (locNodeId.equals(nodeId)) {
        if (log.isDebugEnabled())         log.debug("Handshake request from local node: " + req);
        return;
      }
      if (log.isDebugEnabled())       log.debug("Initialized connection with remote node: " + nodeId);
      if (debugMode)       debugLog("Initialized connection with remote node: " + nodeId);
    }
 catch (    IOException e) {
      if (log.isDebugEnabled())       U.error(log,"Caught exception on handshake [err=" + e + ", sock="+ sock+ ']',e);
      if (X.hasCause(e,ObjectStreamException.class) || !sock.isClosed()) {
        if (U.isMacInvalidArgumentError(e))         LT.error(log,e,"Failed to initialize connection [sock=" + sock + "]\n\t"+ U.MAC_INVALID_ARG_MSG);
 else         LT.error(log,e,"Failed to initialize connection [sock=" + sock + ']');
      }
      return;
    }
catch (    GridException e) {
      if (log.isDebugEnabled())       U.error(log,"Caught exception on handshake [err=" + e + ", sock="+ sock+ ']',e);
      if (e.hasCause(SocketTimeoutException.class))       LT.warn(log,null,"Socket operation timed out on handshake " + "(consider increasing 'networkTimeout' configuration property) " + "[netTimeout=" + netTimeout + ']');
 else       if (e.hasCause(ClassNotFoundException.class))       LT.warn(log,null,"Failed to read message due to ClassNotFoundException " + "(make sure same versions of all classes are available on all nodes) " + "[rmtAddr=" + sock.getRemoteSocketAddress() + ", err="+ X.cause(e,ClassNotFoundException.class).getMessage()+ ']');
 else       if (e.hasCause(ObjectStreamException.class) || (!sock.isClosed() && !e.hasCause(IOException.class)))       LT.error(log,e,"Failed to initialize connection [sock=" + sock + ']');
      return;
    }
    while (!isInterrupted()) {
      try {
        GridTcpDiscoveryAbstractMessage msg=marsh.unmarshal(in,U.gridClassLoader());
        msg.senderNodeId(nodeId);
        if (log.isDebugEnabled())         log.debug("Message has been received: " + msg);
        stats.onMessageReceived(msg);
        if (debugMode && recordable(msg))         debugLog("Message has been received: " + msg);
        if (msg instanceof GridTcpDiscoveryJoinRequestMessage) {
          GridTcpDiscoveryJoinRequestMessage req=(GridTcpDiscoveryJoinRequestMessage)msg;
          if (!req.responded()) {
            processJoinRequestMessage(req);
            break;
          }
        }
 else         if (msg instanceof GridTcpDiscoveryDuplicateIdMessage) {
          writeToSocket(sock,RES_OK);
          boolean ignored=false;
          GridTcpDiscoverySpiState state=null;
synchronized (mux) {
            if (spiState == CONNECTING) {
              joinRes.set(msg);
              spiState=DUPLICATE_ID;
              mux.notifyAll();
            }
 else {
              ignored=true;
              state=spiState;
            }
          }
          if (ignored && log.isDebugEnabled())           log.debug("Duplicate ID message has been ignored [msg=" + msg + ", spiState="+ state+ ']');
          continue;
        }
 else         if (msg instanceof GridTcpDiscoveryAuthFailedMessage) {
          writeToSocket(sock,RES_OK);
          boolean ignored=false;
          GridTcpDiscoverySpiState state=null;
synchronized (mux) {
            if (spiState == CONNECTING) {
              joinRes.set(msg);
              spiState=AUTH_FAILED;
              mux.notifyAll();
            }
 else {
              ignored=true;
              state=spiState;
            }
          }
          if (ignored && log.isDebugEnabled())           log.debug("Auth failed message has been ignored [msg=" + msg + ", spiState="+ state+ ']');
          continue;
        }
 else         if (msg instanceof GridTcpDiscoveryCheckFailedMessage) {
          writeToSocket(sock,RES_OK);
          boolean ignored=false;
          GridTcpDiscoverySpiState state=null;
synchronized (mux) {
            if (spiState == CONNECTING) {
              joinRes.set(msg);
              spiState=CHECK_FAILED;
              mux.notifyAll();
            }
 else {
              ignored=true;
              state=spiState;
            }
          }
          if (ignored && log.isDebugEnabled())           log.debug("Check failed message has been ignored [msg=" + msg + ", spiState="+ state+ ']');
          continue;
        }
 else         if (msg instanceof GridTcpDiscoveryLoopbackProblemMessage) {
          writeToSocket(sock,RES_OK);
          boolean ignored=false;
          GridTcpDiscoverySpiState state=null;
synchronized (mux) {
            if (spiState == CONNECTING) {
              joinRes.set(msg);
              spiState=LOOPBACK_PROBLEM;
              mux.notifyAll();
            }
 else {
              ignored=true;
              state=spiState;
            }
          }
          if (ignored && log.isDebugEnabled())           log.debug("Loopback problem message has been ignored [msg=" + msg + ", spiState="+ state+ ']');
          continue;
        }
        msgWorker.addMessage(msg);
        writeToSocket(sock,RES_OK);
      }
 catch (      GridException e) {
        if (log.isDebugEnabled())         U.error(log,"Caught exception on message read [sock=" + sock + ", locNodeId="+ locNodeId+ ", rmtNodeId="+ nodeId+ ']',e);
        if (isInterrupted() || sock.isClosed())         return;
        if (e.hasCause(ClassNotFoundException.class))         LT.warn(log,null,"Failed to read message due to ClassNotFoundException " + "(make sure same versions of all classes are available on all nodes) " + "[rmtNodeId=" + nodeId + ", err="+ X.cause(e,ClassNotFoundException.class).getMessage()+ ']');
        boolean err=e.hasCause(ObjectStreamException.class) || (nodeAlive(nodeId) && spiStateCopy() == CONNECTED && !X.hasCause(e,IOException.class));
        if (err)         LT.error(log,e,"Failed to read message [sock=" + sock + ", locNodeId="+ locNodeId+ ", rmtNodeId="+ nodeId+ ']');
        return;
      }
catch (      IOException e) {
        if (log.isDebugEnabled())         U.error(log,"Caught exception on message read [sock=" + sock + ", locNodeId="+ locNodeId+ ", rmtNodeId="+ nodeId+ ']',e);
        if (isInterrupted() || sock.isClosed())         return;
        boolean err=X.hasCause(e,ObjectStreamException.class) || (nodeAlive(nodeId) && spiStateCopy() == CONNECTED);
        if (err)         LT.error(log,e,"Failed to send receipt on message [sock=" + sock + ", locNodeId="+ locNodeId+ ", rmtNodeId="+ nodeId+ ']');
        return;
      }
    }
  }
  finally {
    U.closeQuiet(sock);
  }
}
