{
  final AtomicBoolean stop=new AtomicBoolean();
  final AtomicInteger createCtr=new AtomicInteger();
  final AtomicReference<Exception> err=new AtomicReference<>();
  igfs.create(FILE,false).close();
  int threadCnt=50;
  IgniteInternalFuture<?> fut=multithreadedAsync(new Runnable(){
    @Override public void run(){
      while (!stop.get() && err.get() == null) {
        IgfsOutputStream os=null;
        try {
          os=igfs.create(FILE,true);
          os.write(chunk);
          os.close();
          createCtr.incrementAndGet();
        }
 catch (        IgniteException e) {
        }
catch (        IOException e) {
          err.compareAndSet(null,e);
          Throwable[] chain=X.getThrowables(e);
          Throwable cause=chain[chain.length - 1];
          System.out.println("Failed due to IOException exception. Cause:");
          cause.printStackTrace(System.out);
        }
 finally {
          if (os != null)           try {
            os.close();
          }
 catch (          IOException ioe) {
            throw new IgniteException(ioe);
          }
        }
      }
    }
  }
,threadCnt);
  long startTime=U.currentTimeMillis();
  while (err.get() == null && createCtr.get() < 500 && U.currentTimeMillis() - startTime < 60 * 1000)   U.sleep(100);
  stop.set(true);
  fut.get();
  awaitFileClose(igfs.asSecondary(),FILE);
  if (err.get() != null) {
    X.println("Test failed: rethrowing first error: " + err.get());
    throw err.get();
  }
  checkFileContent(igfs,FILE,chunk);
}
