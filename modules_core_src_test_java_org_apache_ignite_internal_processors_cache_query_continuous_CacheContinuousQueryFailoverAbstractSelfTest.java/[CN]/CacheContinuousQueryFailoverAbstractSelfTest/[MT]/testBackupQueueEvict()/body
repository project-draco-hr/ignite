{
  startGridsMultiThreaded(2);
  client=true;
  Ignite qryClient=startGrid(2);
  CacheEventListener1 lsnr=new CacheEventListener1(false);
  ContinuousQuery<Object,Object> qry=new ContinuousQuery<>();
  qry.setLocalListener(lsnr);
  QueryCursor<?> cur=qryClient.cache(null).query(qry);
  final Collection<Object> backupQueue=backupQueue(ignite(0));
  assertEquals(0,backupQueue.size());
  long ttl=100;
  final ExpiryPolicy expiry=new TouchedExpiryPolicy(new Duration(MILLISECONDS,ttl));
  final IgniteCache<Object,Object> cache0=ignite(2).cache(null).withExpiryPolicy(expiry);
  final List<Integer> keys=primaryKeys(ignite(1).cache(null),BACKUP_ACK_THRESHOLD);
  CountDownLatch latch=new CountDownLatch(keys.size());
  lsnr.latch=latch;
  for (  Integer key : keys) {
    log.info("Put: " + key);
    cache0.put(key,key);
  }
  GridTestUtils.waitForCondition(new GridAbsPredicate(){
    @Override public boolean apply(){
      return backupQueue.isEmpty();
    }
  }
,2000);
  assertTrue("Backup queue is not cleared: " + backupQueue,backupQueue.size() < BACKUP_ACK_THRESHOLD);
  boolean wait=waitForCondition(new GridAbsPredicate(){
    @Override public boolean apply(){
      return cache0.localPeek(keys.get(0)) == null;
    }
  }
,ttl + 1000);
  assertTrue("Entry evicted.",wait);
  GridTestUtils.waitForCondition(new GridAbsPredicate(){
    @Override public boolean apply(){
      return backupQueue.isEmpty();
    }
  }
,2000);
  assertTrue("Backup queue is not cleared: " + backupQueue,backupQueue.size() < BACKUP_ACK_THRESHOLD);
  if (backupQueue.size() != 0) {
    for (    Object o : backupQueue) {
      CacheContinuousQueryEntry e=(CacheContinuousQueryEntry)o;
      assertNotSame("Evicted entry added to backup queue.",-1L,e.updateCounter());
    }
  }
  cur.close();
}
