{
  final String cfgPath=args.length > 0 ? args[0] : "examples/config/example-cache.xml";
  final String cacheName=getStringProperty(CACHE_NAME,"partitioned");
  final Integer valSize=getIntProperty(VALUE_SIZE,1024);
  final Integer threadsCnt=getIntProperty(THREADS_CNT,8);
  final Integer testDurSec=getIntProperty(TEST_DUR_SEC,180);
  final Integer filterSkipProb=getIntProperty("FILTER_SKIP_PROBABILITY",10,new C1<Integer,String>(){
    @Nullable @Override public String apply(    Integer val){
      if (val < 0 || val > 100)       return "The value should be between 1 and 100.";
      return null;
    }
  }
);
  final boolean useQry=getBooleanProperty("IGNITE_USE_QUERIES",true);
  final int bufSize=getIntProperty("IGNITE_BUFFER_SIZE",1);
  final long timeInterval=getLongProperty("IGNITE_TIME_INTERVAL",0);
  final int parallelCnt=getIntProperty("IGNITE_PARALLEL_COUNT",8);
  final int keyRange=getIntProperty("IGNITE_KEY_RANGE",100000);
  final long updSleepMs=getLongProperty("IGNITE_UPDATE_SLEEP_MS",0);
  final long filterSleepMs=getLongProperty("IGNITE_FILTER_SLEEP_MS",0);
  final long cbSleepMs=getLongProperty("IGNITE_CALLBACK_SLEEP_MS",0);
  X.println("The test will start with the following parameters:");
  dumpProperties(System.out);
  try (Ignite ignite=Ignition.start(cfgPath)){
    final GridCache<Object,Object> cache=ignite.cache(cacheName);
    if (cache == null)     throw new IgniteCheckedException("Cache is not configured: " + cacheName);
    final GridCacheContinuousQueryManager contQryMgr=((GridCacheAdapter)((GridCacheProxyImpl)cache).cache()).context().continuousQueries();
    if (contQryMgr == null)     throw new IgniteCheckedException("Could not access GridCacheContinuousQueryManager");
    final AtomicBoolean stop=new AtomicBoolean();
    final AtomicLong cbCntr=new AtomicLong();
    final AtomicLong updCntr=new AtomicLong();
    for (int i=0; i < parallelCnt; i++) {
      if (useQry) {
        CacheContinuousQuery<Object,Object> qry=cache.queries().createContinuousQuery();
        qry.callback(new PX2<UUID,Collection<Map.Entry<Object,Object>>>(){
          @Override public boolean applyx(          UUID uuid,          Collection<Map.Entry<Object,Object>> entries) throws IgniteInterruptedException {
            if (cbSleepMs > 0)             U.sleep(cbSleepMs);
            cbCntr.addAndGet(entries.size());
            return true;
          }
        }
);
        qry.filter(new PX2<Object,Object>(){
          @Override public boolean applyx(          Object key,          Object val) throws IgniteInterruptedException {
            if (filterSleepMs > 0)             U.sleep(filterSleepMs);
            return Math.random() * 100 >= filterSkipProb;
          }
        }
);
        qry.bufferSize(bufSize);
        qry.timeInterval(timeInterval);
        qry.execute();
      }
 else {
        ignite.events().remoteListen(bufSize,timeInterval,true,new PX2<UUID,IgniteEvent>(){
          @Override public boolean applyx(          UUID uuid,          IgniteEvent evt) throws IgniteInterruptedException {
            if (cbSleepMs > 0)             U.sleep(cbSleepMs);
            cbCntr.incrementAndGet();
            return true;
          }
        }
,new PX1<IgniteEvent>(){
          @Override public boolean applyx(          IgniteEvent evt) throws IgniteInterruptedException {
            if (filterSleepMs > 0)             U.sleep(filterSleepMs);
            return Math.random() * 100 >= filterSkipProb;
          }
        }
,EVT_CACHE_OBJECT_PUT);
      }
    }
    startDaemon(new Runnable(){
      @Override public void run(){
        try {
          while (!stop.get() && !Thread.currentThread().isInterrupted()) {
            long cbCntr0=cbCntr.get();
            long updCntr0=updCntr.get();
            U.sleep(1000);
            long cbDelta=cbCntr.get() - cbCntr0;
            long updDelta=updCntr.get() - updCntr0;
            X.println("Stats [entriesPerSec=" + cbDelta + ", updatesPerSec="+ updDelta+ ']');
          }
        }
 catch (        IgniteInterruptedException ignored) {
        }
      }
    }
);
    X.println("Starting " + threadsCnt + " generator thread(s).");
    IgniteFuture<Long> genFut=runMultiThreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        byte[] val=new byte[valSize];
        ThreadLocalRandom8 rnd=ThreadLocalRandom8.current();
        while (!stop.get() && !Thread.currentThread().isInterrupted()) {
          Integer key=rnd.nextInt(keyRange);
          cache.putx(key,val);
          updCntr.incrementAndGet();
          if (updSleepMs > 0)           U.sleep(updSleepMs);
        }
        return true;
      }
    }
,threadsCnt,"load-test-generator");
    U.sleep(testDurSec * 1000);
    stop.set(true);
    genFut.get();
  }
 }
