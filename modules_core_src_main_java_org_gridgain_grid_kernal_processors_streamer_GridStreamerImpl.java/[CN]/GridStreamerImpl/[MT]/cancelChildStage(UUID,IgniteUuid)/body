{
  assert atLeastOnce;
  if (nodeId.equals(ctx.localNodeId())) {
    cancelledFutIds.add(cancelledFutId);
    Iterator<Map.Entry<IgniteUuid,BatchExecutionFuture>> it=batchFuts.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<IgniteUuid,BatchExecutionFuture> entry=it.next();
      if (entry.getKey().equals(cancelledFutId)) {
        BatchExecutionFuture batchFut=entry.getValue();
        try {
          batchFut.cancel();
        }
 catch (        GridException e) {
          log.warning("Failed to cancel batch execution future [cancelledFutId=" + cancelledFutId + ", batchFut="+ batchFut+ ']',e);
        }
        it.remove();
      }
    }
  }
 else {
    try {
      sendWithRetries(nodeId,new GridStreamerCancelRequest(cancelledFutId));
    }
 catch (    GridException e) {
      if (!e.hasCause(GridTopologyException.class))       log.error("Failed to send streamer cancel request to remote node [nodeId=" + nodeId + ", cancelledFutId="+ cancelledFutId+ ']',e);
    }
  }
}
