{
  if (log.isDebugEnabled())   log.debug("Starting streamer: " + name);
  if (F.isEmpty(c.getStages()))   throw new GridException("Streamer should have at least one stage configured " + "(fix configuration and restart): " + name);
  if (F.isEmpty(c.getWindows()))   throw new GridException("Streamer should have at least one window configured " + "(fix configuration and restart): " + name);
  prepareResources();
  U.startLifecycleAware(lifecycleAwares());
  stages=new LinkedHashMap<>(c.getStages().size());
  int stageIdx=0;
  GridStreamerStageWrapper prev=null;
  for (  GridStreamerStage s : c.getStages()) {
    String sName=s.name();
    if (F.isEmpty(sName))     throw new GridException("Streamer stage should have non-empty name [streamerName=" + name + ", stage="+ s+ ']');
    if (stages.containsKey(sName))     throw new GridException("Streamer stages have duplicate names (all names should be unique) " + "[streamerName=" + name + ", stage="+ s+ ", stageName="+ sName+ ']');
    if (firstStage == null)     firstStage=sName;
    GridStreamerStageWrapper wrapper=new GridStreamerStageWrapper(s,stageIdx);
    stages.put(sName,wrapper);
    if (prev != null)     prev.nextStageName(s.name());
    prev=wrapper;
    stageIdx++;
  }
  winMap=new LinkedHashMap<>();
  for (  GridStreamerWindow w : c.getWindows()) {
    String wName=w.name();
    if (F.isEmpty(wName))     throw new GridException("Streamer window should have non-empty name [streamerName=" + name + ", window="+ w+ ']');
    if (winMap.containsKey(wName))     throw new GridException("Streamer windows have duplicate names (all names should be unique). " + "If you use two or more windows of the same type you need to assign their names explicitly " + "[streamer=" + name + ", windowName="+ wName+ ']');
    winMap.put(wName,w);
    if (dfltWin == null)     dfltWin=w;
  }
  execSvc=c.getExecutorService();
  if (execSvc == null) {
    execSvc=new GridThreadPoolExecutor(ctx.gridName(),Runtime.getRuntime().availableProcessors(),Runtime.getRuntime().availableProcessors(),0,new LinkedBlockingQueue<Runnable>());
    execSvcCap=Runtime.getRuntime().availableProcessors();
    dfltExecSvc=true;
  }
 else {
    if (execSvc instanceof ThreadPoolExecutor) {
      ThreadPoolExecutor exec=(ThreadPoolExecutor)execSvc;
      execSvcCap=exec.getMaximumPoolSize();
    }
 else     execSvcCap=-1;
  }
  resetMetrics();
  if (router == null)   router=new GridStreamerLocalEventRouter();
  ctx.io().addMessageListener(topic,new GridMessageListener(){
    @Override public void onMessage(    UUID nodeId,    Object msg){
      if (log.isDebugEnabled())       log.debug("Received message [nodeId=" + nodeId + ", msg="+ msg+ ']');
      processStreamerMessage(nodeId,msg);
    }
  }
);
  ctx.event().addLocalEventListener(new GridLocalEventListener(){
    @Override public void onEvent(    GridEvent evt){
      GridDiscoveryEvent discoEvt=(GridDiscoveryEvent)evt;
      for (      GridStreamerStageExecutionFuture fut : stageFuts.values())       fut.onNodeLeft(discoEvt.eventNodeId());
    }
  }
,EVT_NODE_LEFT,EVT_NODE_FAILED);
}
