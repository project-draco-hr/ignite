{
  if (checkThreadTx)   checkEmptyTransactions();
  DynamicCacheDescriptor desc=registeredCaches.get(maskNull(cacheName));
  DynamicCacheChangeRequest req=new DynamicCacheChangeRequest(cacheName,ctx.localNodeId());
  req.failIfExists(failIfExists);
  if (ccfg != null) {
    try {
      cloneCheckSerializable(ccfg);
    }
 catch (    IgniteCheckedException e) {
      return new GridFinishedFuture<>(e);
    }
    if (desc != null) {
      if (failIfExists) {
        return new GridFinishedFuture<>(new CacheExistsException("Failed to start cache " + "(a cache with the same name is already started): " + cacheName));
      }
 else {
        CacheConfiguration descCfg=desc.cacheConfiguration();
        if (nearCfg != null) {
          if (CU.affinityNode(ctx.discovery().localNode(),descCfg.getNodeFilter())) {
            if (descCfg.getNearConfiguration() != null)             return new GridFinishedFuture<>();
 else             return new GridFinishedFuture<>(new IgniteCheckedException("Failed to start near " + "cache (local node is an affinity node for cache): " + cacheName));
          }
 else           req.clientStartOnly(true);
        }
 else         req.clientStartOnly(true);
        req.deploymentId(desc.deploymentId());
        req.startCacheConfiguration(descCfg);
      }
    }
 else {
      req.deploymentId(IgniteUuid.randomUuid());
      try {
        CacheConfiguration cfg=new CacheConfiguration(ccfg);
        CacheObjectContext cacheObjCtx=ctx.cacheObjects().contextForCache(cfg);
        initialize(false,cfg,cacheObjCtx);
        req.startCacheConfiguration(cfg);
      }
 catch (      IgniteCheckedException e) {
        return new GridFinishedFuture(e);
      }
    }
  }
 else {
    req.clientStartOnly(true);
    if (desc != null)     ccfg=desc.cacheConfiguration();
    if (ccfg == null) {
      if (failIfNotStarted)       return new GridFinishedFuture<>(new CacheExistsException("Failed to start client cache " + "(a cache with the given name is not started): " + cacheName));
 else       return new GridFinishedFuture<>();
    }
    req.deploymentId(desc.deploymentId());
    req.startCacheConfiguration(ccfg);
  }
  if (ccfg.isSwapEnabled())   for (  ClusterNode n : ctx.discovery().allNodes())   if (!GridCacheUtils.clientNode(n) && !GridCacheUtils.isSwapEnabled(n))   return new GridFinishedFuture<>(new IgniteCheckedException("Failed to start cache " + cacheName + " with swap enabled: Remote Node with ID "+ n.id().toString().toUpperCase()+ " has not swap SPI configured"));
  if (nearCfg != null)   req.nearCacheConfiguration(nearCfg);
  req.cacheType(cacheType);
  return F.first(initiateCacheChanges(F.asList(req),failIfExists));
}
