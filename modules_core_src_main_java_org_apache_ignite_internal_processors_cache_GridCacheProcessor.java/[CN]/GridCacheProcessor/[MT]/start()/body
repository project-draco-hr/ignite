{
  if (ctx.config().isDaemon())   return;
  DeploymentMode depMode=ctx.config().getDeploymentMode();
  if (!F.isEmpty(ctx.config().getCacheConfiguration())) {
    if (depMode != CONTINUOUS && depMode != SHARED)     U.warn(log,"Deployment mode for cache is not CONTINUOUS or SHARED " + "(it is recommended that you change deployment mode and restart): " + depMode,"Deployment mode for cache is not CONTINUOUS or SHARED.");
  }
  maxPreloadOrder=validatePreloadOrder(ctx.config().getCacheConfiguration());
  ctx.discovery().setCustomEventListener(new GridPlainInClosure<Serializable>(){
    @Override public void apply(    Serializable evt){
      if (evt instanceof DynamicCacheChangeBatch)       onCacheChangeRequested((DynamicCacheChangeBatch)evt);
    }
  }
);
  IgfsConfiguration[] igfsCfgs=ctx.grid().configuration().getIgfsConfiguration();
  if (igfsCfgs != null) {
    for (    IgfsConfiguration igfsCfg : igfsCfgs) {
      sysCaches.add(igfsCfg.getMetaCacheName());
      sysCaches.add(igfsCfg.getDataCacheName());
    }
  }
  if (IgniteComponentType.HADOOP.inClassPath())   sysCaches.add(CU.SYS_CACHE_HADOOP_MR);
  sysCaches.add(CU.UTILITY_CACHE_NAME);
  sysCaches.add(CU.ATOMICS_CACHE_NAME);
  CacheConfiguration[] cfgs=ctx.config().getCacheConfiguration();
  sharedCtx=createSharedContext(ctx);
  ctx.performance().add("Disable serializable transactions (set 'txSerializableEnabled' to false)",!ctx.config().getTransactionConfiguration().isTxSerializableEnabled());
  Collection<GridCacheAdapter<?,?>> startSeq=new ArrayList<>(cfgs.length);
  for (int i=0; i < cfgs.length; i++) {
    CacheConfiguration<?,?> cfg=new CacheConfiguration(cfgs[i]);
    initialize(cfg);
    cfgs[i]=cfg;
    if (caches.containsKey(cfg.getName())) {
      String cacheName=cfg.getName();
      if (cacheName != null)       throw new IgniteCheckedException("Duplicate cache name found (check configuration and " + "assign unique name to each cache): " + cacheName);
 else       throw new IgniteCheckedException("Default cache has already been configured (check configuration and " + "assign unique name to each cache).");
    }
    GridCacheContext cacheCtx=createCache(cfg);
    sharedCtx.addCacheContext(cacheCtx);
    startSeq.add(cacheCtx.cache());
    caches.put(cfg.getName(),cacheCtx.cache());
    if (sysCaches.contains(cfg.getName()))     stopSeq.addLast(cacheCtx.cache());
 else     stopSeq.addFirst(cacheCtx.cache());
  }
  for (  GridCacheSharedManager mgr : sharedCtx.managers())   mgr.start(sharedCtx);
  for (  GridCacheAdapter<?,?> cache : startSeq)   startCache(cache);
  for (  Map.Entry<String,GridCacheAdapter<?,?>> e : caches.entrySet()) {
    GridCacheAdapter cache=e.getValue();
    proxies.put(e.getKey(),new GridCacheProxyImpl(cache.context(),cache,null));
    jCacheProxies.put(e.getKey(),new IgniteCacheProxy(cache.context(),cache,null,false));
  }
  for (  Map.Entry<String,GridCacheAdapter<?,?>> e : caches.entrySet()) {
    GridCacheAdapter cache=e.getValue();
    if (!sysCaches.contains(e.getKey()))     publicProxies.put(e.getKey(),new GridCacheProxyImpl(cache.context(),cache,null));
  }
  transactions=new IgniteTransactionsImpl(sharedCtx);
  if (log.isDebugEnabled())   log.debug("Started cache processor.");
}
