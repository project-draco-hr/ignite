{
  if (cc.getCacheMode() == REPLICATED) {
    if (cc.getNearConfiguration() != null && ctx.discovery().cacheAffinityNode(ctx.discovery().localNode(),cc.getName())) {
      U.warn(log,"Near cache cannot be used with REPLICATED cache, " + "will be ignored [cacheName=" + U.maskName(cc.getName()) + ']');
      cc.setNearConfiguration(null);
    }
  }
  if (cc.getCacheMode() == LOCAL && !cc.getAffinity().getClass().equals(LocalAffinityFunction.class))   U.warn(log,"AffinityFunction configuration parameter will be ignored for local cache [cacheName=" + U.maskName(cc.getName()) + ']');
  if (cc.getRebalanceMode() != CacheRebalanceMode.NONE) {
    assertParameter(cc.getRebalanceThreadPoolSize() > 0,"rebalanceThreadPoolSize > 0");
    assertParameter(cc.getRebalanceBatchSize() > 0,"rebalanceBatchSize > 0");
  }
  if (cc.getCacheMode() == PARTITIONED || cc.getCacheMode() == REPLICATED) {
    if (cc.getAtomicityMode() == ATOMIC && cc.getWriteSynchronizationMode() == FULL_ASYNC)     U.warn(log,"Cache write synchronization mode is set to FULL_ASYNC. All single-key 'put' and " + "'remove' operations will return 'null', all 'putx' and 'removex' operations will return" + " 'true' [cacheName=" + U.maskName(cc.getName()) + ']');
  }
  DeploymentMode depMode=c.getDeploymentMode();
  if (c.isPeerClassLoadingEnabled() && (depMode == PRIVATE || depMode == ISOLATED) && !CU.isSystemCache(cc.getName()))   throw new IgniteCheckedException("Cannot start cache in PRIVATE or ISOLATED deployment mode: " + ctx.config().getDeploymentMode());
  if (!c.getTransactionConfiguration().isTxSerializableEnabled() && c.getTransactionConfiguration().getDefaultTxIsolation() == SERIALIZABLE)   U.warn(log,"Serializable transactions are disabled while default transaction isolation is SERIALIZABLE " + "(most likely misconfiguration - either update 'isTxSerializableEnabled' or " + "'defaultTxIsolationLevel' properties) for cache: "+ U.maskName(cc.getName()),"Serializable transactions are disabled while default transaction isolation is SERIALIZABLE " + "for cache: " + U.maskName(cc.getName()));
  if (cc.isWriteBehindEnabled()) {
    if (cfgStore == null)     throw new IgniteCheckedException("Cannot enable write-behind (writer or store is not provided) " + "for cache: " + U.maskName(cc.getName()));
    assertParameter(cc.getWriteBehindBatchSize() > 0,"writeBehindBatchSize > 0");
    assertParameter(cc.getWriteBehindFlushSize() >= 0,"writeBehindFlushSize >= 0");
    assertParameter(cc.getWriteBehindFlushFrequency() >= 0,"writeBehindFlushFrequency >= 0");
    assertParameter(cc.getWriteBehindFlushThreadCount() > 0,"writeBehindFlushThreadCount > 0");
    if (cc.getWriteBehindFlushSize() == 0 && cc.getWriteBehindFlushFrequency() == 0)     throw new IgniteCheckedException("Cannot set both 'writeBehindFlushFrequency' and " + "'writeBehindFlushSize' parameters to 0 for cache: " + U.maskName(cc.getName()));
  }
  if (cc.isReadThrough() && cfgStore == null)   throw new IgniteCheckedException("Cannot enable read-through (loader or store is not provided) " + "for cache: " + U.maskName(cc.getName()));
  if (cc.isWriteThrough() && cfgStore == null)   throw new IgniteCheckedException("Cannot enable write-through (writer or store is not provided) " + "for cache: " + U.maskName(cc.getName()));
  long delay=cc.getRebalanceDelay();
  if (delay != 0) {
    if (cc.getCacheMode() != PARTITIONED)     U.warn(log,"Rebalance delay is supported only for partitioned caches (will ignore): " + (cc.getName()),"Will ignore rebalance delay for cache: " + U.maskName(cc.getName()));
 else     if (cc.getRebalanceMode() == SYNC) {
      if (delay < 0) {
        U.warn(log,"Ignoring SYNC rebalance mode with manual rebalance start (node will not wait for " + "rebalancing to be finished): " + U.maskName(cc.getName()),"Node will not wait for rebalance in SYNC mode: " + U.maskName(cc.getName()));
      }
 else {
        U.warn(log,"Using SYNC rebalance mode with rebalance delay (node will wait until rebalancing is " + "initiated for " + delay + "ms) for cache: "+ U.maskName(cc.getName()),"Node will wait until rebalancing is initiated for " + delay + "ms for cache: "+ U.maskName(cc.getName()));
      }
    }
  }
  ctx.igfsHelper().validateCacheConfiguration(cc);
switch (cc.getMemoryMode()) {
case OFFHEAP_VALUES:
{
      if (cc.getOffHeapMaxMemory() < 0)       cc.setOffHeapMaxMemory(0);
      break;
    }
case OFFHEAP_TIERED:
{
    if (cc.getOffHeapMaxMemory() < 0)     cc.setOffHeapMaxMemory(0);
    break;
  }
case ONHEAP_TIERED:
if (cacheType.userCache() && cc.getEvictionPolicy() == null && cc.getOffHeapMaxMemory() >= 0) U.quietAndWarn(log,"Eviction policy not enabled with ONHEAP_TIERED mode for cache " + "(entries will not be moved to off-heap store): " + U.maskName(cc.getName()));
break;
default :
throw new IllegalStateException("Unknown memory mode: " + cc.getMemoryMode());
}
if (cc.getMemoryMode() == CacheMemoryMode.OFFHEAP_VALUES) {
if (GridQueryProcessor.isEnabled(cc)) throw new IgniteCheckedException("Cannot have query indexing enabled while values are stored off-heap. " + "You must either disable query indexing or disable off-heap values only flag for cache: " + U.maskName(cc.getName()));
}
if (cc.getAtomicityMode() == ATOMIC) assertParameter(cc.getTransactionManagerLookupClassName() == null,"transaction manager can not be used with ATOMIC cache");
}
