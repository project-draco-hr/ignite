{
  boolean valid=valid(tx != null ? tx.topologyVersion() : cctx.affinity().affinityTopologyVersion());
  if (valBytes != null && val == null && (isNewLocked() || !valid))   val=cctx.marshaller().<V>unmarshal(valBytes,cctx.deploy().globalLoader());
  GridCacheVersion enqueueVer=null;
  try {
synchronized (this) {
      checkObsolete();
      cctx.cache().metrics0().onRead(false);
      boolean ret=false;
      V old=this.val;
      boolean hasVal=hasValueUnlocked();
      if (isNew() || !valid || expVer == null || expVer.equals(this.dhtVer)) {
        this.primaryNodeId=primaryNodeId;
        refreshingLocked(false);
        if (!dhtVer.equals(dhtVersion())) {
          update(val,valBytes,expireTime,ttl,ver);
          if (cctx.deferredDelete()) {
            boolean deleted=val == null && valBytes == null;
            if (deleted != deletedUnlocked()) {
              deletedUnlocked(deleted);
              if (deleted)               enqueueVer=ver;
            }
          }
          recordDhtVersion(dhtVer);
          ret=true;
        }
      }
      if (evt && cctx.events().isRecordable(EVT_CACHE_OBJECT_READ))       cctx.events().addEvent(partition(),key,tx,null,EVT_CACHE_OBJECT_READ,val,val != null || valBytes != null,old,hasVal,null);
      return ret;
    }
  }
  finally {
    if (enqueueVer != null)     cctx.onDeferredDelete(this,enqueueVer);
  }
}
