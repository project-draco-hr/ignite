{
  final AtomicInteger tidGen=new AtomicInteger();
  final Random rand=new Random();
  final int cnt=100 * 1024;
  multithreaded(new Callable<Object>(){
    @SuppressWarnings("UnusedAssignment") @Override public Object call() throws Exception {
      IgniteCache<Integer,String> c=grid().jcache(null);
      int tid=tidGen.getAndIncrement();
      int start=2 * 1024 * tid;
      Iterator<Cache.Entry<Integer,String>> it=null;
      boolean created=false;
      for (int i=start; i < start + cnt; i++) {
        int key=i % cnt;
        if (!created && i >= start + tid * 100) {
          if (it == null)           it=c.iterator();
          created=true;
        }
        c.put(key,Integer.toString(key));
        c.get(rand.nextInt(cnt));
      }
      while (it.hasNext())       it.next();
      it=null;
      for (int i=start; i < start + cnt; i++) {
        int key=i % cnt;
        assertEquals(Integer.toString(key),c.get(key));
      }
      assertEquals(cnt,c.size());
      int idx=0;
      for (      Cache.Entry<Integer,String> e : c) {
        assertNotNull(e.getValue());
        idx++;
      }
      assertEquals(cnt,idx);
      System.gc();
      return null;
    }
  }
,10);
  jcache().get(rand.nextInt(cnt));
  System.gc();
  Thread.sleep(1000);
  jcache().get(rand.nextInt(cnt));
  assertEquals(0,local().map.iteratorMapSize());
}
