{
  boolean isNew=true;
  boolean poll=false;
  int size=0;
  int relSize=0;
  long relAddr=0;
  try {
    long first=mem.readLong(binAddr);
    long qAddr=0;
    if (first != 0) {
      long prev=0;
      long cur=first;
      while (true) {
        long next=Entry.nextAddress(cur,mem);
        if (Entry.keyEquals(cur,keyBytes,mem)) {
          if (prev != 0)           Entry.nextAddress(prev,next,mem);
 else           first=next;
          qAddr=Entry.queueAddress(cur,mem);
          relSize=Entry.size(cur,mem);
          relAddr=cur;
          isNew=false;
          break;
        }
        prev=cur;
        cur=next;
        if (next == 0)         break;
      }
    }
    size=Entry.HEADER + keyBytes.length + valBytes.length;
    poll=!mem.reserve(size);
    long addr=mem.allocate(size,false,true);
    mem.writeLong(binAddr,addr);
    if (isNew)     qAddr=lru.offer(0,addr,1);
    lru.touch(qAddr,addr);
    Entry.write(addr,1,keyBytes,valBytes,qAddr,first,mem);
    return isNew;
  }
  finally {
    if (relAddr != 0)     mem.release(relAddr,relSize);
    if (poll)     lruPoller.lruPoll(size);
  }
}
