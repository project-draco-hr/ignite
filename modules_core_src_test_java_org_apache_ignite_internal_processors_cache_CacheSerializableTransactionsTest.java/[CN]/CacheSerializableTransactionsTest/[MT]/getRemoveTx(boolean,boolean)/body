{
  final Ignite ignite0=ignite(0);
  CacheConfiguration<Integer,Integer> ccfg=cacheConfiguration(PARTITIONED,FULL_SYNC,0,store,false);
  final List<Ignite> clients=clients();
  final String cacheName=ignite0.createCache(ccfg).getName();
  try {
    final List<IgniteCache<Integer,Integer>> caches=new ArrayList<>();
    for (    Ignite client : clients) {
      if (nearCache)       caches.add(client.createNearCache(cacheName,new NearCacheConfiguration<Integer,Integer>()));
 else       caches.add(client.<Integer,Integer>cache(cacheName));
    }
    for (int i=0; i < 100; i++) {
      final AtomicInteger cntr=new AtomicInteger();
      final Integer key=i;
      final AtomicInteger threadIdx=new AtomicInteger();
      final int THREADS=10;
      final CyclicBarrier barrier=new CyclicBarrier(THREADS);
      final IgniteInternalFuture<?> updateFut=GridTestUtils.runMultiThreadedAsync(new Callable<Void>(){
        @Override public Void call() throws Exception {
          int thread=threadIdx.getAndIncrement();
          int idx=thread % caches.size();
          IgniteCache<Integer,Integer> cache=caches.get(idx);
          Ignite ignite=cache.unwrap(Ignite.class);
          IgniteTransactions txs=ignite.transactions();
          log.info("Started update thread: " + ignite.name());
          Thread.currentThread().setName("update-thread-" + ignite.name() + "-"+ thread);
          barrier.await();
          for (int i=0; i < 50; i++) {
            while (true) {
              try {
                ThreadLocalRandom rnd=ThreadLocalRandom.current();
                boolean rmv=rnd.nextInt(3) == 0;
                Integer val;
                try (Transaction tx=txs.txStart(OPTIMISTIC,SERIALIZABLE)){
                  val=cache.get(key);
                  if (rmv)                   cache.remove(key);
 else                   cache.put(key,val == null ? 1 : val + 1);
                  tx.commit();
                  if (rmv) {
                    if (val != null) {
                      for (int j=0; j < val; j++)                       cntr.decrementAndGet();
                    }
                  }
 else                   cntr.incrementAndGet();
                }
                 break;
              }
 catch (              TransactionOptimisticException ignore) {
              }
            }
          }
          return null;
        }
      }
,THREADS,"update-thread");
      updateFut.get();
      Integer val=cntr.get();
      log.info("Iteration [iter=" + i + ", val="+ val+ ']');
      checkValue(key,val == 0 ? null : val,cacheName);
    }
  }
  finally {
    destroyCache(cacheName);
  }
}
