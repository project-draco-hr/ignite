{
  final Ignite srv=ignite(1);
  CacheConfiguration<Integer,Integer> ccfg=cacheConfiguration(PARTITIONED,FULL_SYNC,1,store,false);
  final List<Ignite> clients=clients();
  final String cacheName=srv.createCache(ccfg).getName();
  final AtomicBoolean stop=new AtomicBoolean();
  try {
    final List<IgniteCache<Integer,Integer>> caches=new ArrayList<>();
    for (    Ignite client : clients) {
      if (nearCache)       caches.add(client.createNearCache(cacheName,new NearCacheConfiguration<Integer,Integer>()));
 else       caches.add(client.<Integer,Integer>cache(cacheName));
    }
    IgniteInternalFuture<?> restartFut=null;
    if (restart) {
      restartFut=GridTestUtils.runAsync(new Callable<Object>(){
        @Override public Object call() throws Exception {
          while (!stop.get()) {
            stopGrid(0);
            U.sleep(300);
            Ignite ignite=startGrid(0);
            assertFalse(ignite.configuration().isClientMode());
          }
          return null;
        }
      }
);
    }
    for (int i=0; i < 30; i++) {
      final AtomicInteger cntr=new AtomicInteger();
      final Integer key=i;
      final AtomicInteger threadIdx=new AtomicInteger();
      final int THREADS=10;
      final CyclicBarrier barrier=new CyclicBarrier(THREADS);
      GridTestUtils.runMultiThreadedAsync(new Callable<Void>(){
        @Override public Void call() throws Exception {
          int idx=threadIdx.getAndIncrement() % caches.size();
          IgniteCache<Integer,Integer> cache=caches.get(idx);
          Ignite ignite=cache.unwrap(Ignite.class);
          IgniteTransactions txs=ignite.transactions();
          log.info("Started update thread: " + ignite.name());
          barrier.await();
          for (int i=0; i < 1000; i++) {
            try {
              try (Transaction tx=txs.txStart(OPTIMISTIC,SERIALIZABLE)){
                Integer val=cache.get(key);
                cache.put(key,val == null ? 1 : val + 1);
                tx.commit();
              }
               cntr.incrementAndGet();
            }
 catch (            TransactionOptimisticException ignore) {
            }
catch (            IgniteException|CacheException e) {
              assertTrue("Unexpected exception [err=" + e + ", cause="+ e.getCause()+ ']',restart && X.hasCause(e,ClusterTopologyCheckedException.class));
            }
          }
          return null;
        }
      }
,THREADS,"update-thread").get();
      log.info("Iteration [iter=" + i + ", val="+ cntr.get()+ ']');
      assertTrue(cntr.get() > 0);
      checkValue(key,cntr.get(),cacheName,restart);
    }
    stop.set(true);
    if (restartFut != null)     restartFut.get();
  }
  finally {
    stop.set(true);
    destroyCache(srv,cacheName);
  }
}
