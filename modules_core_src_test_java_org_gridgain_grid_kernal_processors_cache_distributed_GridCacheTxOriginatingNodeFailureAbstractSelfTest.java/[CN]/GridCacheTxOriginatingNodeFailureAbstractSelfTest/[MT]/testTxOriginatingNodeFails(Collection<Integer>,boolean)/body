{
  assertFalse(keys.isEmpty());
  final Collection<GridKernal> grids=new ArrayList<>();
  GridNode txNode=grid(originatingNode()).localNode();
  for (int i=1; i < gridCount(); i++)   grids.add((GridKernal)grid(i));
  final Map<Integer,String> map=new HashMap<>();
  final String initVal="initialValue";
  for (  Integer key : keys) {
    grid(originatingNode()).cache(null).put(key,initVal);
    map.put(key,String.valueOf(key));
  }
  Map<Integer,Collection<GridNode>> nodeMap=new HashMap<>();
  GridCacheAdapter<Integer,String> cache=((GridKernal)grid(1)).internalCache();
  info("Node being checked: " + grid(1).localNode().id());
  for (  Integer key : keys) {
    Collection<GridNode> nodes=new ArrayList<>();
    nodes.addAll(cache.affinity().mapKeyToPrimaryAndBackups(key));
    nodes.remove(txNode);
    nodeMap.put(key,nodes);
  }
  info("Starting tx [values=" + map + ", topVer="+ ((GridKernal)grid(1)).context().discovery().topologyVersion()+ ']');
  if (partial)   ignoreMessages(grid(1).localNode().id(),ignoreMessageClass());
  final Grid txGridNode=G.grid(txNode.id());
  GridTestUtils.runAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      GridCache<Integer,String> cache=txGridNode.cache(null);
      assertNotNull(cache);
      GridCacheTxProxyImpl tx=(GridCacheTxProxyImpl)cache.txStart();
      GridCacheTxEx txEx=GridTestUtils.getFieldValue(tx,"tx");
      cache.putAll(map);
      try {
        txEx.prepareAsync().get(3,TimeUnit.SECONDS);
      }
 catch (      GridFutureTimeoutException ignored) {
        info("Failed to wait for prepare future completion: " + partial);
      }
      return null;
    }
  }
).get();
  info("Stopping originating node " + txNode);
  G.stop(G.grid(txNode.id()).name(),true);
  info("Stopped grid, waiting for transactions to complete.");
  boolean txFinished=GridTestUtils.waitForCondition(new GridAbsPredicate(){
    @Override public boolean apply(){
      for (      GridKernal g : grids) {
        GridCacheAdapter<?,?> cache=g.internalCache();
        int txNum=cache.isNear() ? ((GridNearCacheAdapter)cache).dht().context().tm().idMapSize() : cache.context().tm().idMapSize();
        if (txNum != 0)         return false;
      }
      return true;
    }
  }
,10000);
  assertTrue(txFinished);
  info("Transactions finished.");
  for (  Map.Entry<Integer,Collection<GridNode>> e : nodeMap.entrySet()) {
    final Integer key=e.getKey();
    final String val=map.get(key);
    assertFalse(e.getValue().isEmpty());
    for (    GridNode node : e.getValue()) {
      compute(G.grid(node.id()).cluster().forNode(node)).call(new Callable<Void>(){
        /** 
 */
        @GridInstanceResource private Grid grid;
        @Override public Void call() throws Exception {
          GridCache<Integer,String> cache=grid.cache(null);
          assertNotNull(cache);
          assertEquals(partial ? initVal : val,cache.peek(key));
          return null;
        }
      }
);
    }
  }
  for (  Map.Entry<Integer,String> e : map.entrySet()) {
    for (    Grid g : G.allGrids()) {
      UUID locNodeId=g.cluster().localNode().id();
      assertEquals("Check failed for node: " + locNodeId,partial ? initVal : e.getValue(),g.cache(null).get(e.getKey()));
    }
  }
}
