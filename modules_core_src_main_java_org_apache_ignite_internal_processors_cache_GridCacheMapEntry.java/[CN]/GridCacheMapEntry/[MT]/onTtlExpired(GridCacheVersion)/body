{
  boolean obsolete=false;
  boolean deferred=false;
  try {
synchronized (this) {
      V expiredVal=val;
      boolean hasOldBytes=valBytes != null || valPtr != 0;
      boolean expired=checkExpired();
      if (expired) {
        if (cctx.deferredDelete() && !detached() && !isInternal()) {
          if (!deletedUnlocked()) {
            update(null,null,0L,0L,ver);
            deletedUnlocked(true);
            deferred=true;
          }
        }
 else {
          if (markObsolete0(obsoleteVer,true))           obsolete=true;
        }
        if (cctx.events().isRecordable(EVT_CACHE_OBJECT_EXPIRED)) {
          cctx.events().addEvent(partition(),key,cctx.localNodeId(),null,EVT_CACHE_OBJECT_EXPIRED,null,false,expiredVal,expiredVal != null || hasOldBytes,null,null,null);
        }
        cctx.continuousQueries().onEntryExpired(this,key,expiredVal,null);
      }
    }
  }
 catch (  IgniteCheckedException e) {
    U.error(log,"Failed to clean up expired cache entry: " + this,e);
  }
 finally {
    if (obsolete)     onMarkedObsolete();
    if (deferred)     cctx.onDeferredDelete(this,obsoleteVer);
  }
  return obsolete;
}
