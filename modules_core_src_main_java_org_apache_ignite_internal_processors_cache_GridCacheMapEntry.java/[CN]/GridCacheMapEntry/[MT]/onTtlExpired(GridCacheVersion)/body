{
  boolean obsolete=false;
  boolean deferred=false;
  try {
synchronized (this) {
      CacheObject expiredVal=saveValueForIndexUnlocked();
      boolean hasOldBytes=valPtr != 0;
      boolean expired=checkExpired();
      if (expired) {
        if (!obsolete()) {
          if (cctx.deferredDelete() && !detached() && !isInternal()) {
            if (!deletedUnlocked()) {
              update(null,0L,0L,obsoleteVer);
              deletedUnlocked(true);
              deferred=true;
            }
          }
 else {
            if (markObsolete0(obsoleteVer,true))             obsolete=true;
          }
        }
        clearIndex(expiredVal);
        releaseSwap();
        if (cctx.events().isRecordable(EVT_CACHE_OBJECT_EXPIRED)) {
          cctx.events().addEvent(partition(),key,cctx.localNodeId(),null,EVT_CACHE_OBJECT_EXPIRED,null,false,expiredVal,expiredVal != null || hasOldBytes,null,null,null);
        }
        cctx.continuousQueries().onEntryExpired(this,key,expiredVal);
      }
    }
  }
 catch (  IgniteCheckedException e) {
    U.error(log,"Failed to clean up expired cache entry: " + this,e);
  }
 finally {
    if (obsolete) {
      onMarkedObsolete();
      cctx.cache().removeEntry(this);
    }
    if (deferred)     cctx.onDeferredDelete(this,obsoleteVer);
    if ((obsolete || deferred) && cctx.cache().configuration().isStatisticsEnabled())     cctx.cache().metrics0().onEvict();
  }
  return obsolete;
}
