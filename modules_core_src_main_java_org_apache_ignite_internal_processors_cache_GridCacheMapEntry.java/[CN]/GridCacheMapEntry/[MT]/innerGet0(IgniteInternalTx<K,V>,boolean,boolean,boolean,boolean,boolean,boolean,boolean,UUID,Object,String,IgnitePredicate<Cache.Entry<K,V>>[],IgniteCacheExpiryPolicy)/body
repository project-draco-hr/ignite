{
  if (readThrough && !cctx.readThrough())   readThrough=false;
  GridCacheMvccCandidate<K> owner;
  V old;
  V ret=null;
  if (!F.isEmptyOrNulls(filter) && !cctx.isAll((new CacheEntryImpl<>(key,rawGetOrUnmarshal(true))),filter))   return CU.<V>failed(failFast);
  GridCacheVersion startVer;
  boolean expired=false;
  V expiredVal=null;
  boolean hasOldBytes;
synchronized (this) {
    checkObsolete();
    startVer=ver;
    GridCacheMvcc<K> mvcc=mvccExtras();
    owner=mvcc == null ? null : mvcc.anyOwner();
    double delta;
    long expireTime=expireTimeExtras();
    if (expireTime > 0) {
      delta=expireTime - U.currentTimeMillis();
      if (log.isDebugEnabled())       log.debug("Checked expiration time for entry [timeLeft=" + delta + ", entry="+ this+ ']');
      if (delta <= 0)       expired=true;
    }
    V val=this.val;
    hasOldBytes=valBytes != null || valPtr != 0;
    if ((unmarshal || isOffHeapValuesOnly()) && !expired && val == null && hasOldBytes)     val=rawGetOrUnmarshalUnlocked(tmp);
    boolean valid=valid(tx != null ? tx.topologyVersion() : cctx.affinity().affinityTopologyVersion());
    if (val == null && !hasOldBytes && readSwap) {
      if (isNew() || !valid) {
        if (expired) {
          releaseSwap();
          clearIndex(null);
        }
 else {
          if (tmp) {
            unswap(false,false);
            val=rawGetOrUnmarshalUnlocked(true);
          }
 else           val=unswap();
          if (expireTime > 0) {
            delta=expireTime - U.currentTimeMillis();
            if (log.isDebugEnabled())             log.debug("Checked expiration time for entry [timeLeft=" + delta + ", entry="+ this+ ']');
            if (delta <= 0)             expired=true;
          }
        }
      }
    }
    old=expired || !valid ? null : val;
    if (expired) {
      expiredVal=val;
      value(null,null);
    }
    if (old == null && !hasOldBytes) {
      if (updateMetrics && cctx.cache().configuration().isStatisticsEnabled())       cctx.cache().metrics0().onRead(false);
    }
 else {
      if (updateMetrics && cctx.cache().configuration().isStatisticsEnabled())       cctx.cache().metrics0().onRead(true);
      ret=old;
    }
    if (evt && expired) {
      if (cctx.events().isRecordable(EVT_CACHE_OBJECT_EXPIRED)) {
        cctx.events().addEvent(partition(),key,tx,owner,EVT_CACHE_OBJECT_EXPIRED,null,false,expiredVal,expiredVal != null || hasOldBytes,subjId,null,taskName);
      }
      cctx.continuousQueries().onEntryExpired(this,key,expiredVal,null);
      evt=false;
    }
    if (evt && !expired && cctx.events().isRecordable(EVT_CACHE_OBJECT_READ)) {
      cctx.events().addEvent(partition(),key,tx,owner,EVT_CACHE_OBJECT_READ,ret,ret != null,old,hasOldBytes || old != null,subjId,transformClo != null ? transformClo.getClass().getName() : null,taskName);
      evt=false;
    }
    if (ret != null && expiryPlc != null) {
      long ttl=expiryPlc.forAccess();
      if (ttl != CU.TTL_NOT_CHANGED) {
        updateTtl(ttl);
        expiryPlc.ttlUpdated(key(),getOrMarshalKeyBytes(),version(),hasReaders() ? ((GridDhtCacheEntry)this).readers() : null);
      }
    }
  }
  if (!cctx.isAll(this,filter))   return CU.<V>failed(failFast,ret);
  if (ret != null) {
    if (F.isEmptyOrNulls(filter) || version().equals(startVer))     return ret;
    return innerGet0(tx,readSwap,readThrough,false,failFast,unmarshal,updateMetrics,tmp,subjId,transformClo,taskName,filter,expiryPlc);
  }
  boolean loadedFromStore=false;
  if (ret == null && readThrough) {
    IgniteInternalTx tx0=null;
    if (tx != null && tx.local()) {
      if (cctx.isReplicated() || cctx.isColocated() || tx.near())       tx0=tx;
 else       if (tx.dht()) {
        GridCacheVersion ver=((GridDhtTxLocalAdapter)tx).nearXidVersion();
        tx0=cctx.dht().near().context().tm().tx(ver);
      }
    }
    ret=readThrough(tx0,key,false,filter,subjId,taskName);
    loadedFromStore=true;
  }
  boolean match=false;
synchronized (this) {
    long ttl=ttlExtras();
    if (startVer.equals(ver)) {
      match=true;
      if (ret != null) {
        if (cctx.portableEnabled())         ret=(V)cctx.kernalContext().portable().detachPortable(ret);
        GridCacheVersion nextVer=nextVersion();
        V prevVal=rawGetOrUnmarshalUnlocked(false);
        long expTime=toExpireTime(ttl);
        if (loadedFromStore)         updateIndex(ret,null,expTime,nextVer,prevVal);
        boolean hadValPtr=valPtr != 0;
        update(ret,null,expTime,ttl,nextVer);
        if (hadValPtr && cctx.offheapTiered())         cctx.swap().removeOffheap(key,getOrMarshalKeyBytes());
        if (cctx.deferredDelete() && deletedUnlocked() && !isInternal()&& !detached())         deletedUnlocked(false);
      }
      if (evt && cctx.events().isRecordable(EVT_CACHE_OBJECT_READ))       cctx.events().addEvent(partition(),key,tx,owner,EVT_CACHE_OBJECT_READ,ret,ret != null,old,hasOldBytes,subjId,transformClo != null ? transformClo.getClass().getName() : null,taskName);
    }
  }
  if (F.isEmptyOrNulls(filter) || match)   return ret;
  return innerGet0(tx,readSwap,readThrough,false,failFast,unmarshal,updateMetrics,tmp,subjId,transformClo,taskName,filter,expiryPlc);
}
