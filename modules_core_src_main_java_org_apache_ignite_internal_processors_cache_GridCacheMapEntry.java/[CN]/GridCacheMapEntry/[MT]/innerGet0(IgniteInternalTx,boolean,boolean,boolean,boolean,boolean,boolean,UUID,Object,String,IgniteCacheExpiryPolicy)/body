{
  if (readThrough && !cctx.readThrough())   readThrough=false;
  GridCacheMvccCandidate owner;
  CacheObject old;
  CacheObject ret=null;
  GridCacheVersion startVer;
  boolean expired=false;
  CacheObject expiredVal=null;
  boolean hasOldBytes;
synchronized (this) {
    checkObsolete();
    startVer=ver;
    GridCacheMvcc mvcc=mvccExtras();
    owner=mvcc == null ? null : mvcc.anyOwner();
    double delta;
    long expireTime=expireTimeExtras();
    if (expireTime > 0) {
      delta=expireTime - U.currentTimeMillis();
      if (log.isDebugEnabled())       log.debug("Checked expiration time for entry [timeLeft=" + delta + ", entry="+ this+ ']');
      if (delta <= 0)       expired=true;
    }
    CacheObject val=this.val;
    hasOldBytes=valPtr != 0;
    if ((unmarshal || isOffHeapValuesOnly()) && !expired && val == null && hasOldBytes)     val=rawGetOrUnmarshalUnlocked(tmp);
    boolean valid=valid(tx != null ? tx.topologyVersion() : cctx.affinity().affinityTopologyVersion());
    if (val == null && !hasOldBytes && readSwap) {
      if (isNew() || !valid) {
        if (expired) {
          releaseSwap();
          clearIndex(null);
        }
 else {
          if (tmp) {
            unswap(false);
            val=rawGetOrUnmarshalUnlocked(true);
          }
 else           val=unswap();
          if (expireTime > 0) {
            delta=expireTime - U.currentTimeMillis();
            if (log.isDebugEnabled())             log.debug("Checked expiration time for entry [timeLeft=" + delta + ", entry="+ this+ ']');
            if (delta <= 0)             expired=true;
          }
        }
      }
    }
    old=expired || !valid ? null : val;
    if (expired) {
      expiredVal=val;
      value(null);
    }
    if (old == null && !hasOldBytes) {
      if (updateMetrics && cctx.cache().configuration().isStatisticsEnabled())       cctx.cache().metrics0().onRead(false);
    }
 else {
      if (updateMetrics && cctx.cache().configuration().isStatisticsEnabled())       cctx.cache().metrics0().onRead(true);
      ret=old;
    }
    if (evt && expired) {
      if (cctx.events().isRecordable(EVT_CACHE_OBJECT_EXPIRED)) {
        cctx.events().addEvent(partition(),key,tx,owner,EVT_CACHE_OBJECT_EXPIRED,null,false,expiredVal,expiredVal != null || hasOldBytes,subjId,null,taskName);
      }
      cctx.continuousQueries().onEntryExpired(this,key,expiredVal);
      evt=false;
    }
    if (evt && !expired && cctx.events().isRecordable(EVT_CACHE_OBJECT_READ)) {
      cctx.events().addEvent(partition(),key,tx,owner,EVT_CACHE_OBJECT_READ,ret,ret != null,old,hasOldBytes || old != null,subjId,transformClo != null ? transformClo.getClass().getName() : null,taskName);
      evt=false;
    }
    if (ret != null && expiryPlc != null)     updateTtl(expiryPlc);
  }
  if (ret != null)   return ret;
  boolean loadedFromStore=false;
  if (ret == null && readThrough) {
    IgniteInternalTx tx0=null;
    if (tx != null && tx.local()) {
      if (cctx.isReplicated() || cctx.isColocated() || tx.near())       tx0=tx;
 else       if (tx.dht()) {
        GridCacheVersion ver=tx.nearXidVersion();
        tx0=cctx.dht().near().context().tm().tx(ver);
      }
    }
    Object storeVal=readThrough(tx0,key,false,subjId,taskName);
    ret=cctx.toCacheObject(storeVal);
    loadedFromStore=true;
  }
synchronized (this) {
    long ttl=ttlExtras();
    if (startVer.equals(ver)) {
      if (ret != null) {
        ret=cctx.kernalContext().cacheObjects().prepareForCache(ret,cctx);
        GridCacheVersion nextVer=nextVersion();
        CacheObject prevVal=rawGetOrUnmarshalUnlocked(false);
        long expTime=CU.toExpireTime(ttl);
        if (loadedFromStore)         updateIndex(ret,expTime,nextVer,prevVal);
        boolean hadValPtr=valPtr != 0;
        update(ret,expTime,ttl,nextVer);
        if (hadValPtr && cctx.offheapTiered())         cctx.swap().removeOffheap(key);
        if (cctx.deferredDelete() && deletedUnlocked() && !isInternal()&& !detached())         deletedUnlocked(false);
      }
      if (evt && cctx.events().isRecordable(EVT_CACHE_OBJECT_READ))       cctx.events().addEvent(partition(),key,tx,owner,EVT_CACHE_OBJECT_READ,ret,ret != null,old,hasOldBytes,subjId,transformClo != null ? transformClo.getClass().getName() : null,taskName);
    }
  }
  return ret;
}
