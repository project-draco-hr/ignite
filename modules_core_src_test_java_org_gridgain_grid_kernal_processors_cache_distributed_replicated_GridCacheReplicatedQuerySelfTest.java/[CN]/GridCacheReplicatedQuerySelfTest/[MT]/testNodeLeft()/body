{
  try {
    Grid g=startGrid();
    GridCache<Integer,Integer> cache=g.cache(null);
    for (int i=0; i < 1000; i++)     assertTrue(cache.putx(i,i));
    GridCacheQuery<Map.Entry<Integer,Integer>> q=cache.queries().createSqlQuery(Integer.class,"_key >= 0 order by _key").projection(grid);
    q.pageSize(50);
    q.projection(g.forNodes(Arrays.asList(g.localNode(),grid(0).localNode())));
    GridCacheQueryFuture<Map.Entry<Integer,Integer>> fut=q.execute();
    assertEquals(0,(int)fut.next().getKey());
    final ConcurrentMap<UUID,Map<Long,GridFutureAdapter<GridCloseableIterator<GridIndexingKeyValueRow<Integer,Integer>>>>> map=U.field(((GridKernal)grid(0)).internalCache().context().queries(),"qryIters");
    assertTrue(GridTestUtils.waitForCondition(new PA(){
      @Override public boolean apply(){
        return map.size() == 1;
      }
    }
,getTestTimeout()));
    Map<Long,GridFutureAdapter<GridCloseableIterator<GridIndexingKeyValueRow<Integer,Integer>>>> futs=map.get(g.localNode().id());
    assertEquals(1,futs.size());
    GridCloseableIterator<GridIndexingKeyValueRow<Integer,Integer>> iter=F.first(futs.values()).get();
    assertFalse(iter.isClosed());
    final UUID nodeId=g.localNode().id();
    final CountDownLatch latch=new CountDownLatch(1);
    grid(0).events().localListen(new GridPredicate<GridEvent>(){
      @Override public boolean apply(      GridEvent evt){
        if (((GridDiscoveryEvent)evt).eventNode().id().equals(nodeId))         latch.countDown();
        return true;
      }
    }
,EVT_NODE_LEFT);
    stopGrid();
    latch.await();
    assertEquals(0,map.size());
    assertTrue(iter.isClosed());
  }
  finally {
    stopGrid();
  }
}
