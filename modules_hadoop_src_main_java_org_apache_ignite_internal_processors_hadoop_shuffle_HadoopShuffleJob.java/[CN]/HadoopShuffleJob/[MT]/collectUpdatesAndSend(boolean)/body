{
  for (int i=0; i < maps.length(); i++) {
    HadoopMultimap map=maps.get(i);
    if (map == null || locReduceAddr.equals(reduceAddrs[i]))     continue;
    if (msgs[i] == null)     msgs[i]=new HadoopShuffleMessage(job.id(),i,MSG_BUF_SIZE);
    final int idx=i;
    map.visit(false,new HadoopMultimap.Visitor(){
      /** 
 */
      private long keyPtr;
      /** 
 */
      private int keySize;
      /** 
 */
      private boolean keyAdded;
      /** 
 * {@inheritDoc} 
 */
      @Override public void onKey(      long keyPtr,      int keySize){
        this.keyPtr=keyPtr;
        this.keySize=keySize;
        keyAdded=false;
      }
      private boolean tryAdd(      long valPtr,      int valSize){
        HadoopShuffleMessage msg=msgs[idx];
        if (!keyAdded) {
          int size=keySize + valSize;
          if (!msg.available(size,false))           return false;
          msg.addKey(keyPtr,keySize);
          msg.addValue(valPtr,valSize);
          keyAdded=true;
          return true;
        }
        if (!msg.available(valSize,true))         return false;
        msg.addValue(valPtr,valSize);
        return true;
      }
      /** 
 * {@inheritDoc} 
 */
      @Override public void onValue(      long valPtr,      int valSize){
        if (tryAdd(valPtr,valSize))         return;
        send(idx,keySize + valSize);
        keyAdded=false;
        if (!tryAdd(valPtr,valSize))         throw new IllegalStateException();
      }
    }
);
    if (flush && msgs[i].offset() != 0)     send(i,0);
  }
}
