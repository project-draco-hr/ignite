{
  if (log.isDebugEnabled())   log.debug("Flushing job " + job.id() + " on address "+ locReduceAddr);
  flushed=true;
  if (maps.length() == 0)   return new GridFinishedFuture<>();
  U.await(ioInitLatch);
  GridWorker snd0=snd;
  if (snd0 != null) {
    if (log.isDebugEnabled())     log.debug("Cancelling sender thread.");
    snd0.cancel();
    try {
      snd0.join();
      if (log.isDebugEnabled())       log.debug("Finished waiting for sending thread to complete on shuffle job flush: " + job.id());
    }
 catch (    InterruptedException e) {
      throw new IgniteInterruptedCheckedException(e);
    }
  }
  collectUpdatesAndSend(true);
  if (log.isDebugEnabled())   log.debug("Finished sending collected updates to remote reducers: " + job.id());
  GridCompoundFuture fut=new GridCompoundFuture<>();
  for (  IgniteBiTuple<HadoopShuffleMessage,GridFutureAdapter<?>> tup : sentMsgs.values())   fut.add(tup.get2());
  fut.markInitialized();
  if (log.isDebugEnabled())   log.debug("Collected futures to compound futures for flush: " + sentMsgs.size());
  return fut;
}
