{
  info("Test timeout: " + (getTestTimeout() / (60 * 1000)) + " min.");
  startGridsMultiThreaded(GRID_CNT);
  clientFlagGlobal=true;
  for (int i=GRID_CNT; i < GRID_CNT + CLIENT_GRID_CNT; i++)   startGrid(i);
  final AtomicBoolean done=new AtomicBoolean();
  final AtomicBoolean done0=new AtomicBoolean();
  final AtomicInteger idx=new AtomicInteger();
  final List<Integer> idxs=new ArrayList<>();
  for (int i=GRID_CNT; i < GRID_CNT + CLIENT_GRID_CNT; i++)   idxs.add(i);
  final CyclicBarrier barrier=new CyclicBarrier(THREAD_CNT,new Runnable(){
    @Override public void run(){
      if (done0.get())       done.set(true);
      Collections.shuffle(idxs);
      idx.set(GRID_CNT);
    }
  }
);
  GridFuture<?> fut=multithreadedAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      while (true) {
        barrier.await();
        if (done.get())         break;
        int i=idxs.get(idx.getAndIncrement());
        stopGrid(i);
        clientFlagPerThread.set(i >= GRID_CNT);
        startGrid(i);
      }
      info("Thread finished.");
      return null;
    }
  }
,THREAD_CNT);
  Thread.sleep(getTestTimeout() - 60 * 1000);
  done0.set(true);
  fut.get();
}
