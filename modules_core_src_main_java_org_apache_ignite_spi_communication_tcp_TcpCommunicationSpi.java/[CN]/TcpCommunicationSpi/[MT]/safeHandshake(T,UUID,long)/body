{
  HandshakeTimeoutObject<T> obj=new HandshakeTimeoutObject<>(client,U.currentTimeMillis() + timeout);
  sockTimeoutWorker.addTimeoutObject(obj);
  try {
    if (client instanceof GridCommunicationClient)     ((GridCommunicationClient)client).doHandshake(new HandshakeClosure(rmtNodeId));
 else {
      SocketChannel ch=(SocketChannel)client;
      boolean success=false;
      try {
        ByteBuffer buf=ByteBuffer.allocate(17);
        for (int i=0; i < 17; ) {
          int read=ch.read(buf);
          if (read == -1)           throw new IgniteCheckedException("Failed to read remote node ID (connection closed).");
          i+=read;
        }
        UUID rmtNodeId0=U.bytesToUuid(buf.array(),1);
        if (!rmtNodeId.equals(rmtNodeId0))         throw new IgniteCheckedException("Remote node ID is not as expected [expected=" + rmtNodeId + ", rcvd="+ rmtNodeId0+ ']');
 else         if (log.isDebugEnabled())         log.debug("Received remote node ID: " + rmtNodeId0);
        ch.write(ByteBuffer.wrap(U.GG_HEADER));
        ch.write(ByteBuffer.wrap(nodeIdMsg.nodeIdBytesWithType));
        success=true;
      }
 catch (      IOException e) {
        if (log.isDebugEnabled())         log.debug("Failed to read from channel: " + e);
        throw new IgniteCheckedException("Failed to read from channel.",e);
      }
 finally {
        if (!success)         U.closeQuiet(ch);
      }
    }
  }
  finally {
    boolean cancelled=obj.cancel();
    if (cancelled)     sockTimeoutWorker.removeTimeoutObject(obj);
    if (!cancelled)     throw new HandshakeTimeoutException("Failed to perform handshake due to timeout (consider increasing " + "'connectionTimeout' configuration property).");
  }
}
