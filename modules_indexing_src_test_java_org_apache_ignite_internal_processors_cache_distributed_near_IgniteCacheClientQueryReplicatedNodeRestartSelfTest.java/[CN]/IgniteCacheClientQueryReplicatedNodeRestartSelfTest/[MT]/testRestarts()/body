{
  int duration=90 * 1000;
  int qryThreadNum=5;
  int restartThreadsNum=2;
  final int nodeLifeTime=2 * 1000;
  final int logFreq=10;
  startGridsMultiThreaded(GRID_CNT);
  final AtomicIntegerArray locks=new AtomicIntegerArray(GRID_CNT - 1);
  fillCaches();
  final List<List<?>> pRes=grid(0).cache("pu").query(new SqlFieldsQuery(QRY)).getAll();
  Thread.sleep(3000);
  assertEquals(pRes,grid(0).cache("pu").query(new SqlFieldsQuery(QRY)).getAll());
  assertFalse(pRes.isEmpty());
  final AtomicInteger qryCnt=new AtomicInteger();
  final AtomicBoolean qrysDone=new AtomicBoolean();
  final List<Integer> cacheSize=new ArrayList<>(4);
  for (int i=0; i < GRID_CNT - 1; i++) {
    int j=0;
    for (    String cacheName : F.asList("co","pr","pe","pu")) {
      IgniteCache<?,?> cache=grid(i).cache(cacheName);
      assertClient(cache,false);
      if (i == 0)       cacheSize.add(cache.size());
 else       assertEquals(cacheSize.get(j++).intValue(),cache.size());
    }
  }
  int j=0;
  for (  String cacheName : F.asList("co","pr","pe","pu")) {
    IgniteCache<?,?> cache=grid(GRID_CNT - 1).cache(cacheName);
    assertClient(cache,true);
    assertEquals(cacheSize.get(j++).intValue(),cache.size());
  }
  final IgniteCache<?,?> clientCache=grid(GRID_CNT - 1).cache("pu");
  IgniteInternalFuture<?> fut1=multithreadedAsync(new CAX(){
    @Override public void applyx() throws IgniteCheckedException {
      GridRandom rnd=new GridRandom();
      while (!qrysDone.get()) {
        SqlFieldsQuery qry=new SqlFieldsQuery(QRY);
        boolean smallPageSize=rnd.nextBoolean();
        if (smallPageSize)         qry.setPageSize(3);
        List<List<?>> res;
        try {
          res=clientCache.query(qry).getAll();
        }
 catch (        CacheException e) {
          assertTrue("On large page size must retry.",smallPageSize);
          boolean failedOnRemoteFetch=false;
          for (Throwable th=e; th != null; th=th.getCause()) {
            if (!(th instanceof CacheException))             continue;
            if (th.getMessage() != null && th.getMessage().startsWith("Failed to fetch data from node:")) {
              failedOnRemoteFetch=true;
              break;
            }
          }
          if (!failedOnRemoteFetch) {
            e.printStackTrace();
            fail("Must fail inside of GridResultPage.fetchNextPage or subclass.");
          }
          res=FAKE;
        }
        if (res != FAKE && !res.equals(pRes)) {
          int j=0;
          for (          String cacheName : F.asList("co","pr","pe","pu")) {
            assertEquals(cacheName,cacheSize.get(j++).intValue(),grid(GRID_CNT - 1).cache(cacheName).size());
          }
          assertEquals(pRes,res);
        }
        int c=qryCnt.incrementAndGet();
        if (c % logFreq == 0)         info("Executed queries: " + c);
      }
    }
  }
,qryThreadNum,"query-thread");
  final AtomicInteger restartCnt=new AtomicInteger();
  final AtomicBoolean restartsDone=new AtomicBoolean();
  IgniteInternalFuture<?> fut2=multithreadedAsync(new Callable<Object>(){
    @SuppressWarnings({"BusyWait"}) @Override public Object call() throws Exception {
      GridRandom rnd=new GridRandom();
      while (!restartsDone.get()) {
        int g;
        do {
          g=rnd.nextInt(locks.length());
        }
 while (!locks.compareAndSet(g,0,-1));
        log.info("Stop node: " + g);
        stopGrid(g);
        Thread.sleep(rnd.nextInt(nodeLifeTime));
        log.info("Start node: " + g);
        startGrid(g);
        Thread.sleep(rnd.nextInt(nodeLifeTime));
        locks.set(g,0);
        int c=restartCnt.incrementAndGet();
        if (c % logFreq == 0)         info("Node restarts: " + c);
      }
      return true;
    }
  }
,restartThreadsNum,"restart-thread");
  Thread.sleep(duration);
  info("Stopping..");
  restartsDone.set(true);
  fut2.get();
  info("Restarts stopped.");
  qrysDone.set(true);
  fut1.get();
  info("Queries stopped.");
}
