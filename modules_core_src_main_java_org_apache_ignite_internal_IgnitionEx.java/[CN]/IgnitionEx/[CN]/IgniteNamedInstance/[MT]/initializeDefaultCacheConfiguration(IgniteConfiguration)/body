{
  List<CacheConfiguration> cacheCfgs=new ArrayList<>();
  boolean clientDisco=cfg.getDiscoverySpi() instanceof TcpClientDiscoverySpi;
  if (!clientDisco) {
    cacheCfgs.add(marshallerSystemCache());
    cacheCfgs.add(utilitySystemCache());
  }
  if (IgniteComponentType.HADOOP.inClassPath())   cacheCfgs.add(CU.hadoopSystemCache());
  if (cfg.getAtomicConfiguration() != null && !clientDisco)   cacheCfgs.add(atomicsSystemCache(cfg.getAtomicConfiguration()));
  CacheConfiguration[] userCaches=cfg.getCacheConfiguration();
  if (userCaches != null && userCaches.length > 0) {
    if (!U.discoOrdered(cfg.getDiscoverySpi()) && !U.relaxDiscoveryOrdered())     throw new IgniteCheckedException("Discovery SPI implementation does not support node ordering and " + "cannot be used with cache (use SPI with @GridDiscoverySpiOrderSupport annotation, " + "like GridTcpDiscoverySpi)");
    for (    CacheConfiguration ccfg : userCaches) {
      if (CU.isHadoopSystemCache(ccfg.getName()))       throw new IgniteCheckedException("Cache name cannot be \"" + CU.SYS_CACHE_HADOOP_MR + "\" because it is reserved for internal purposes.");
      if (CU.isAtomicsCache(ccfg.getName()))       throw new IgniteCheckedException("Cache name cannot be \"" + CU.ATOMICS_CACHE_NAME + "\" because it is reserved for internal purposes.");
      if (CU.isUtilityCache(ccfg.getName()))       throw new IgniteCheckedException("Cache name cannot be \"" + CU.UTILITY_CACHE_NAME + "\" because it is reserved for internal purposes.");
      if (CU.isMarshallerCache(ccfg.getName()))       throw new IgniteCheckedException("Cache name cannot be \"" + CU.MARSH_CACHE_NAME + "\" because it is reserved for internal purposes.");
      cacheCfgs.add(ccfg);
    }
  }
  cfg.setCacheConfiguration(cacheCfgs.toArray(new CacheConfiguration[cacheCfgs.size()]));
}
