{
  int thrCnt=getIntProperty(THREADS_CNT,1);
  int dur=getIntProperty(TEST_DUR_SEC,60);
  int winSize=getIntProperty("GG_WIN_SIZE",5000);
  dumpProperties(System.out);
  final StreamerBoundedSizeWindow<Integer> win=new StreamerBoundedSizeWindow<>();
  win.setMaximumSize(winSize);
  win.setIndexes(idxCfg.indexProvider());
  win.start();
  final AtomicLong enqueueCntr=new AtomicLong();
  IgniteFuture<Long> enqueueFut=runMultiThreadedAsync(new CAX(){
    @Override public void applyx() throws IgniteCheckedException {
      Random rnd=new Random();
      while (!Thread.currentThread().isInterrupted()) {
        win.enqueue(rnd.nextInt());
        enqueueCntr.incrementAndGet();
      }
    }
  }
,thrCnt,"generator");
  final AtomicLong evictCntr=new AtomicLong();
  IgniteFuture<Long> evictFut=runMultiThreadedAsync(new CAX(){
    @Override public void applyx() throws IgniteCheckedException {
      while (!Thread.currentThread().isInterrupted()) {
        win.pollEvicted();
        evictCntr.incrementAndGet();
      }
    }
  }
,thrCnt,"evictor");
  IgniteFuture<Long> collFut=runMultiThreadedAsync(new CAX(){
    @Override public void applyx(){
      int nSec=0;
      long prevEnqueue=enqueueCntr.get();
      long prevEvict=evictCntr.get();
      try {
        while (!Thread.currentThread().isInterrupted()) {
          U.sleep(1000);
          nSec++;
          long curEnqueue=enqueueCntr.get();
          long curEvict=evictCntr.get();
          X.println("Stats [enqueuePerSec=" + (curEnqueue - prevEnqueue) + ", evictPerSec="+ (curEvict - prevEvict)+ ']');
          prevEnqueue=curEnqueue;
          prevEvict=curEvict;
        }
      }
 catch (      IgniteInterruptedException ignored) {
      }
      X.println("Final results [enqueuePerSec=" + (enqueueCntr.get() / nSec) + ", evictPerSec="+ (evictCntr.get() / nSec)+ ']');
    }
  }
,1,"collector");
  U.sleep(dur * 1000);
  X.println("Finishing test.");
  collFut.cancel();
  enqueueFut.cancel();
  evictFut.cancel();
}
