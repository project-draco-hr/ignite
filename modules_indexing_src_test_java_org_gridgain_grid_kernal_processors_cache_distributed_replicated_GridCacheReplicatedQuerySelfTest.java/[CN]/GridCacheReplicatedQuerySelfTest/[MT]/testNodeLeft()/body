{
  try {
    Ignite g=startGrid();
    GridCache<Integer,Integer> cache=g.cache(null);
    for (int i=0; i < 1000; i++)     assertTrue(cache.putx(i,i));
    GridCacheQuery<Map.Entry<Integer,Integer>> q=cache.queries().createSqlQuery(Integer.class,"_key >= 0 order by _key").projection(ignite.cluster());
    q.pageSize(50);
    q.projection(g.cluster().forNodes(Arrays.asList(g.cluster().localNode(),grid(0).localNode())));
    GridCacheQueryFuture<Map.Entry<Integer,Integer>> fut=q.execute();
    assertEquals(0,(int)fut.next().getKey());
    final ConcurrentMap<UUID,Map<Long,GridFutureAdapter<GridCloseableIterator<GridIndexingKeyValueRow<Integer,Integer>>>>> map=U.field(((GridKernal)grid(0)).internalCache().context().queries(),"qryIters");
    assertTrue(GridTestUtils.waitForCondition(new PA(){
      @Override public boolean apply(){
        return map.size() == 1;
      }
    }
,getTestTimeout()));
    Map<Long,GridFutureAdapter<GridCloseableIterator<GridIndexingKeyValueRow<Integer,Integer>>>> futs=map.get(g.cluster().localNode().id());
    assertEquals(1,futs.size());
    GridSpiCloseableIterator<GridIndexingKeyValueRow<Integer,Integer>> iter=U.field(((IgniteFuture)F.first(futs.values()).get()).get(),"iter");
    ResultSet rs=U.field(iter,"data");
    assertFalse(rs.isClosed());
    final UUID nodeId=g.cluster().localNode().id();
    final CountDownLatch latch=new CountDownLatch(1);
    grid(0).events().localListen(new IgnitePredicate<GridEvent>(){
      @Override public boolean apply(      GridEvent evt){
        if (((GridDiscoveryEvent)evt).eventNode().id().equals(nodeId))         latch.countDown();
        return true;
      }
    }
,EVT_NODE_LEFT);
    stopGrid();
    latch.await();
    assertEquals(0,map.size());
    assertTrue(rs.isClosed());
  }
  finally {
    stopGrid();
  }
}
