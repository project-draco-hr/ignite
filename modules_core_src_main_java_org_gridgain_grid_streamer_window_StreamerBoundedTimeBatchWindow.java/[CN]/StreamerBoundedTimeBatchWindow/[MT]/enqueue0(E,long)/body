{
  WindowHolder tup=ref.get();
  ConcurrentLinkedDeque8<Batch> evts=tup.batchQueue();
  AtomicInteger size=tup.batchQueueSize();
  while (true) {
    Batch last=evts.peekLast();
    if (last == null || !last.add(evt,ts)) {
      if (last != null)       last.finish();
      if (enqueueLock.writeLock().tryLock()) {
        try {
          Batch first0=evts.peekLast();
          if (first0 == last) {
            Batch batch=new Batch(batchSize,ts + batchTimeInterval);
            ConcurrentLinkedDeque8.Node<Batch> node=evts.offerLastx(batch);
            batch.node(node);
            size.incrementAndGet();
            if (batch.removed() && evts.unlinkx(node))             size.decrementAndGet();
          }
        }
  finally {
          enqueueLock.writeLock().unlock();
        }
      }
 else {
        enqueueLock.readLock().lock();
        try {
          evts.peekLast();
        }
  finally {
          enqueueLock.readLock().unlock();
        }
      }
    }
 else {
      tup.totalQueueSize().incrementAndGet();
      return true;
    }
  }
}
