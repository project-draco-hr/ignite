{
  for (  Ignite g : G.allGrids()) {
    for (    GridCache<?,?> c : ((GridEx)g).cachesx()) {
      CacheConfiguration cfg=c.configuration();
      if (cfg.getCacheMode() == PARTITIONED && cfg.getPreloadMode() != NONE && g.cluster().nodes().size() > 1) {
        GridCacheAffinityFunction aff=cfg.getAffinity();
        GridDhtCacheAdapter<?,?> dht=dht(c);
        GridDhtPartitionTopology<?,?> top=dht.topology();
        for (int p=0; p < aff.partitions(); p++) {
          long start=0;
          for (int i=0; ; i++) {
            Collection<ClusterNode> affNodes=c.affinity().mapPartitionToPrimaryAndBackups(p);
            int exp=affNodes.size();
            Collection<ClusterNode> owners=top.nodes(p,-1);
            int actual=owners.size();
            if (affNodes.size() != owners.size() || !affNodes.containsAll(owners)) {
              LT.warn(log(),null,"Waiting for topology map update [grid=" + g.name() + ", p="+ p+ ", nodes="+ exp+ ", owners="+ actual+ ", affNodes="+ affNodes+ ", owners="+ owners+ ", locNode="+ g.cluster().localNode().id()+ ']');
              if (i == 0)               start=System.currentTimeMillis();
              Thread.sleep(200);
              continue;
            }
            if (i > 0)             log().warning("Finished waiting for topology map update [grid=" + g.name() + ", p="+ p+ ", duration="+ (System.currentTimeMillis() - start)+ "ms]");
            break;
          }
        }
      }
    }
  }
}
