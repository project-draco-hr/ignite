{
  GridDhtCacheEntry<K,V> cached=(GridDhtCacheEntry<K,V>)entry.cached();
  boolean ret;
  GridCacheContext<K,V> cacheCtx=entry.context();
  GridDhtCacheAdapter<K,V> dht=cacheCtx.isNear() ? cacheCtx.near().dht() : cacheCtx.dht();
  while (true) {
    try {
      Collection<GridNode> dhtNodes=dht.topology().nodes(cached.partition(),tx.topologyVersion());
      if (log.isDebugEnabled())       log.debug("Mapping entry to DHT nodes [nodes=" + U.toShortString(dhtNodes) + ", entry="+ entry+ ']');
      Collection<UUID> readers=cached.readers();
      Collection<GridNode> nearNodes=null;
      if (!F.isEmpty(readers)) {
        nearNodes=cctx.discovery().nodes(readers,F0.not(F.idForNodeId(tx.nearNodeId())));
        if (log.isDebugEnabled())         log.debug("Mapping entry to near nodes [nodes=" + U.toShortString(nearNodes) + ", entry="+ entry+ ']');
      }
 else       if (log.isDebugEnabled())       log.debug("Entry has no near readers: " + entry);
      ret=map(entry,F.view(dhtNodes,F.remoteNodes(cctx.localNodeId())),dhtMap,futDhtMap);
      ret|=map(entry,F.view(nearNodes,F0.notIn(dhtNodes)),nearMap,futNearMap);
      break;
    }
 catch (    GridCacheEntryRemovedException ignore) {
      cached=dht.entryExx(entry.key());
      entry.cached(cached,cached.keyBytes());
    }
  }
  return ret;
}
