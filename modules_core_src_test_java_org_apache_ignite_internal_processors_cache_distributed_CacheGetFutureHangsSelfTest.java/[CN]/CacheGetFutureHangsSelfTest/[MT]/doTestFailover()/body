{
  try {
    for (int i=0; i < GRID_CNT + 1; i++) {
      final IgniteEx grid=startGrid(i);
      grids[i]=grid;
      ids[i]=grid.localNode().id().toString();
      aliveGrids.add(i);
      flags[i]=new AtomicBoolean();
    }
    for (int i=0; i < GRID_CNT + 1; i++) {
      final int gridIdx=i;
      futs.add(multithreadedAsync(new Runnable(){
        @Override public void run(){
          IgniteCache cache=grids[gridIdx].cache(null);
          while (!flags[gridIdx].get()) {
            int idx=ThreadLocalRandom.current().nextInt(GRID_CNT + 1);
            String id=ids[idx];
            if (id != null) {
              cache.containsKey(id);
            }
            try {
              Thread.sleep(ThreadLocalRandom.current().nextLong(50));
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
,1,"containsKey-thread-" + i));
      futs.add(multithreadedAsync(new Runnable(){
        @Override public void run(){
          IgniteCache cache=grids[gridIdx].cache(null);
          while (!flags[gridIdx].get()) {
            int idx=ThreadLocalRandom.current().nextInt(GRID_CNT + 1);
            String id=ids[idx];
            if (id != null) {
              cache.put(id,UUID.randomUUID());
            }
            try {
              Thread.sleep(ThreadLocalRandom.current().nextLong(50));
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
,1,"put-thread-" + i));
    }
    while (aliveGrids.size() > 1) {
      final int gridToKill=ThreadLocalRandom.current().nextInt(GRID_CNT) + 1;
      if (gridToKill > 0 && grids[gridToKill] != null) {
        U.debug("!!! Trying to kill grid " + gridToKill);
        U.debug("!!! Grid stop start " + gridToKill);
        grids[gridToKill].close();
        aliveGrids.remove(gridToKill);
        grids[gridToKill]=null;
        flags[gridToKill].set(true);
        U.debug("!!! Grid stop finished " + gridToKill);
      }
    }
    Thread.sleep(ThreadLocalRandom.current().nextLong(100));
  }
  finally {
    flags[0].set(true);
    for (    IgniteInternalFuture fut : futs)     fut.get();
  }
}
