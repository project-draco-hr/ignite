{
  A.notNull(tasks,"tasks != null");
  A.ensure(timeout >= 0,"timeout >= 0");
  A.notNull(unit,"unit != null");
  long now=U.currentTimeMillis();
  timeout=TimeUnit.MILLISECONDS.convert(timeout,unit);
  long end=timeout == 0 ? Long.MAX_VALUE : timeout + now;
  if (end < 0)   end=Long.MAX_VALUE;
  checkShutdown();
  Collection<GridComputeTaskFuture<T>> taskFuts=new ArrayList<>();
  for (  Callable<T> task : tasks) {
    deployTask(GridExecutorCallableTask.class,task);
    GridComputeTaskFuture<T> fut=prj.compute().execute(new GridExecutorCallableTask<T>(task.getClass()),task);
    taskFuts.add(fut);
    now=U.currentTimeMillis();
  }
  boolean isInterrupted=false;
  for (  GridComputeTaskFuture<T> fut : taskFuts) {
    if (!isInterrupted && now < end) {
      try {
        fut.get(end - now);
      }
 catch (      GridComputeTaskTimeoutException ignore) {
        if (log.isDebugEnabled())         log.debug("Timeout occurred during getting task result: " + fut);
        cancelFuture(fut);
      }
catch (      GridException e) {
        if (e.getCause() instanceof InterruptedException) {
          isInterrupted=true;
          cancelFuture(fut);
        }
      }
    }
    now=U.currentTimeMillis();
  }
  if (isInterrupted)   throw new InterruptedException("Got interrupted while waiting for tasks invocation.");
  List<Future<T>> futs=new ArrayList<>(taskFuts.size());
  for (  GridComputeTaskFuture<T> fut : taskFuts) {
    if (!fut.isDone())     cancelFuture(fut);
    futs.add(new TaskFutureWrapper<>(fut));
  }
  return futs;
}
