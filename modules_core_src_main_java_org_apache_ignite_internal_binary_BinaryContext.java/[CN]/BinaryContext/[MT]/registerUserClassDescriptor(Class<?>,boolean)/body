{
  boolean registered;
  final String clsName=cls.getName();
  BinaryInternalMapper mapper=userTypeMapper(clsName);
  final String typeName=mapper.typeName(clsName);
  final int typeId=mapper.typeId(clsName);
  try {
    registered=marshCtx.registerClass(typeId,cls);
  }
 catch (  IgniteCheckedException e) {
    throw new BinaryObjectException("Failed to register class.",e);
  }
  BinarySerializer serializer=serializerForClass(cls);
  String affFieldName=affinityFieldName(cls);
  BinaryClassDescriptor desc=new BinaryClassDescriptor(this,cls,true,typeId,typeName,affFieldName,mapper,serializer,true,registered);
  if (!deserialize) {
    Collection<BinarySchema> schemas=desc.schema() != null ? Collections.singleton(desc.schema()) : null;
    metaHnd.addMeta(typeId,new BinaryMetadata(typeId,typeName,desc.fieldsMeta(),affFieldName,schemas,desc.isEnum()).wrap(this));
  }
  if (IgniteUtils.detectClassLoader(cls).equals(dfltLdr))   userTypes.put(typeId,desc);
  descByCls.put(cls,desc);
  typeId2Mapper.putIfAbsent(typeId,mapper);
  return desc;
}
