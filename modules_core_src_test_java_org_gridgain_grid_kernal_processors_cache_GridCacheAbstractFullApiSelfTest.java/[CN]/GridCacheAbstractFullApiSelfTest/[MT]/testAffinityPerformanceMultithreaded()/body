{
  final GridCache<String,Integer> cache=cache();
  final int total=20 * 1000 * 1000;
  final int threads=20;
  final int size=total / threads;
  final AtomicLong ops=new AtomicLong(0);
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch done=new CountDownLatch(threads);
  multithreadedAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      latch.await();
      for (long start=ops.getAndAdd(size), op=start; op < start + size; op++)       cache.affinity().mapKeyToPrimaryAndBackups(Long.toString(op));
      done.countDown();
      return null;
    }
  }
,threads);
  long start=System.currentTimeMillis();
  latch.countDown();
  done.await();
  long opsPerMs=ops.get() / (System.currentTimeMillis() - start);
  info("Operations per ms [opsPerMs=" + opsPerMs + ']');
  assertTrue("Expect more then 1000 operations per ms [opsPerMs=" + opsPerMs + ']',opsPerMs > 800);
}
