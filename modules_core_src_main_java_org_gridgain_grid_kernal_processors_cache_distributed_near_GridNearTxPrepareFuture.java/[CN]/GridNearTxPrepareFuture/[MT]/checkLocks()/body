{
  Collection<GridCacheTxEntry<K,V>> checkEntries=tx.groupLock() ? Collections.singletonList(tx.groupLockEntry()) : tx.writeEntries();
  for (  GridCacheTxEntry<K,V> txEntry : checkEntries) {
    while (true) {
      GridCacheEntryEx<K,V> cached=txEntry.cached();
      try {
        GridCacheVersion ver=txEntry.explicitVersion() != null ? txEntry.explicitVersion() : tx.xidVersion();
        if (!cached.lockedBy(ver)) {
          if (log.isDebugEnabled())           log.debug("Transaction entry is not locked by transaction (will wait) [entry=" + cached + ", tx="+ tx+ ']');
          return false;
        }
        break;
      }
 catch (      GridCacheEntryRemovedException ignored) {
        if (log.isDebugEnabled())         log.debug("Got removed entry in future onAllReplies method (will retry): " + txEntry);
        txEntry.cached(txEntry.context().cache().entryEx(txEntry.key()),txEntry.keyBytes());
      }
    }
  }
  if (log.isDebugEnabled())   log.debug("All locks are acquired for near prepare future: " + this);
  return true;
}
