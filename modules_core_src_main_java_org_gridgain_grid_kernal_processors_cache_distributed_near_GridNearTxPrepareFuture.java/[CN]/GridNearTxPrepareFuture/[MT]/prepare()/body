{
  GridDhtTopologyFuture topFut=topologyReadLock();
  try {
    if (topFut.isDone()) {
      try {
        if (!tx.state(PREPARING)) {
          if (tx.setRollbackOnly()) {
            if (tx.timedOut())             onError(null,null,new GridCacheTxTimeoutException("Transaction timed out and " + "was rolled back: " + this));
 else             onError(null,null,new GridException("Invalid transaction state for prepare " + "[state=" + tx.state() + ", tx="+ this+ ']'));
          }
 else           onError(null,null,new GridCacheTxRollbackException("Invalid transaction state for " + "prepare [state=" + tx.state() + ", tx="+ this+ ']'));
          return;
        }
        GridDiscoveryTopologySnapshot snapshot=topFut.topologySnapshot();
        tx.topologyVersion(snapshot.topologyVersion());
        tx.topologySnapshot(snapshot);
        cctx.mvcc().addFuture(this);
        prepare0();
      }
 catch (      GridCacheTxTimeoutException|GridCacheTxOptimisticException e) {
        onError(cctx.localNodeId(),null,e);
      }
catch (      GridException e) {
        tx.setRollbackOnly();
        String msg="Failed to prepare transaction (will attempt rollback): " + this;
        U.error(log,msg,e);
        tx.rollbackAsync();
        onError(null,null,new GridCacheTxRollbackException(msg,e));
      }
    }
 else {
      topFut.syncNotify(false);
      topFut.listenAsync(new CI1<GridFuture<Long>>(){
        @Override public void apply(        GridFuture<Long> t){
          prepare();
        }
      }
);
    }
  }
  finally {
    topologyReadUnlock();
  }
}
