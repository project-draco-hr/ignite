{
  IgniteCacheProxy<K,V> proxy=(IgniteCacheProxy<K,V>)cache;
  GridCacheAdapter<K,V> internalCache=proxy.context().cache();
  if (internalCache.isNear())   internalCache=internalCache.context().near().dht();
  GridCacheContext<K,V> cctx=internalCache.context();
  long topVer=cctx.affinity().affinityTopologyVersion();
  GridCacheVersion ver=cctx.versions().next(topVer);
  boolean portable=cctx.portableEnabled();
  for (  Map.Entry<K,V> e : entries) {
    try {
      K key=e.getKey();
      V val=e.getValue();
      if (portable) {
        key=(K)cctx.marshalToPortable(key);
        val=(V)cctx.marshalToPortable(val);
      }
      GridCacheEntryEx<K,V> entry=internalCache.entryEx(key,topVer);
      entry.unswap(true,false);
      entry.initialValue(val,null,ver,CU.TTL_ETERNAL,CU.EXPIRE_TIME_ETERNAL,false,topVer,GridDrType.DR_LOAD);
      cctx.evicts().touch(entry,topVer);
    }
 catch (    GridDhtInvalidPartitionException|GridCacheEntryRemovedException ignored) {
    }
catch (    IgniteCheckedException ex) {
      IgniteLogger log=cache.unwrap(Ignite.class).log();
      U.error(log,"Failed to set initial value for cache entry: " + e,ex);
    }
  }
}
