{
  GridLicenseUseRegistry.onUsage(DATA_GRID,GridOffHeapMapFactory.class);
  long max=cctx.config().getOffHeapMaxMemory();
  long init=max > 0 ? max / 1024 : 8L * 1024L * 1024L;
  int parts=cctx.config().getAffinity().partitions();
  GridOffHeapEvictListener lsnr=!swapEnabled && !offheapEnabled ? null : new GridOffHeapEvictListener(){
    private final AtomicBoolean evictWarn=new AtomicBoolean();
    @Override public void onEvict(    int part,    int hash,    byte[] kb,    byte[] vb){
      try {
        if (evictWarn.compareAndSet(false,true))         U.warn(log,"Off-heap evictions started. You may wish to increase 'offHeapMaxMemory' in " + "cache configuration [cache=" + cctx.name() + ", offHeapMaxMemory="+ cctx.config().getOffHeapMaxMemory()+ ']',"Off-heap evictions started: " + cctx.name());
        writeToSwap(part,null,kb,vb);
      }
 catch (      GridException e) {
        log.error("Failed to unmarshal off-heap entry [part=" + part + ", hash="+ hash+ ']',e);
      }
    }
  }
;
  offheap.create(spaceName,parts,init,max,lsnr);
}
