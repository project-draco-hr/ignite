{
  GridCacheVersion ver=ctx.versions().next();
  if (storeEnabled && keys.size() > 1) {
    updateWithBatch(op,keys,vals,ver,filter);
    return null;
  }
  Iterator<?> valsIter=vals != null ? vals.iterator() : null;
  GridBiTuple<Boolean,?> res=null;
  GridCachePartialUpdateException err=null;
  for (  K key : keys) {
    Object val=valsIter != null ? valsIter.next() : null;
    if (key == null)     continue;
    while (true) {
      GridCacheEntryEx<K,V> entry=null;
      try {
        entry=entryEx(key);
        GridBiTuple<Boolean,V> t=entry.innerUpdateLocal(ver,val == null ? DELETE : op,val,storeEnabled,retval,ttl,true,true,filter);
        if (res == null) {
          V retVal=t.get2();
          if (op == TRANSFORM && val instanceof GridCacheTransformComputeClosure) {
            assert retval;
            res=new GridBiTuple<>(t.get1(),((GridCacheTransformComputeClosure<V,?>)val).compute(retVal));
          }
 else           res=t;
        }
        break;
      }
 catch (      GridCacheEntryRemovedException ignored) {
        if (log.isDebugEnabled())         log.debug("Got removed entry while updating (will retry): " + key);
        entry=null;
      }
catch (      GridException e) {
        if (err == null)         err=partialUpdateException();
        err.add(F.asList(key),e);
        U.error(log,"Failed to update key : " + key,e);
        break;
      }
 finally {
        if (entry != null)         ctx.evicts().touch(entry);
      }
    }
  }
  if (err != null)   throw err;
  return res == null ? null : rawRetval ? new GridCacheReturn<>(res.get2(),res.get1()) : retval ? res.get2() : res.get1();
}
