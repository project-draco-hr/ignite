{
  ctx.checkSecurity(GridSecurityPermission.CACHE_READ);
  if (F.isEmpty(keys))   return Collections.emptyMap();
  GridCacheProjectionImpl<K,V> prj=ctx.projectionPerCall();
  UUID subjId=ctx.subjectIdPerCall(null,prj);
  ExpiryPolicy expiryPlc=prj != null ? prj.expiry() : null;
  if (expiryPlc == null)   expiryPlc=ctx.expiry();
  Map<K,V> vals=new HashMap<>(keys.size(),1.0f);
  if (keyCheck)   validateCacheKeys(keys);
  final GetExpiryPolicy expiry=accessExpiryPolicy(expiryPlc);
  boolean success=true;
  for (  K key : keys) {
    if (key == null)     continue;
    GridCacheEntryEx<K,V> entry=null;
    while (true) {
      try {
        entry=swapOrOffheap ? entryEx(key) : peekEx(key);
        if (entry != null) {
          V v=entry.innerGet(null,swapOrOffheap,false,false,true,true,true,false,subjId,null,taskName,filter,expiry);
          if (v != null)           vals.put(key,v);
 else           success=false;
        }
 else {
          if (!storeEnabled && configuration().isStatisticsEnabled())           metrics0().onRead(false);
          success=false;
        }
        break;
      }
 catch (      GridCacheEntryRemovedException ignored) {
      }
catch (      GridCacheFilterFailedException ignored) {
        break;
      }
 finally {
        if (entry != null)         ctx.evicts().touch(entry,ctx.affinity().affinityTopologyVersion());
      }
      if (!success && storeEnabled)       break;
    }
  }
  if (success || !storeEnabled) {
    if (!clone)     return vals;
    Map<K,V> map=new GridLeanMap<>();
    for (    Map.Entry<K,V> e : vals.entrySet())     map.put(e.getKey(),ctx.cloneValue(e.getValue()));
    return map;
  }
  return getAllAsync(keys,true,null,false,subjId,taskName,deserializePortable,false,expiry,filter).get();
}
