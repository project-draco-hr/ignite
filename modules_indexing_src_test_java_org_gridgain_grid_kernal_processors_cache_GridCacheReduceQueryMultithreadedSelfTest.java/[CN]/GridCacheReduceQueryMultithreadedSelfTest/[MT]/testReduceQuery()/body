{
  final int keyCnt=5000;
  final int logFreq=500;
  final GridCache<String,Integer> c=cache();
  final CountDownLatch startLatch=new CountDownLatch(1);
  IgniteFuture<?> fut1=multithreadedAsync(new Callable(){
    @Override public Object call() throws Exception {
      for (int i=1; i < keyCnt; i++) {
        assertTrue(c.putx(String.valueOf(i),i));
        startLatch.countDown();
        if (i % logFreq == 0)         info("Stored entries: " + i);
      }
      return null;
    }
  }
,1);
  final GridCacheQuery<Map.Entry<String,Integer>> sumQry=c.queries().createSqlQuery(Integer.class,"_val > 0").timeout(TEST_TIMEOUT);
  final R1<Map.Entry<String,Integer>,Integer> rmtRdc=new R1<Map.Entry<String,Integer>,Integer>(){
    /** 
 */
    private AtomicInteger sum=new AtomicInteger();
    @Override public boolean collect(    Map.Entry<String,Integer> e){
      sum.addAndGet(e.getValue());
      return true;
    }
    @Override public Integer reduce(){
      return sum.get();
    }
  }
;
  final AtomicBoolean stop=new AtomicBoolean();
  startLatch.await();
  IgniteFuture<?> fut2=multithreadedAsync(new Callable(){
    @Override public Object call() throws Exception {
      int cnt=0;
      while (!stop.get()) {
        Collection<Integer> res=sumQry.execute(rmtRdc).get();
        int sum=F.sumInt(res);
        cnt++;
        assertTrue(sum > 0);
        if (cnt % logFreq == 0) {
          info("Reduced value: " + sum);
          info("Executed queries: " + cnt);
        }
      }
      return null;
    }
  }
,1);
  fut1.get();
  stop.set(true);
  fut2.get();
}
