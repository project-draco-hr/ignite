{
  startedThreadsLock.block();
  List<Thread> all;
  try {
    all=new ArrayList<>(startedThreads.size());
    startedThreads.drainTo(all);
  }
  finally {
    startedThreadsLock.unblock();
  }
  boolean aliveThreads=F.forAny(all,new P1<Thread>(){
    @Override public boolean apply(    Thread t){
      return t.isAlive();
    }
  }
);
  if (!aliveThreads)   return;
  U.warn(log,"Interrupting threads started so far: " + all.size());
  U.interrupt(all);
  U.joinThreads(all,log);
  Iterator<Thread> it=all.iterator();
  for (Thread thread=it.next(); it.hasNext(); thread=it.next())   if (!thread.isAlive())   it.remove();
  if (all.isEmpty())   U.warn(log,"Finished interrupting threads.");
 else   U.error(log,"Finished interrupting threads, but some threads are still alive" + " [size=" + all.size() + ", threads="+ all+ "]");
}
