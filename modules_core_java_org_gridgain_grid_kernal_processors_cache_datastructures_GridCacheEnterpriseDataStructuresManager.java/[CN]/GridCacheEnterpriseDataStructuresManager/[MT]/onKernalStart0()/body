{
  try {
    dsView=cctx.cache().<GridCacheInternal,GridCacheInternal>projection(GridCacheInternal.class,GridCacheInternal.class).flagsOn(CLONE);
    if (transactionalWithNear()) {
      cntDownLatchView=cctx.cache().<GridCacheInternalKey,GridCacheCountDownLatchValue>projection(GridCacheInternalKey.class,GridCacheCountDownLatchValue.class).flagsOn(CLONE);
      atomicLongView=cctx.cache().<GridCacheInternalKey,GridCacheAtomicLongValue>projection(GridCacheInternalKey.class,GridCacheAtomicLongValue.class).flagsOn(CLONE);
      atomicRefView=cctx.cache().<GridCacheInternalKey,GridCacheAtomicReferenceValue>projection(GridCacheInternalKey.class,GridCacheAtomicReferenceValue.class).flagsOn(CLONE);
      atomicStampedView=cctx.cache().<GridCacheInternalKey,GridCacheAtomicStampedValue>projection(GridCacheInternalKey.class,GridCacheAtomicStampedValue.class).flagsOn(CLONE);
      seqView=cctx.cache().<GridCacheInternalKey,GridCacheAtomicSequenceValue>projection(GridCacheInternalKey.class,GridCacheAtomicSequenceValue.class).flagsOn(CLONE);
    }
    if (supportsQueue()) {
      queueHdrView=cctx.cache().<GridCacheQueueKey,GridCacheQueueHeader>projection(GridCacheQueueKey.class,GridCacheQueueHeader.class).flagsOn(CLONE);
      queueCleanupWorker=new QueueCleanupWorker();
      new GridThread(queueCleanupWorker).start();
      queueQry=(GridCacheContinuousQueryAdapter)cctx.cache().queries().createContinuousQuery();
      queueQry.filter(new QueueHeaderPredicate());
      queueQry.callback(new GridBiPredicate<UUID,Collection<Map.Entry>>(){
        @Override public boolean apply(        UUID uuid,        Collection<Map.Entry> entries){
          for (          Map.Entry e : entries) {
            GridCacheQueueKey key=(GridCacheQueueKey)e.getKey();
            GridCacheQueueHeader hdr=(GridCacheQueueHeader)e.getValue();
            for (            final GridCacheQueueAdapter queue : queuesMap.values()) {
              if (queue.name().equals(key.queueName())) {
                if (hdr == null) {
                  cctx.closures().callLocalSafe(new Callable<Void>(){
                    @Override public Void call() throws Exception {
                      try {
                        queue.size();
                      }
 catch (                      GridCacheDataStructureRemovedRuntimeException ignore) {
                        queuesMap.remove(queue.queueId());
                      }
                      return null;
                    }
                  }
,false);
                }
 else                 queue.onHeaderChanged(hdr);
              }
            }
          }
          return true;
        }
      }
);
      queueQry.execute(cctx.isLocal() || cctx.isReplicated() ? cctx.grid().forLocal() : null,true);
    }
    initFlag=true;
  }
  finally {
    initLatch.countDown();
  }
}
