{
  cctx.checkSecurity(SecurityPermission.CACHE_READ);
  int taskNameHash=!internal && cctx.kernalContext().security().enabled() ? cctx.kernalContext().job().currentTaskNameHash() : 0;
  boolean skipPrimaryCheck=loc && cctx.config().getCacheMode() == CacheMode.REPLICATED && cctx.affinityNode();
  boolean v2=useV2Protocol(cctx.discovery().allNodes());
  final CacheContinuousQueryHandler hnd=clsr.apply(v2);
  hnd.taskNameHash(taskNameHash);
  hnd.skipPrimaryCheck(skipPrimaryCheck);
  hnd.notifyExisting(notifyExisting);
  hnd.internal(internal);
  hnd.keepBinary(keepBinary);
  hnd.localCache(cctx.isLocal());
  IgnitePredicate<ClusterNode> pred=(loc || cctx.config().getCacheMode() == CacheMode.LOCAL) ? F.nodeForNodeId(cctx.localNodeId()) : F.<ClusterNode>alwaysTrue();
  UUID id=cctx.kernalContext().continuous().startRoutine(hnd,bufSize,timeInterval,autoUnsubscribe,pred).get();
  try {
    if (hnd.isQuery() && cctx.userCache())     hnd.waitTopologyFuture(cctx.kernalContext());
  }
 catch (  IgniteCheckedException e) {
    log.warning("Failed to start continuous query.",e);
    cctx.kernalContext().continuous().stopRoutine(id);
    throw new IgniteCheckedException("Failed to start continuous query.",e);
  }
  if (notifyExisting) {
    final Iterator<GridCacheEntryEx> it=cctx.cache().allEntries().iterator();
    locLsnr.onUpdated(new Iterable<CacheEntryEvent>(){
      @Override public Iterator<CacheEntryEvent> iterator(){
        return new Iterator<CacheEntryEvent>(){
          private CacheContinuousQueryEvent next;
{
            advance();
          }
          @Override public boolean hasNext(){
            return next != null;
          }
          @Override public CacheEntryEvent next(){
            if (!hasNext())             throw new NoSuchElementException();
            CacheEntryEvent next0=next;
            advance();
            return next0;
          }
          @Override public void remove(){
            throw new UnsupportedOperationException();
          }
          private void advance(){
            next=null;
            while (next == null) {
              if (!it.hasNext())               break;
              GridCacheEntryEx e=it.next();
              CacheContinuousQueryEntry entry=new CacheContinuousQueryEntry(cctx.cacheId(),CREATED,e.key(),e.rawGet(),null,keepBinary,0,-1,null);
              next=new CacheContinuousQueryEvent<>(cctx.kernalContext().cache().jcache(cctx.name()),cctx,entry);
              if (hnd.getEventFilter() != null && !hnd.getEventFilter().evaluate(next))               next=null;
            }
          }
        }
;
      }
    }
);
  }
  return id;
}
