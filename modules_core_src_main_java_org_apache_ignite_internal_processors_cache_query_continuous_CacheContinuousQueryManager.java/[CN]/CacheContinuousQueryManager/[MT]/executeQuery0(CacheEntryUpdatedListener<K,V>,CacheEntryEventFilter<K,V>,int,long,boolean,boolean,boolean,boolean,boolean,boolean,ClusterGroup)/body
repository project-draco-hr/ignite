{
  cctx.checkSecurity(GridSecurityPermission.CACHE_READ);
  if (grp == null)   grp=cctx.kernalContext().grid();
  Collection<ClusterNode> nodes=grp.nodes();
  if (nodes.isEmpty())   throw new ClusterTopologyException("Failed to execute continuous query (empty cluster group is " + "provided).");
  boolean skipPrimaryCheck=false;
switch (cctx.config().getCacheMode()) {
case LOCAL:
    if (!nodes.contains(cctx.localNode()))     throw new ClusterTopologyException("Continuous query for LOCAL cache can be executed " + "only locally (provided projection contains remote nodes only).");
 else     if (nodes.size() > 1)     U.warn(log,"Continuous query for LOCAL cache will be executed locally (provided projection is " + "ignored).");
  grp=grp.forNode(cctx.localNode());
break;
case REPLICATED:
if (nodes.size() == 1 && F.first(nodes).equals(cctx.localNode())) {
CacheDistributionMode distributionMode=cctx.config().getDistributionMode();
if (distributionMode == PARTITIONED_ONLY || distributionMode == NEAR_PARTITIONED) skipPrimaryCheck=true;
}
break;
}
int taskNameHash=!internal && cctx.kernalContext().security().enabled() ? cctx.kernalContext().job().currentTaskNameHash() : 0;
GridContinuousHandler hnd=new CacheContinuousQueryHandler<>(cctx.name(),TOPIC_CACHE.topic(topicPrefix,cctx.localNodeId(),seq.getAndIncrement()),locLsnr,rmtFilter,internal,notifyExisting,oldValRequired,sync,ignoreExpired,taskNameHash,skipPrimaryCheck);
UUID id=cctx.kernalContext().continuous().startRoutine(hnd,bufSize,timeInterval,autoUnsubscribe,grp.predicate()).get();
if (notifyExisting) {
final Iterator<Cache.Entry<K,V>> it=cctx.cache().entrySetx().iterator();
locLsnr.onUpdated(new Iterable<CacheEntryEvent<? extends K,? extends V>>(){
@Override public Iterator<CacheEntryEvent<? extends K,? extends V>> iterator(){
return new Iterator<CacheEntryEvent<? extends K,? extends V>>(){
@Override public boolean hasNext(){
  return it.hasNext();
}
@Override public CacheEntryEvent<? extends K,? extends V> next(){
  Cache.Entry<K,V> e=it.next();
  return new CacheContinuousQueryEvent<>(cctx.kernalContext().cache().jcache(cctx.name()),CREATED,new CacheContinuousQueryEntry<>(e.getKey(),e.getValue(),null,null,null));
}
@Override public void remove(){
  throw new UnsupportedOperationException();
}
}
;
}
}
);
}
return id;
}
