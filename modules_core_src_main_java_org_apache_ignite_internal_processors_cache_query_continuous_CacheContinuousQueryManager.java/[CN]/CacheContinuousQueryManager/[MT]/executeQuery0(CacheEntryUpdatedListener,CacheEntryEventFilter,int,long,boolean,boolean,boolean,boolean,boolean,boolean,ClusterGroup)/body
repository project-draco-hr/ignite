{
  cctx.checkSecurity(GridSecurityPermission.CACHE_READ);
  if (grp == null)   grp=cctx.kernalContext().grid().cluster();
  Collection<ClusterNode> nodes=grp.nodes();
  if (nodes.isEmpty())   throw new ClusterTopologyException("Failed to execute continuous query (empty cluster group is " + "provided).");
  boolean skipPrimaryCheck=false;
switch (cctx.config().getCacheMode()) {
case LOCAL:
    if (!nodes.contains(cctx.localNode()))     throw new ClusterTopologyException("Continuous query for LOCAL cache can be executed " + "only locally (provided projection contains remote nodes only).");
 else     if (nodes.size() > 1)     U.warn(log,"Continuous query for LOCAL cache will be executed locally (provided projection is " + "ignored).");
  grp=grp.forNode(cctx.localNode());
break;
case REPLICATED:
if (nodes.size() == 1 && F.first(nodes).equals(cctx.localNode())) skipPrimaryCheck=cctx.affinityNode();
break;
}
int taskNameHash=!internal && cctx.kernalContext().security().enabled() ? cctx.kernalContext().job().currentTaskNameHash() : 0;
GridContinuousHandler hnd=new CacheContinuousQueryHandler<>(cctx.name(),TOPIC_CACHE.topic(topicPrefix,cctx.localNodeId(),seq.getAndIncrement()),locLsnr,rmtFilter,internal,notifyExisting,oldValRequired,sync,ignoreExpired,taskNameHash,skipPrimaryCheck);
UUID id=cctx.kernalContext().continuous().startRoutine(hnd,bufSize,timeInterval,autoUnsubscribe,grp.predicate()).get();
if (notifyExisting) {
final Iterator<GridCacheEntryEx> it=cctx.cache().allEntries().iterator();
locLsnr.onUpdated(new Iterable<CacheEntryEvent>(){
@Override public Iterator<CacheEntryEvent> iterator(){
return new Iterator<CacheEntryEvent>(){
private CacheContinuousQueryEvent next;
{
  advance();
}
@Override public boolean hasNext(){
  return next != null;
}
@Override public CacheEntryEvent next(){
  if (!hasNext())   throw new NoSuchElementException();
  CacheEntryEvent next0=next;
  advance();
  return next0;
}
@Override public void remove(){
  throw new UnsupportedOperationException();
}
private void advance(){
  next=null;
  while (next == null) {
    if (!it.hasNext())     break;
    GridCacheEntryEx e=it.next();
    next=new CacheContinuousQueryEvent<>(cctx.kernalContext().cache().jcache(cctx.name()),cctx,new CacheContinuousQueryEntry(cctx.cacheId(),CREATED,e.key(),e.rawGet(),null));
    if (rmtFilter != null && !rmtFilter.evaluate(next))     next=null;
  }
}
}
;
}
}
);
}
return id;
}
