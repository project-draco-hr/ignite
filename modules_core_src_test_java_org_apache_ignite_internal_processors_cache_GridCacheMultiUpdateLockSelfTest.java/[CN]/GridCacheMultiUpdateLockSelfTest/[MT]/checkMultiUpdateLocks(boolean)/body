{
  this.nearEnabled=nearEnabled;
  startGrids(3);
  try {
    IgniteKernal g=(IgniteKernal)grid(0);
    GridCacheContext<Object,Object> cctx=g.internalCache().context();
    GridDhtCacheAdapter cache=nearEnabled ? cctx.near().dht() : cctx.colocated();
    AffinityTopologyVersion topVer=cache.beginMultiUpdate();
    IgniteInternalFuture<?> startFut;
    try {
      assertEquals(3,topVer.topologyVersion());
      final AtomicBoolean started=new AtomicBoolean();
      startFut=multithreadedAsync(new Callable<Object>(){
        @Override public Object call() throws Exception {
          info(">>>> Starting grid.");
          Ignite g4=startGrid(4);
          started.set(true);
          IgniteCache<Object,Object> c=g4.cache(null);
          info(">>>> Checking tx in new grid.");
          try (Transaction tx=g4.transactions().txStart(PESSIMISTIC,REPEATABLE_READ)){
            assertEquals(2,c.get("a"));
            assertEquals(4,c.get("b"));
            assertEquals(6,c.get("c"));
          }
           return null;
        }
      }
,1);
      U.sleep(200);
      info(">>>> Checking grid has not started yet.");
      assertFalse(started.get());
      IgniteCache<Object,Object> cache0=g.cache(null);
      info(">>>> Checking tx commit.");
      Transaction tx=g.transactions().txStart(PESSIMISTIC,REPEATABLE_READ);
      try {
        cache0.put("a",1);
        cache0.put("b",2);
        cache0.put("c",3);
        tx.commit();
      }
  finally {
        tx.close();
      }
      info(">>>> Checking grid still is not started");
      assertFalse(started.get());
      tx=g.transactions().txStart(PESSIMISTIC,REPEATABLE_READ);
      try {
        cache0.put("a",2);
        cache0.put("b",4);
        cache0.put("c",6);
        tx.commit();
      }
  finally {
        tx.close();
      }
    }
  finally {
      info(">>>> Releasing multi update.");
      cache.endMultiUpdate();
    }
    info("Waiting for thread termination.");
    startFut.get();
  }
  finally {
    stopAllGrids();
  }
}
