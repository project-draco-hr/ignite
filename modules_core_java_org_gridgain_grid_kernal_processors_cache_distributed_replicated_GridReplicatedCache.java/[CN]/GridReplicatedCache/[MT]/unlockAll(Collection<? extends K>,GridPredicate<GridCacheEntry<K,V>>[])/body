{
  if (keys == null || keys.isEmpty())   return;
  Collection<? extends GridNode> nodes=ctx.affinity().remoteNodes(keys);
  try {
    GridDistributedUnlockRequest<K,V> req=new GridDistributedUnlockRequest<>(keys.size());
    for (    K key : keys) {
      GridDistributedCacheEntry<K,V> entry=entryexx(key);
      if (!ctx.isAll(entry.wrap(false),filter))       continue;
      GridCacheMvccCandidate<K> rmv=entry.removeLock();
      if (rmv != null && !nodes.isEmpty()) {
        if (!rmv.reentry()) {
          req.addKey(entry.key(),entry.getOrMarshalKeyBytes(),ctx);
          req.version(rmv.version());
          if (log.isDebugEnabled())           log.debug("Removed lock (will distribute): " + rmv);
        }
 else {
          if (log.isDebugEnabled())           log.debug("Locally unlocked lock reentry without distributing to other nodes [removed=" + rmv + ", entry="+ entry+ ']');
        }
      }
 else {
        if (log.isDebugEnabled())         log.debug("Current thread still owns lock (or there are no other nodes) [lock=" + rmv + ", curThreadId="+ Thread.currentThread().getId()+ ']');
      }
      ctx.evicts().touch(entry);
    }
    if (F.isEmpty(req.keyBytes()) && F.isEmpty(req.keys())) {
      if (log.isDebugEnabled())       log.debug("No keys to unlock locally (was it reentry unlock?): " + keys);
      return;
    }
    ctx.io().safeSend(nodes,req,null);
  }
 catch (  GridException e) {
    U.error(log,"Failed to unlock keys: " + keys,e);
  }
}
