{
  final int range=10000;
  final int iterCnt=iterationCount();
  final AtomicInteger iters=new AtomicInteger();
  multithreadedAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      Random rnd=new Random();
      while (true) {
        int i=iters.getAndIncrement();
        if (i >= iterCnt)         break;
        int g=rnd.nextInt(gridCount());
        Ignite ignite=grid(g);
        IgniteCache<Object,Object> cache=ignite.cache(null);
        int k=rnd.nextInt(range);
        boolean rmv=rnd.nextBoolean();
        if (!rmv)         cache.put(k,Thread.currentThread().getId());
 else         cache.remove(k);
        if (i > 0 && i % 5000 == 0)         info("Completed: " + i);
      }
      return null;
    }
  }
,THREAD_CNT).get();
  int present=0;
  int absent=0;
  Affinity<Integer> aff=ignite(0).affinity(null);
  boolean invalidVal=false;
  for (int i=0; i < range; i++) {
    Long firstVal=null;
    for (int g=0; g < gridCount(); g++) {
      Ignite ignite=grid(g);
      Long val=(Long)ignite.cache(null).localPeek(i,CachePeekMode.ONHEAP);
      if (firstVal == null && val != null)       firstVal=val;
      if (val != null) {
        if (!firstVal.equals(val)) {
          invalidVal=true;
          boolean primary=aff.isPrimary(ignite.cluster().localNode(),i);
          boolean backup=aff.isBackup(ignite.cluster().localNode(),i);
          log.error("Invalid value detected [key=" + i + ", val="+ val+ ", firstVal="+ firstVal+ ", node="+ g+ ", primary="+ primary+ ", backup="+ backup+ ']');
        }
      }
    }
    if (firstVal == null)     absent++;
 else     present++;
  }
  assertFalse("Inconsistent value found.",invalidVal);
  info("Finished check [present=" + present + ", absent="+ absent+ ']');
  info("Checking keySet consistency");
  for (int g=0; g < gridCount(); g++)   checkKeySet(grid(g));
}
