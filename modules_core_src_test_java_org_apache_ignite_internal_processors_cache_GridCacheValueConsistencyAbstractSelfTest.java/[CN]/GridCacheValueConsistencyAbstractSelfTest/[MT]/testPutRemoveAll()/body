{
  awaitPartitionMapExchange();
  IgniteCache<String,Integer> cache=jcache();
  int keyCnt=10;
  for (int i=0; i < keyCnt; i++) {
    info("Putting value to cache: " + i);
    cache.put("key" + i,i);
  }
  for (int g=0; g < gridCount(); g++) {
    IgniteCache<String,Integer> cache0=jcache(g);
    ClusterNode locNode=grid(g).localNode();
    for (int i=0; i < keyCnt; i++) {
      String key="key" + i;
      if (ignite(0).affinity(null).mapKeyToPrimaryAndBackups(key).contains(grid(g).localNode())) {
        info("Node is reported as affinity node for key [key=" + key + ", nodeId="+ locNode.id()+ ']');
        assertEquals((Integer)i,cache0.localPeek(key,CachePeekMode.ONHEAP));
      }
 else {
        info("Node is reported as NOT affinity node for key [key=" + key + ", nodeId="+ locNode.id()+ ']');
        if (distributionMode() == NEAR_PARTITIONED && cache == cache0)         assertEquals((Integer)i,cache0.localPeek(key,CachePeekMode.ONHEAP));
 else         assertNull(cache0.localPeek(key,CachePeekMode.ONHEAP));
      }
      assertEquals((Integer)i,cache0.get(key));
    }
  }
  for (int g=0; g < gridCount(); g++) {
    info(">>>> Removing all values form cache: " + g);
    jcache(g).removeAll();
  }
  info(">>>> Starting values check");
  for (int g=0; g < gridCount(); g++) {
    IgniteCache<String,Integer> cache0=jcache(g);
    for (int i=0; i < keyCnt; i++) {
      String key="key" + i;
      assertNull(cache0.localPeek(key,CachePeekMode.ONHEAP));
      assertNull(cache0.get(key));
    }
  }
}
