{
  awaitPartitionMapExchange();
  IgniteCache<String,Integer> cache=jcache();
  int keyCnt=10;
  for (int i=0; i < keyCnt; i++)   cache.put("key" + i,i);
  for (int g=0; g < gridCount(); g++) {
    IgniteCache<String,Integer> cache0=jcache(g);
    ClusterNode locNode=grid(g).localNode();
    for (int i=0; i < keyCnt; i++) {
      String key="key" + i;
      if (ignite(0).affinity(null).mapKeyToPrimaryAndBackups(key).contains(locNode)) {
        info("Node is reported as affinity node for key [key=" + key + ", nodeId="+ locNode.id()+ ']');
        assertEquals((Integer)i,cache0.localPeek(key,CachePeekMode.ONHEAP));
      }
 else {
        info("Node is reported as NOT affinity node for key [key=" + key + ", nodeId="+ locNode.id()+ ']');
        if (distributionMode() == NEAR_PARTITIONED && cache == cache0)         assertEquals((Integer)i,cache0.localPeek(key,CachePeekMode.ONHEAP));
 else         assertNull(cache0.localPeek(key,CachePeekMode.ONHEAP));
      }
      assertEquals((Integer)i,cache0.get(key));
    }
  }
  info("Removing values from cache.");
  for (int i=0; i < keyCnt; i++)   assertEquals((Integer)i,cache.getAndRemove("key" + i));
  for (int g=0; g < gridCount(); g++) {
    IgniteCache<String,Integer> cache0=jcache(g);
    for (int i=0; i < keyCnt; i++) {
      String key="key" + i;
      assertNull(cache0.localPeek(key,CachePeekMode.ONHEAP));
      assertNull(cache0.get(key));
    }
  }
}
