{
  int present=0;
  int absent=0;
  Affinity<Integer> aff=ignite(0).affinity(null);
  boolean invalidVal=false;
  for (int i=0; i < range; i++) {
    Long firstVal=null;
    for (int g=0; g < gridCount(); g++) {
      Ignite ignite=grid(g);
      Long val=(Long)ignite.cache(null).localPeek(i,CachePeekMode.ONHEAP);
      if (firstVal == null && val != null)       firstVal=val;
      if (val != null) {
        if (!firstVal.equals(val)) {
          invalidVal=true;
          boolean primary=aff.isPrimary(ignite.cluster().localNode(),i);
          boolean backup=aff.isBackup(ignite.cluster().localNode(),i);
          log.error("Invalid value detected [key=" + i + ", val="+ val+ ", firstVal="+ firstVal+ ", node="+ g+ ", primary="+ primary+ ", backup="+ backup+ ']');
          log.error("All values: ");
          printValues(aff,i);
          break;
        }
      }
    }
    if (firstVal == null)     absent++;
 else     present++;
  }
  assertFalse("Inconsistent value found.",invalidVal);
  info("Finished check [present=" + present + ", absent="+ absent+ ']');
  info("Checking keySet consistency");
  for (int g=0; g < gridCount(); g++)   checkKeySet(grid(g));
}
