{
  IgniteCache<TestKey,TestValue> cache=grid(0).jcache(null);
  Set<TestKey> keys=new LinkedHashSet<>();
  for (int i=0; i < ITER_CNT; i++) {
    TestKey key=new TestKey(i,i);
    keys.add(key);
    cache.put(key,new TestValue(i));
  }
  interceptor.delegate(new CacheInterceptorAdapter<TestKey,TestValue>(){
    @Override public TestValue onBeforePut(    Cache.Entry<TestKey,TestValue> entry,    TestValue newVal){
      assertEquals(entry.getKey().key(),entry.getKey().field());
      assertEquals(entry.getKey().key(),entry.getValue().val());
      entry.getKey().field(WRONG_VALUE);
      entry.getValue().val(WRONG_VALUE);
      return super.onBeforePut(entry,newVal);
    }
    @Override public void onAfterPut(    Cache.Entry<TestKey,TestValue> entry){
      assertEquals(entry.getKey().key(),entry.getKey().field());
      assertEquals(entry.getKey().key(),entry.getValue().val());
      entry.getValue().val(WRONG_VALUE);
      entry.getKey().field(WRONG_VALUE);
      super.onAfterPut(entry);
    }
  }
);
  cache.invokeAll(keys,new EntryProcessor<TestKey,TestValue,Object>(){
    @Override public Object process(    MutableEntry<TestKey,TestValue> entry,    Object... arguments) throws EntryProcessorException {
      assertEquals(entry.getKey().key(),entry.getKey().field());
      assertEquals(entry.getKey().key(),entry.getValue().val());
      entry.getKey().field(WRONG_VALUE);
      entry.getValue().val(WRONG_VALUE);
      return -1;
    }
  }
);
  for (  Cache.Entry<Object,Object> e : internalCache(0).entrySet()) {
    assertNotEquals(WRONG_VALUE,((TestKey)e.getKey()).field());
    assertNotEquals(WRONG_VALUE,((TestValue)e.getValue()).val());
  }
}
