{
  final AtomicInteger polled=new GridAtomicInteger();
  final AtomicInteger added=new GridAtomicInteger();
  GridFuture<?> fut=multithreadedAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      Random rnd=new Random();
      for (int i=0; i < iterCnt; i++) {
        if (i > 0 && i % 10000 == 0)         info("Finished " + i + " iterations");
        int op=rnd.nextInt(8);
switch (op) {
case 0:
{
            for (int j=0; j < 30; j++)             win.enqueue(rnd.nextInt(range));
            added.addAndGet(30);
            break;
          }
case 1:
{
          for (int j=0; j < 10; j++)           win.enqueue(rnd.nextInt(range),rnd.nextInt(range),rnd.nextInt(range),rnd.nextInt(range),rnd.nextInt(range),rnd.nextInt(range));
          added.addAndGet(10 * 6);
          break;
        }
case 2:
{
        Object o=win.pollEvicted();
        if (o != null)         polled.incrementAndGet();
        break;
      }
case 3:
{
      Collection<Integer> p0=win.pollEvicted(50);
      polled.addAndGet(p0.size());
      break;
    }
case 4:
{
    Collection<Integer> p0=win.pollEvictedBatch();
    polled.addAndGet(p0.size());
    break;
  }
case 5:
{
  Object o=win.dequeue();
  if (o != null)   polled.incrementAndGet();
  break;
}
case 6:
{
Collection<Integer> p0=win.dequeue(50);
polled.addAndGet(p0.size());
break;
}
case 7:
{
Iterator<Integer> it=win.iterator();
while (it.hasNext()) {
it.next();
if (rnd.nextInt(10) == 5) {
  it.remove();
  polled.incrementAndGet();
}
}
break;
}
}
}
return null;
}
}
,threadCnt);
fut.get();
info("Window size: " + win.size());
info("Added=" + added.get() + ", polled="+ polled.get());
}
