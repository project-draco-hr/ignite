{
  if (res.error() != null)   onError(res.error());
 else {
    if (nearMapping != null && !F.isEmpty(res.nearEvicted())) {
      for (      IgniteTxEntry entry : nearMapping.entries()) {
        if (res.nearEvicted().contains(entry.txKey())) {
          while (true) {
            try {
              GridDhtCacheEntry cached=(GridDhtCacheEntry)entry.cached();
              cached.removeReader(nearMapping.node().id(),res.messageId());
              break;
            }
 catch (            GridCacheEntryRemovedException ignore) {
              GridCacheEntryEx e=entry.context().cache().peekEx(entry.key());
              if (e == null)               break;
              entry.cached(e);
            }
          }
        }
      }
      nearMapping.evictReaders(res.nearEvicted());
    }
    if (!F.isEmpty(res.invalidPartitions())) {
      for (Iterator<IgniteTxEntry> it=dhtMapping.entries().iterator(); it.hasNext(); ) {
        IgniteTxEntry entry=it.next();
        if (res.invalidPartitions().contains(entry.cached().partition())) {
          it.remove();
          if (log.isDebugEnabled())           log.debug("Removed mapping for entry from dht mapping [key=" + entry.key() + ", tx="+ tx+ ", dhtMapping="+ dhtMapping+ ']');
        }
      }
    }
    if (!F.isEmpty(res.invalidPartitionsByCacheId())) {
      Map<Integer,int[]> invalidPartsMap=res.invalidPartitionsByCacheId();
      for (Iterator<IgniteTxEntry> it=dhtMapping.entries().iterator(); it.hasNext(); ) {
        IgniteTxEntry entry=it.next();
        int[] invalidParts=invalidPartsMap.get(entry.cacheId());
        if (invalidParts != null && F.contains(invalidParts,entry.cached().partition())) {
          it.remove();
          if (log.isDebugEnabled())           log.debug("Removed mapping for entry from dht mapping [key=" + entry.key() + ", tx="+ tx+ ", dhtMapping="+ dhtMapping+ ']');
        }
      }
      if (dhtMapping.empty()) {
        dhtMap.remove(nodeId);
        if (log.isDebugEnabled())         log.debug("Removed mapping for node entirely because all partitions are invalid [nodeId=" + nodeId + ", tx="+ tx+ ']');
      }
    }
    AffinityTopologyVersion topVer=tx.topologyVersion();
    boolean rec=cctx.gridEvents().isRecordable(EVT_CACHE_REBALANCE_OBJECT_LOADED);
    for (    GridCacheEntryInfo info : res.preloadEntries()) {
      GridCacheContext<?,?> cacheCtx=cctx.cacheContext(info.cacheId());
      while (true) {
        GridCacheEntryEx entry=cacheCtx.cache().entryEx(info.key());
        GridDrType drType=cacheCtx.isDrEnabled() ? GridDrType.DR_PRELOAD : GridDrType.DR_NONE;
        try {
          if (entry.initialValue(info.value(),info.version(),info.ttl(),info.expireTime(),true,topVer,drType)) {
            if (rec && !entry.isInternal())             cacheCtx.events().addEvent(entry.partition(),entry.key(),cctx.localNodeId(),(IgniteUuid)null,null,EVT_CACHE_REBALANCE_OBJECT_LOADED,info.value(),true,null,false,null,null,null);
            if (retVal && !invoke)             ret.value(cacheCtx,info.value());
          }
          break;
        }
 catch (        IgniteCheckedException e) {
          onDone(e);
          return;
        }
catch (        GridCacheEntryRemovedException ignore) {
          if (log.isDebugEnabled())           log.debug("Failed to set entry initial value (entry is obsolete, " + "will retry): " + entry);
        }
      }
    }
    onDone(tx);
  }
}
