{
  int locTxNum=nodeTransactions(cctx.localNodeId());
  if (locTxNum > 1 && !cctx.tm().txsPreparedOrCommitted(tx.nearXidVersion(),locTxNum)) {
    onDone(false);
    markInitialized();
    return;
  }
  for (  Map.Entry<UUID,Collection<UUID>> entry : txNodes.entrySet()) {
    UUID nodeId=entry.getKey();
    if (!nodes.containsKey(nodeId) && nodeId.equals(cctx.localNodeId()))     continue;
    if (nodeId.equals(failedNodeId)) {
      for (      UUID id : entry.getValue()) {
        if (txNodes.containsKey(id) || id.equals(cctx.localNodeId()))         continue;
        MiniFuture fut=new MiniFuture(id);
        add(fut);
        GridCacheOptimisticCheckPreparedTxRequest<K,V> req=new GridCacheOptimisticCheckPreparedTxRequest<>(tx,nodeTransactions(id),futureId(),fut.futureId());
        try {
          cctx.io().send(id,req);
        }
 catch (        ClusterTopologyException ignored) {
          fut.onNodeLeft();
        }
catch (        IgniteCheckedException e) {
          fut.onError(e);
          break;
        }
      }
    }
 else {
      MiniFuture fut=new MiniFuture(nodeId);
      add(fut);
      GridCacheOptimisticCheckPreparedTxRequest<K,V> req=new GridCacheOptimisticCheckPreparedTxRequest<>(tx,nodeTransactions(nodeId),futureId(),fut.futureId());
      try {
        cctx.io().send(nodeId,req);
      }
 catch (      ClusterTopologyException ignored) {
        fut.onNodeLeft();
      }
catch (      IgniteCheckedException e) {
        fut.onError(e);
        break;
      }
    }
  }
  markInitialized();
}
