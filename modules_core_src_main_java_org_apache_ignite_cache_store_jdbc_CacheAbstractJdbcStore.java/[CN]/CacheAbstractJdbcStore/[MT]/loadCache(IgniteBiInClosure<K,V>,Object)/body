{
  ExecutorService pool=null;
  String cacheName=session().cacheName();
  try {
    pool=Executors.newFixedThreadPool(maxPoolSize);
    Collection<Future<?>> futs=new ArrayList<>();
    Map<Object,EntryMapping> mappings=getOrCreateCacheMappings(cacheName);
    if (args != null && args.length > 0) {
      if (args.length % 2 != 0)       throw new CacheLoaderException("Expected even number of arguments, but found: " + args.length);
      if (log.isDebugEnabled())       log.debug("Start loading entries from db using user queries from arguments...");
      for (int i=0; i < args.length; i+=2) {
        String keyType=args[i].toString();
        String selQry=args[i + 1].toString();
        EntryMapping em=entryMapping(cacheName,typeIdForTypeName(kindForName(keyType),keyType));
        futs.add(pool.submit(new LoadCacheCustomQueryWorker<>(em,selQry,clo)));
      }
    }
 else {
      Collection<EntryMapping> entryMappings=mappings.values();
      for (      EntryMapping em : entryMappings) {
        if (parallelLoadCacheMinThreshold > 0) {
          Connection conn=null;
          try {
            conn=connection();
            PreparedStatement stmt=conn.prepareStatement(em.loadCacheSelRangeQry);
            stmt.setInt(1,parallelLoadCacheMinThreshold);
            ResultSet rs=stmt.executeQuery();
            if (rs.next()) {
              if (log.isDebugEnabled())               log.debug("Multithread loading entries from db [cache=" + U.maskName(cacheName) + ", keyType="+ em.keyType()+ " ]");
              int keyCnt=em.keyCols.size();
              Object[] upperBound=new Object[keyCnt];
              for (int i=0; i < keyCnt; i++)               upperBound[i]=rs.getObject(i + 1);
              futs.add(pool.submit(loadCacheRange(em,clo,null,upperBound,0)));
              while (rs.next()) {
                Object[] lowerBound=upperBound;
                upperBound=new Object[keyCnt];
                for (int i=0; i < keyCnt; i++)                 upperBound[i]=rs.getObject(i + 1);
                futs.add(pool.submit(loadCacheRange(em,clo,lowerBound,upperBound,0)));
              }
              futs.add(pool.submit(loadCacheRange(em,clo,upperBound,null,0)));
              continue;
            }
          }
 catch (          SQLException e) {
            log.warning("Failed to load entries from db in multithreaded mode [cache=" + U.maskName(cacheName) + ", keyType="+ em.keyType()+ " ]",e);
          }
 finally {
            U.closeQuiet(conn);
          }
        }
        if (log.isDebugEnabled())         log.debug("Single thread loading entries from db [cache=" + U.maskName(cacheName) + ", keyType="+ em.keyType()+ " ]");
        futs.add(pool.submit(loadCacheFull(em,clo)));
      }
    }
    for (    Future<?> fut : futs)     U.get(fut);
    if (log.isDebugEnabled())     log.debug("Cache loaded from db: " + U.maskName(cacheName));
  }
 catch (  IgniteCheckedException e) {
    throw new CacheLoaderException("Failed to load cache: " + U.maskName(cacheName),e.getCause());
  }
 finally {
    U.shutdownNow(getClass(),pool,log);
  }
}
