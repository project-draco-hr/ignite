{
  Map<Object,EntryMapping> entryMappings=cacheMappings.get(cacheName);
  if (entryMappings != null)   return entryMappings;
  cacheMappingsLock.lock();
  try {
    entryMappings=cacheMappings.get(cacheName);
    if (entryMappings != null)     return entryMappings;
    CacheConfiguration ccfg=ignite().jcache(cacheName).getConfiguration(CacheConfiguration.class);
    Collection<CacheTypeMetadata> types=ccfg.getTypeMetadata();
    entryMappings=U.newHashMap(types.size());
    for (    CacheTypeMetadata type : types) {
      Object keyTypeId=keyTypeId(type.getKeyType());
      if (entryMappings.containsKey(keyTypeId))       throw new CacheException("Key type must be unique in type metadata [cache name=" + cacheName + ", key type="+ type.getKeyType()+ "]");
      checkMapping(cacheName,type.getKeyType(),type.getKeyFields());
      checkMapping(cacheName,type.getValueType(),type.getValueFields());
      entryMappings.put(keyTypeId(type.getKeyType()),new EntryMapping(cacheName,dialect,type));
    }
    Map<String,Map<Object,EntryMapping>> mappings=new HashMap<>(cacheMappings);
    mappings.put(cacheName,entryMappings);
    prepareBuilders(cacheName,types);
    cacheMappings=mappings;
    return entryMappings;
  }
  finally {
    cacheMappingsLock.unlock();
  }
}
