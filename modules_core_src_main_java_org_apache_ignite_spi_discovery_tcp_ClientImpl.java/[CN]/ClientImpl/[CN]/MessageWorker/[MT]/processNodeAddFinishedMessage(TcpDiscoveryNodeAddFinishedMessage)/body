{
  if (spi.getSpiContext().isStopping())   return;
  if (getLocalNodeId().equals(msg.nodeId())) {
    if (joinLatch.getCount() > 0) {
      Map<UUID,Map<Integer,byte[]>> dataMap=msg.clientDiscoData();
      if (dataMap != null) {
        for (        Map.Entry<UUID,Map<Integer,byte[]>> entry : dataMap.entrySet())         spi.onExchange(getLocalNodeId(),entry.getKey(),entry.getValue(),null);
      }
      locNode.setAttributes(msg.clientNodeAttributes());
      locNode.visible(true);
      long topVer=msg.topologyVersion();
      locNode.order(topVer);
      notifyDiscovery(EVT_NODE_JOINED,topVer,locNode,updateTopologyHistory(topVer,msg));
      joinErr=null;
      joinLatch.countDown();
      spi.stats.onJoinFinished();
    }
 else     if (log.isDebugEnabled())     log.debug("Discarding node add finished message (this message has already been processed) " + "[msg=" + msg + ", locNode="+ locNode+ ']');
  }
 else {
    TcpDiscoveryNode node=rmtNodes.get(msg.nodeId());
    if (node == null) {
      if (log.isDebugEnabled())       log.debug("Discarding node add finished message since node is not found [msg=" + msg + ']');
      return;
    }
    if (!topHist.isEmpty() && msg.topologyVersion() <= topHist.lastKey()) {
      if (log.isDebugEnabled())       log.debug("Discarding node add finished message since topology already updated " + "[msg=" + msg + ", lastHistKey="+ topHist.lastKey()+ ", node="+ node+ ']');
      return;
    }
    long topVer=msg.topologyVersion();
    node.order(topVer);
    node.visible(true);
    if (spi.locNodeVer.equals(node.version()))     node.version(spi.locNodeVer);
    NavigableSet<ClusterNode> top=updateTopologyHistory(topVer,msg);
    if (!pending && joinLatch.getCount() > 0) {
      if (log.isDebugEnabled())       log.debug("Discarding node add finished message (join process is not finished): " + msg);
      return;
    }
    notifyDiscovery(EVT_NODE_JOINED,topVer,node,top);
    spi.stats.onNodeJoined();
  }
}
