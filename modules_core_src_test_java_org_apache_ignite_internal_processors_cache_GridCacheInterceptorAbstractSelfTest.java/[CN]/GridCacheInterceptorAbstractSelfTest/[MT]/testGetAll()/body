{
  Set<String> keys=new LinkedHashSet<>();
  for (int i=0; i < 1000; i++)   keys.add(String.valueOf(i));
  interceptor.retInterceptor=new InterceptorAdapter(){
    @Nullable @Override public Object onGet(    Object key,    Object val){
      return null;
    }
  }
;
  IgniteCache<String,Integer> cache=jcache(0);
  IgniteCache<String,Integer> cacheAsync=cache.withAsync();
  Map<String,Integer> map=cache.getAll(keys);
  for (  String key : keys)   assertEquals(null,map.get(key));
  assertEquals(1000,interceptor.invokeCnt.get());
  interceptor.reset();
  interceptor.retInterceptor=new InterceptorAdapter(){
    @Nullable @Override public Object onGet(    Object key,    Object val){
      int k=Integer.valueOf((String)key);
      return k % 2 == 0 ? null : (k * 2);
    }
  }
;
  map=cache.getAll(keys);
  for (  String key : keys) {
    int k=Integer.valueOf(key);
    if (k % 2 == 0)     assertEquals(null,map.get(key));
 else     assertEquals((Integer)(k * 2),map.get(key));
  }
  assertEquals(1000,interceptor.invokeCnt.get());
  interceptor.disabled=true;
  for (int i=0; i < 500; i++)   cache.put(String.valueOf(i),i);
  interceptor.disabled=false;
  for (int j=0; j < 2; j++) {
    interceptor.reset();
    interceptor.retInterceptor=new InterceptorAdapter(){
      @Nullable @Override public Object onGet(      Object key,      Object val){
        int k=Integer.valueOf((String)key);
switch (k % 3) {
case 0:
          return null;
case 1:
        return val;
case 2:
      return k * 3;
default :
    fail();
}
return null;
}
}
;
if (j == 0) map=cache.getAll(keys);
 else {
cacheAsync.getAll(keys);
map=cacheAsync.<Map<String,Integer>>future().get();
}
int i=0;
for (String key : keys) {
switch (i % 3) {
case 0:
assertEquals(null,map.get(key));
break;
case 1:
Integer exp=i < 500 ? i : null;
assertEquals(exp,map.get(key));
break;
case 2:
assertEquals((Integer)(i * 3),map.get(key));
break;
default :
fail();
}
i++;
}
assertEquals(1000,interceptor.invokeCnt.get());
}
}
