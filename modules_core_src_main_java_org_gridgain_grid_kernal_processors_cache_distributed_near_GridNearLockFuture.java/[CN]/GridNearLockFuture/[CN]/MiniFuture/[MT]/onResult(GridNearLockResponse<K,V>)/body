{
  if (rcvRes.compareAndSet(false,true)) {
    if (res.error() != null) {
      if (log.isDebugEnabled())       log.debug("Finishing mini future with an error due to error in response [miniFut=" + this + ", res="+ res+ ']');
      if (res.error() instanceof GridCacheLockTimeoutException)       onDone(false);
 else       onDone(res.error());
      return;
    }
    int i=0;
    long topVer=topSnapshot.get().topologyVersion();
    for (    K k : keys) {
      while (true) {
        GridNearCacheEntry<K,V> entry=cctx.near().entryExx(k,topVer);
        try {
          if (res.dhtVersion(i) == null) {
            onDone(new IgniteCheckedException("Failed to receive DHT version from remote node " + "(will fail the lock): " + res));
            return;
          }
          GridTuple3<GridCacheVersion,V,byte[]> oldValTup=valMap.get(entry.key());
          V oldVal=entry.rawGet();
          boolean hasOldVal=false;
          V newVal=res.value(i);
          byte[] newBytes=res.valueBytes(i);
          boolean readRecordable=false;
          if (retval) {
            readRecordable=cctx.events().isRecordable(EVT_CACHE_OBJECT_READ);
            if (readRecordable)             hasOldVal=entry.hasValue();
          }
          GridCacheVersion dhtVer=res.dhtVersion(i);
          GridCacheVersion mappedVer=res.mappedVersion(i);
          if (newVal == null) {
            if (oldValTup != null) {
              if (oldValTup.get1().equals(dhtVer)) {
                newVal=oldValTup.get2();
                newBytes=oldValTup.get3();
              }
              oldVal=oldValTup.get2();
            }
          }
          entry.resetFromPrimary(newVal,newBytes,lockVer,dhtVer,node.id());
          if (inTx() && implicitTx() && tx.onePhaseCommit()) {
            boolean pass=res.filterResult(i);
            tx.entry(cctx.txKey(k)).filters(pass ? CU.<K,V>empty() : CU.<K,V>alwaysFalse());
          }
          entry.readyNearLock(lockVer,mappedVer,res.committedVersions(),res.rolledbackVersions(),res.pending());
          if (retval) {
            if (readRecordable)             cctx.events().addEvent(entry.partition(),entry.key(),tx,null,EVT_CACHE_OBJECT_READ,newVal,newVal != null || newBytes != null,oldVal,hasOldVal,CU.subjectId(tx,cctx.shared()),null,inTx() ? tx.resolveTaskName() : null);
            cctx.cache().metrics0().onRead(false);
          }
          if (log.isDebugEnabled())           log.debug("Processed response for entry [res=" + res + ", entry="+ entry+ ']');
          break;
        }
 catch (        GridCacheEntryRemovedException ignored) {
          if (log.isDebugEnabled())           log.debug("Failed to add candidates because entry was removed (will renew).");
          entries.set(i,(GridDistributedCacheEntry<K,V>)cctx.cache().entryEx(entry.key()));
        }
catch (        IgniteCheckedException e) {
          onDone(e);
          return;
        }
      }
      i++;
    }
    try {
      proceedMapping(mappings);
    }
 catch (    IgniteCheckedException e) {
      onDone(e);
    }
    onDone(true);
  }
}
