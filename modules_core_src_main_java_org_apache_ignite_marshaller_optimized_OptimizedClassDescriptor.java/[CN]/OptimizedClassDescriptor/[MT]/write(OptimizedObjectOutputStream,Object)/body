{
switch (type) {
case TYPE_BYTE:
    out.writeByte((Byte)obj);
  break;
case TYPE_SHORT:
out.writeShort((Short)obj);
break;
case TYPE_INT:
out.writeInt((Integer)obj);
break;
case TYPE_LONG:
out.writeLong((Long)obj);
break;
case TYPE_FLOAT:
out.writeFloat((Float)obj);
break;
case TYPE_DOUBLE:
out.writeDouble((Double)obj);
break;
case TYPE_CHAR:
out.writeChar((Character)obj);
break;
case TYPE_BOOLEAN:
out.writeBoolean((Boolean)obj);
break;
case TYPE_BYTE_ARR:
out.writeByteArray((byte[])obj);
break;
case TYPE_SHORT_ARR:
out.writeShortArray((short[])obj);
break;
case TYPE_INT_ARR:
out.writeIntArray((int[])obj);
break;
case TYPE_LONG_ARR:
out.writeLongArray((long[])obj);
break;
case TYPE_FLOAT_ARR:
out.writeFloatArray((float[])obj);
break;
case TYPE_DOUBLE_ARR:
out.writeDoubleArray((double[])obj);
break;
case TYPE_CHAR_ARR:
out.writeCharArray((char[])obj);
break;
case TYPE_BOOLEAN_ARR:
out.writeBooleanArray((boolean[])obj);
break;
case TYPE_OBJ_ARR:
out.writeArray((Object[])obj);
break;
case TYPE_STR:
out.writeString((String)obj);
break;
case TYPE_ENUM:
out.writeInt(((Enum)obj).ordinal());
break;
case TYPE_UUID:
out.writeUuid((UUID)obj);
break;
case TYPE_PROPS:
out.writeProperties((Properties)obj,dfltsFieldOff);
break;
case TYPE_ARRAY_LIST:
out.writeArrayList((ArrayList<?>)obj);
break;
case TYPE_HASH_MAP:
out.writeHashMap((HashMap<?,?>)obj,loadFactorFieldOff,false);
break;
case TYPE_HASH_SET:
out.writeHashSet((HashSet<?>)obj,mapFieldOff,loadFactorFieldOff);
break;
case TYPE_LINKED_LIST:
out.writeLinkedList((LinkedList<?>)obj);
break;
case TYPE_LINKED_HASH_MAP:
out.writeLinkedHashMap((LinkedHashMap<?,?>)obj,loadFactorFieldOff,accessOrderFieldOff,false);
break;
case TYPE_LINKED_HASH_SET:
out.writeLinkedHashSet((LinkedHashSet<?>)obj,mapFieldOff,loadFactorFieldOff);
break;
case TYPE_DATE:
out.writeDate((Date)obj);
break;
case TYPE_CLS:
OptimizedClassResolver.writeClass(out,OptimizedMarshallerUtils.classDescriptor((Class<?>)obj,obj));
break;
case TYPE_EXTERNALIZABLE:
out.writeExternalizable(obj);
break;
case TYPE_SERIALIZABLE:
if (out.requireSerializable() && !isSerial) throw new NotSerializableException("Must implement java.io.Serializable or " + "set OptimizedMarshaller.setRequireSerializable() to false " + "(note that performance may degrade if object is not Serializable): "+ name);
out.writeSerializable(obj,writeObjMtds,fields);
break;
default :
throw new IllegalStateException("Invalid class type: " + type);
}
}
