{
  if (!swapEnabled() && !offHeapEnabled())   return new GridEmptyCloseableIterator<>();
  checkIteratorQueue();
  if (offHeapEnabled() && !swapEnabled())   return rawOffHeapIterator(true,true);
  if (swapEnabled() && !offHeapEnabled())   return rawSwapIterator(true,true);
  return new GridCloseableIteratorAdapter<Map.Entry<byte[],byte[]>>(){
    private GridCloseableIterator<Map.Entry<byte[],byte[]>> it;
    private boolean offheapFlag=true;
    private boolean done;
    private Map.Entry<byte[],byte[]> cur;
{
      it=rawOffHeapIterator(true,true);
      advance();
    }
    private void advance() throws IgniteCheckedException {
      if (it.hasNext())       return;
      it.close();
      if (offheapFlag) {
        offheapFlag=false;
        it=rawSwapIterator(true,true);
        if (!it.hasNext()) {
          it.close();
          done=true;
        }
      }
 else       done=true;
    }
    @Override protected Map.Entry<byte[],byte[]> onNext() throws IgniteCheckedException {
      if (done)       throw new NoSuchElementException();
      cur=it.next();
      advance();
      return cur;
    }
    @Override protected boolean onHasNext(){
      return !done;
    }
    @Override protected void onRemove() throws IgniteCheckedException {
      if (offheapFlag) {
        KeyCacheObject key=cctx.toCacheKeyObject(cur.getKey());
        int part=cctx.affinity().partition(key);
        boolean rmv=offheap.removex(spaceName,part,key,key.valueBytes(cctx.cacheObjectContext()));
        if (rmv && cctx.config().isStatisticsEnabled())         cctx.cache().metrics0().onOffHeapRemove();
      }
 else       it.removeX();
    }
    @Override protected void onClose() throws IgniteCheckedException {
      if (it != null)       it.close();
    }
  }
;
}
