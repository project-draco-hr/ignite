{
  if (!offheapEnabled && !swapEnabled)   return Collections.emptyList();
  checkIteratorQueue();
  final GridCacheQueryManager<K,V> qryMgr=cctx.queries();
  Collection<? extends K> unprocessedKeys;
  final Collection<GridCacheBatchSwapEntry<K,V>> res=new ArrayList<>(keys.size());
  if (offheapEnabled) {
    Collection<K> unprocessedKeysList=new ArrayList<>(keys.size());
    for (    K key : keys) {
      int part=cctx.affinity().partition(key);
      byte[] keyBytes=CU.marshal(cctx.shared(),key);
      byte[] entryBytes=offheap.remove(spaceName,part,key,keyBytes);
      if (entryBytes != null) {
        GridCacheSwapEntry<V> entry=swapEntry(unmarshalSwapEntry(entryBytes));
        if (entry != null) {
          onOffHeaped(part,key,keyBytes,entry);
          if (cctx.events().isRecordable(EVT_CACHE_OBJECT_FROM_OFFHEAP))           cctx.events().addEvent(part,key,cctx.nodeId(),(IgniteUuid)null,null,EVT_CACHE_OBJECT_FROM_OFFHEAP,null,false,null,true,null,null,null);
          if (qryMgr != null)           qryMgr.onUnswap(key,entry.value(),entry.valueBytes());
          GridCacheBatchSwapEntry<K,V> unswapped=new GridCacheBatchSwapEntry<>(key,keyBytes,part,ByteBuffer.wrap(entry.valueBytes()),entry.valueIsByteArray(),entry.version(),entry.ttl(),entry.expireTime(),entry.keyClassLoaderId(),entry.valueClassLoaderId());
          unswapped.value(entry.value());
          res.add(unswapped);
          continue;
        }
      }
      unprocessedKeysList.add(key);
    }
    unprocessedKeys=unprocessedKeysList;
    if (!swapEnabled || unprocessedKeys.isEmpty())     return res;
  }
 else   unprocessedKeys=keys;
  final GridTuple<IgniteCheckedException> err=F.t1();
  Collection<SwapKey> converted=new ArrayList<>(F.viewReadOnly(unprocessedKeys,new C1<K,SwapKey>(){
    @Override public SwapKey apply(    K key){
      try {
        return new SwapKey(key,cctx.affinity().partition(key),CU.marshal(cctx.shared(),key));
      }
 catch (      IgniteCheckedException e) {
        throw new IgniteException(e);
      }
    }
  }
));
  swapMgr.removeAll(spaceName,converted,new IgniteBiInClosure<SwapKey,byte[]>(){
    @Override public void apply(    SwapKey swapKey,    byte[] rmv){
      if (rmv != null) {
        try {
          GridCacheSwapEntry<V> entry=swapEntry(unmarshalSwapEntry(rmv));
          if (entry == null)           return;
          K key=(K)swapKey.key();
          GridCacheBatchSwapEntry<K,V> unswapped=new GridCacheBatchSwapEntry<>(key,swapKey.keyBytes(),swapKey.partition(),ByteBuffer.wrap(entry.valueBytes()),entry.valueIsByteArray(),entry.version(),entry.ttl(),entry.expireTime(),entry.keyClassLoaderId(),entry.valueClassLoaderId());
          unswapped.value(entry.value());
          res.add(unswapped);
          if (cctx.events().isRecordable(EVT_CACHE_OBJECT_UNSWAPPED))           cctx.events().addEvent(swapKey.partition(),key,cctx.nodeId(),(IgniteUuid)null,null,EVT_CACHE_OBJECT_UNSWAPPED,null,false,entry.value(),true,null,null,null);
          onUnswapped(swapKey.partition(),key,swapKey.keyBytes(),entry);
          if (qryMgr != null)           qryMgr.onUnswap(key,entry.value(),entry.valueBytes());
        }
 catch (        IgniteCheckedException e) {
          err.set(e);
        }
      }
    }
  }
,cctx.deploy().globalLoader());
  if (err.get() != null)   throw err.get();
  return res;
}
