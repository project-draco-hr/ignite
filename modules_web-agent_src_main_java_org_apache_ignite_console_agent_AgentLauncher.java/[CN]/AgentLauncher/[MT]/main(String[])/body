{
  log.info("Starting Apache Ignite Web Console Agent...");
  final AgentConfiguration cfg=new AgentConfiguration();
  JCommander jCommander=new JCommander(cfg);
  String osName=System.getProperty("os.name").toLowerCase();
  jCommander.setProgramName("ignite-web-agent." + (osName.contains("win") ? "bat" : "sh"));
  try {
    jCommander.parse(args);
  }
 catch (  ParameterException pe) {
    log.error("Failed to parse command line parameters: " + Arrays.toString(args),pe);
    jCommander.usage();
    return;
  }
  String prop=cfg.configPath();
  AgentConfiguration propCfg=new AgentConfiguration();
  try {
    File f=AgentUtils.resolvePath(prop);
    if (f == null)     log.warn("Failed to find agent property file: " + prop);
 else     propCfg.load(f.toURI().toURL());
  }
 catch (  IOException ignore) {
    if (!AgentConfiguration.DFLT_CFG_PATH.equals(prop))     log.warn("Failed to load agent property file: " + prop,ignore);
  }
  cfg.merge(propCfg);
  if (cfg.help()) {
    jCommander.usage();
    return;
  }
  System.out.println();
  System.out.println("Agent configuration:");
  System.out.println(cfg);
  System.out.println();
  if (cfg.token() == null) {
    String webHost;
    try {
      webHost=new URI(cfg.serverUri()).getHost();
    }
 catch (    URISyntaxException e) {
      log.error("Failed to parse Ignite Web Console uri",e);
      return;
    }
    System.out.println("Security token is required to establish connection to the web console.");
    System.out.println(String.format("It is available on the Profile page: https://%s/profile",webHost));
    System.out.print("Enter security token: ");
    cfg.token(System.console().readLine().trim());
  }
  final RestHandler restHnd=new RestHandler(cfg);
  try {
    restHnd.start();
    URI uri=URI.create(cfg.serverUri());
    if (uri.getPort() == -1)     uri=URI.create(cfg.serverUri() + ':' + DFLT_SERVER_PORT);
    IO.Options opts=new IO.Options();
    opts.reconnectionDelay=RECONNECT_INTERVAL;
    if (Boolean.getBoolean("trust.all")) {
      SSLContext ctx=SSLContext.getInstance("TLS");
      ctx.init(null,getTrustManagers(),null);
      opts.sslContext=ctx;
    }
    final Socket client=IO.socket(uri,opts);
    try {
      Emitter.Listener onConnecting=new Emitter.Listener(){
        @Override public void call(        Object... args){
          log.info("Connecting to: " + cfg.serverUri());
        }
      }
;
      Emitter.Listener onConnect=new Emitter.Listener(){
        @Override public void call(        Object... args){
          log.info("Connection established.");
          JSONObject authMsg=new JSONObject();
          try {
            authMsg.put("token",cfg.token());
            String clsName=AgentLauncher.class.getSimpleName() + ".class";
            String clsPath=AgentLauncher.class.getResource(clsName).toString();
            if (clsPath.startsWith("jar")) {
              String manifestPath=clsPath.substring(0,clsPath.lastIndexOf('!') + 1) + "/META-INF/MANIFEST.MF";
              Manifest manifest=new Manifest(new URL(manifestPath).openStream());
              Attributes attr=manifest.getMainAttributes();
              authMsg.put("ver",attr.getValue("Implementation-Version"));
              authMsg.put("bt",attr.getValue("Build-Time"));
            }
            client.emit("agent:auth",authMsg,new Ack(){
              @Override public void call(              Object... args){
                if (args != null && args.length > 0) {
                  onDisconnect.call("Authentication failed: " + args[0]);
                  System.exit(1);
                }
                log.info("Authentication success.");
              }
            }
);
          }
 catch (          JSONException|IOException e) {
            log.error("Failed to construct authentication message",e);
            client.close();
          }
        }
      }
;
      DatabaseHandler dbHnd=new DatabaseHandler(cfg);
      final CountDownLatch latch=new CountDownLatch(1);
      client.on(EVENT_CONNECTING,onConnecting).on(EVENT_CONNECT,onConnect).on(EVENT_CONNECT_ERROR,onError).on(EVENT_RECONNECTING,onConnecting).on(EVENT_NODE_REST,restHnd).on(EVENT_SCHEMA_IMPORT_DRIVERS,dbHnd.availableDriversListener()).on(EVENT_SCHEMA_IMPORT_SCHEMAS,dbHnd.schemasListener()).on(EVENT_SCHEMA_IMPORT_METADATA,dbHnd.metadataListener()).on(EVENT_ERROR,onError).on(EVENT_DISCONNECT,onDisconnect).on(EVENT_AGENT_CLOSE,new Emitter.Listener(){
        @Override public void call(        Object... args){
          onDisconnect.call(args);
          client.off();
          latch.countDown();
        }
      }
);
      client.connect();
      latch.await();
    }
  finally {
      client.close();
    }
  }
  finally {
    restHnd.stop();
  }
}
