{
synchronized (nR) {
    final int hR=nR.height;
    if (hL0 - hR >= -1) {
      return n;
    }
 else {
      final Node<K,V> nRL=nR.unsharedLeft();
      final int hRL0=height(nRL);
      final int hRR0=height(nR.right);
      if (hRR0 >= hRL0) {
        return rotateLeft_nl(nParent,n,hL0,nR,nRL,hRL0,hRR0);
      }
 else {
synchronized (nRL) {
          final int hRL=nRL.height;
          if (hRR0 >= hRL) {
            return rotateLeft_nl(nParent,n,hL0,nR,nRL,hRL,hRR0);
          }
 else {
            final int hRLR=height(nRL.right);
            final int b=hRR0 - hRLR;
            if (b >= -1 && b <= 1 && !((hRR0 == 0 || hRLR == 0) && nR.vOpt == null)) {
              return rotateLeftOverRight_nl(nParent,n,hL0,nR,nRL,hRR0,hRLR);
            }
          }
        }
        return rebalanceToRight_nl(n,nR,nRL,hRR0);
      }
    }
  }
}
