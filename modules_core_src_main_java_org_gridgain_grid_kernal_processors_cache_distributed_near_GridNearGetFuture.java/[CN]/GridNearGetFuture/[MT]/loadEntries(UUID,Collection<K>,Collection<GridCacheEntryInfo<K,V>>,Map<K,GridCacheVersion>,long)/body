{
  boolean empty=F.isEmpty(keys);
  Map<K,V> map=empty ? Collections.<K,V>emptyMap() : new GridLeanMap<K,V>(keys.size());
  if (!empty) {
    boolean atomic=cctx.atomic();
    GridCacheVersion ver=atomic ? null : F.isEmpty(infos) ? null : cctx.versions().next();
    for (    GridCacheEntryInfo<K,V> info : infos) {
      try {
        info.unmarshalValue(cctx,cctx.deploy().globalLoader());
        if (!cctx.cache().affinity().isPrimaryOrBackup(cctx.localNode(),info.key())) {
          GridNearCacheEntry<K,V> entry=cache().entryExx(info.key(),topVer);
          GridCacheVersion saved=savedVers.get(info.key());
          entry.loadedValue(tx,nodeId,info.value(),info.valueBytes(),atomic ? info.version() : ver,info.version(),saved,info.ttl(),info.expireTime(),true,topVer,subjId);
        }
      }
 catch (      GridCacheEntryRemovedException ignore) {
        if (log.isDebugEnabled())         log.debug("Got removed entry while processing get response (will not retry).");
      }
catch (      GridException e) {
        onDone(e);
        return Collections.emptyMap();
      }
      V val=info.value();
      if (deserializePortable && val instanceof GridPortableObject) {
        try {
          val=((GridPortableObject)val).deserialize();
        }
 catch (        GridPortableException e) {
          throw new GridRuntimeException(e);
        }
      }
      map.put(info.key(),val);
    }
  }
  return map;
}
