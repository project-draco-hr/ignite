{
  ProcessStartResult clientStartRes=startSharedMemoryTestClient();
  IpcSharedMemoryClientEndpoint clientEndpoint=(IpcSharedMemoryClientEndpoint)srv.accept();
  Collection<Integer> shmemIds=new ArrayList<>();
  InputStream is=null;
  int interactionsCntBeforeClientKilling=5;
  int i=1;
  try {
    is=clientEndpoint.inputStream();
    shmemIds.add(clientEndpoint.inSpace().sharedMemoryId());
    shmemIds.add(clientEndpoint.outSpace().sharedMemoryId());
    for (; i < interactionsCntBeforeClientKilling * 2; i++) {
      info("Before read.");
      is.read();
      Thread.sleep(RW_SLEEP_TIMEOUT);
      if (killClient && i == interactionsCntBeforeClientKilling) {
        info("Going to kill client.");
        clientStartRes.proc().kill();
      }
    }
  }
 catch (  IOException e) {
    assertTrue("No IOException should be thrown if we do not kill client.",killClient);
    assertTrue("No IOException should be thrown before client is killed.",i > interactionsCntBeforeClientKilling);
    assertTrue(X.hasCause(e,IgniteCheckedException.class));
    assertTrue(X.cause(e,IgniteCheckedException.class).getMessage().contains("Shared memory segment has been closed"));
    clientStartRes.isKilledLatch().await();
    return shmemIds;
  }
 finally {
    U.closeQuiet(is);
  }
  assertTrue("Interactions count should be bigger than interactionsCntBeforeClientKilling if we do not kill client.",i > interactionsCntBeforeClientKilling);
  clientStartRes.proc().kill();
  clientStartRes.isKilledLatch().await();
  assertFalse("No IOException have been thrown while the client should be killed.",killClient);
  return shmemIds;
}
