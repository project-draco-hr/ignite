{
  final Random rnd=new Random();
  final LinkedBlockingQueue<UUID> queue=new LinkedBlockingQueue<>();
  multithreaded(new Callable<Object>(){
    @Override public Object call() throws Exception {
      for (int i=0; i < 1000; i++) {
        IgniteTx tx=rnd.nextBoolean() ? new DummyTx() : null;
        int op=rnd.nextInt(10);
        boolean queueEmpty=false;
        if (op < 4) {
          UUID key=queue.poll();
          if (key == null)           queueEmpty=true;
 else {
            if (rnd.nextBoolean())             assertNotNull(store.load(tx,key));
 else {
              final AtomicInteger cntr=new AtomicInteger();
              store.loadAll(tx,Collections.singleton(key),new CI2<Object,Object>(){
                @Override public void apply(                Object o,                Object o1){
                  cntr.incrementAndGet();
                  assertNotNull(o);
                  assertNotNull(o1);
                  UUID key=(UUID)o;
                  UUID val=(UUID)o1;
                  assertTrue(key.equals(val) || (key.getMostSignificantBits() == val.getLeastSignificantBits() && key.getLeastSignificantBits() == val.getMostSignificantBits()));
                }
              }
);
              assertEquals(1,cntr.get());
            }
            if (tx != null)             store.txEnd(tx,true);
            queue.add(key);
          }
        }
 else         if (op < 6) {
          UUID key=queue.poll();
          if (key == null)           queueEmpty=true;
 else {
            if (rnd.nextBoolean())             store.remove(tx,key);
 else             store.removeAll(tx,Collections.singleton(key));
            if (tx != null)             store.txEnd(tx,true);
          }
        }
 else {
          UUID key=queue.poll();
          if (key == null)           queueEmpty=true;
 else {
            UUID val=new UUID(key.getLeastSignificantBits(),key.getMostSignificantBits());
            if (rnd.nextBoolean())             store.put(tx,key,val);
 else             store.putAll(tx,Collections.singletonMap(key,val));
            if (tx != null)             store.txEnd(tx,true);
            queue.add(key);
          }
        }
        if (queueEmpty) {
          UUID key=UUID.randomUUID();
          if (rnd.nextBoolean())           store.put(tx,key,key);
 else           store.putAll(tx,Collections.singletonMap(key,key));
          if (tx != null)           store.txEnd(tx,true);
          queue.add(key);
        }
      }
      return null;
    }
  }
,37);
}
