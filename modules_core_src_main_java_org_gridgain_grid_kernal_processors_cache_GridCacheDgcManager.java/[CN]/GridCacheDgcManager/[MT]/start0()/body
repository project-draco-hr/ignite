{
  if (cctx.config().getCacheMode() == LOCAL || cctx.config().getAtomicityMode() == ATOMIC)   return;
  traceLog=log.getLogger(DGC_TRACE_LOGGER_NAME);
  if (traceLogged.compareAndSet(false,true)) {
    if (traceLog.isDebugEnabled())     traceLog.debug("DGC trace log enabled.");
 else     U.log(log,"DGC trace log disabled.");
  }
  dgcFreq=cctx.config().getDgcFrequency();
  A.ensure(dgcFreq >= 0,"dgcFreq cannot be negative");
  dgcSuspectLockTimeout=cctx.config().getDgcSuspectLockTimeout();
  A.ensure(dgcSuspectLockTimeout >= 0,"dgcSuspiciousLockTimeout cannot be negative");
  if (dgcFreq > 0 && log.isDebugEnabled()) {
    log.debug("Locks older than " + dgcSuspectLockTimeout + " ms. "+ "will be implicitly removed in case they are not present on lock owner nodes. "+ "To change this behavior please configure 'dgcFrequency' and 'dgcSuspectLockTimeout' "+ "cache configuration properties.");
  }
  reqThread=new GridThread(reqWorker=new RequestWorker());
  reqThread.start();
  resThread=new GridThread(resWorker=new ResponseWorker());
  resThread.start();
  cctx.io().addHandler(GridCacheDgcRequest.class,reqHnd);
  cctx.io().addHandler(GridCacheDgcResponse.class,resHnd);
  if (log.isDebugEnabled())   log.debug("Started DGC manager " + "[dgcFreq=" + dgcFreq + ", suspectLockTimeout="+ dgcSuspectLockTimeout+ ']');
}
