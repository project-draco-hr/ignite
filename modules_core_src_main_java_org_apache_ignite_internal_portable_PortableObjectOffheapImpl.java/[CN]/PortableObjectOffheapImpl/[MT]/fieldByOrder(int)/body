{
  Object val;
  int schemaOffset=PortablePrimitives.readInt(ptr,start + GridPortableMarshaller.SCHEMA_OR_RAW_OFF_POS);
  short flags=PortablePrimitives.readShort(ptr,start + GridPortableMarshaller.FLAGS_POS);
  int fieldOffsetSize=PortableUtils.fieldOffsetSize(flags);
  int fieldOffsetPos=start + schemaOffset + order * (4 + fieldOffsetSize) + 4;
  int fieldPos;
  if (fieldOffsetSize == PortableUtils.OFFSET_1)   fieldPos=start + ((int)PortablePrimitives.readByte(ptr,fieldOffsetPos) & 0xFF);
 else   if (fieldOffsetSize == PortableUtils.OFFSET_2)   fieldPos=start + ((int)PortablePrimitives.readShort(ptr,fieldOffsetPos) & 0xFFFF);
 else   fieldPos=start + PortablePrimitives.readInt(ptr,fieldOffsetPos);
  byte hdr=PortablePrimitives.readByte(ptr,fieldPos);
switch (hdr) {
case INT:
    val=PortablePrimitives.readInt(ptr,fieldPos + 1);
  break;
case LONG:
val=PortablePrimitives.readLong(ptr,fieldPos + 1);
break;
case BOOLEAN:
val=PortablePrimitives.readBoolean(ptr,fieldPos + 1);
break;
case SHORT:
val=PortablePrimitives.readShort(ptr,fieldPos + 1);
break;
case BYTE:
val=PortablePrimitives.readByte(ptr,fieldPos + 1);
break;
case CHAR:
val=PortablePrimitives.readChar(ptr,fieldPos + 1);
break;
case FLOAT:
val=PortablePrimitives.readFloat(ptr,fieldPos + 1);
break;
case DOUBLE:
val=PortablePrimitives.readDouble(ptr,fieldPos + 1);
break;
case STRING:
{
boolean utf=PortablePrimitives.readBoolean(ptr,fieldPos + 1);
if (utf) {
int dataLen=PortablePrimitives.readInt(ptr,fieldPos + 2);
byte[] data=PortablePrimitives.readByteArray(ptr,fieldPos + 6,dataLen);
val=new String(data,UTF_8);
}
 else {
int dataLen=PortablePrimitives.readInt(ptr,fieldPos + 2);
char[] data=PortablePrimitives.readCharArray(ptr,fieldPos + 6,dataLen);
val=String.valueOf(data);
}
break;
}
case DATE:
{
long time=PortablePrimitives.readLong(ptr,fieldPos + 1);
val=new Date(time);
break;
}
case TIMESTAMP:
{
long time=PortablePrimitives.readLong(ptr,fieldPos + 1);
int nanos=PortablePrimitives.readInt(ptr,fieldPos + 1 + 8);
Timestamp ts=new Timestamp(time);
ts.setNanos(ts.getNanos() + nanos);
val=ts;
break;
}
case UUID:
{
long most=PortablePrimitives.readLong(ptr,fieldPos + 1);
long least=PortablePrimitives.readLong(ptr,fieldPos + 1 + 8);
val=new UUID(most,least);
break;
}
case DECIMAL:
{
int scale=PortablePrimitives.readInt(ptr,fieldPos + 1);
int dataLen=PortablePrimitives.readInt(ptr,fieldPos + 5);
byte[] data=PortablePrimitives.readByteArray(ptr,fieldPos + 9,dataLen);
BigInteger intVal=new BigInteger(data);
if (scale < 0) {
scale&=0x7FFFFFFF;
intVal=intVal.negate();
}
val=new BigDecimal(intVal,scale);
break;
}
case NULL:
val=null;
break;
default :
{
PortableReaderExImpl reader=new PortableReaderExImpl(ctx,new PortableOffheapInputStream(ptr,size,false),start,null);
val=reader.unmarshalFieldByAbsolutePosition(fieldPos);
}
}
return (F)val;
}
