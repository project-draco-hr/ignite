{
  final int keyCnt=5000;
  final int logFreq=500;
  final GridCacheAdapter<String,Integer> c=internalCache(jcache());
  final CountDownLatch startLatch=new CountDownLatch(1);
  IgniteInternalFuture<?> fut1=multithreadedAsync(new Callable(){
    @Override public Object call() throws Exception {
      for (int i=1; i < keyCnt; i++) {
        c.getAndPut(String.valueOf(i),i);
        startLatch.countDown();
        if (i % logFreq == 0)         info("Stored entries: " + i);
      }
      return null;
    }
  }
,1);
  final CacheQuery<List<?>> sumQry=c.context().queries().createSqlFieldsQuery("select _val from Integer",false).timeout(TEST_TIMEOUT);
  final R1<List<?>,Integer> rmtRdc=new R1<List<?>,Integer>(){
    /** 
 */
    private AtomicInteger sum=new AtomicInteger();
    @Override public boolean collect(    List<?> e){
      sum.addAndGet((Integer)e.get(0));
      return true;
    }
    @Override public Integer reduce(){
      return sum.get();
    }
  }
;
  final AtomicBoolean stop=new AtomicBoolean();
  startLatch.await();
  IgniteInternalFuture<?> fut2=multithreadedAsync(new Callable(){
    @Override public Object call() throws Exception {
      int cnt=0;
      while (!stop.get()) {
        Collection<Integer> res=sumQry.execute(rmtRdc).get();
        int sum=F.sumInt(res);
        cnt++;
        assertTrue(sum > 0);
        if (cnt % logFreq == 0) {
          info("Reduced value: " + sum);
          info("Executed queries: " + cnt);
        }
      }
      return null;
    }
  }
,1);
  fut1.get();
  stop.set(true);
  fut2.get();
}
