{
  if (log.isDebugEnabled())   log.debug("Processing node failed event [locNodeId=" + cctx.localNodeId() + ", failedNodeId="+ evtNodeId+ ']');
  for (  GridCacheTxEx<K,V> tx : idMap.values()) {
    if ((tx.near() && !tx.local()) || (cctx.isStoreEnabled() && tx.masterNodeIds().contains(evtNodeId))) {
      salvageTx(tx,false,RECOVERY_FINISH);
    }
 else     if (tx.optimistic()) {
      if (tx.originatingNodeId().equals(evtNodeId)) {
        if (tx.state() == PREPARED)         commitIfPrepared(tx);
 else {
          if (tx.setRollbackOnly())           tx.rollbackAsync();
        }
      }
    }
 else {
      if (tx.originatingNodeId().equals(evtNodeId)) {
        if (tx.state() != COMMITTING && tx.state() != COMMITTED) {
          commitIfRemotelyCommitted(tx);
        }
 else {
          if (log.isDebugEnabled())           log.debug("Skipping pessimistic transaction check (transaction is being committed) " + "[tx=" + tx + ", locNodeId="+ cctx.localNodeId()+ ']');
        }
      }
 else {
        if (log.isDebugEnabled())         log.debug("Skipping pessimistic transaction check [tx=" + tx + ", evtNodeId="+ evtNodeId+ ", locNodeId="+ cctx.localNodeId()+ ']');
      }
    }
  }
}
