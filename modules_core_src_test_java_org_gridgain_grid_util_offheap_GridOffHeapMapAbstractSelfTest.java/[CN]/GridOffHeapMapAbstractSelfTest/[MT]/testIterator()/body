{
  initCap=10;
  map=newMap();
  final AtomicInteger rehashes=new AtomicInteger();
  final AtomicInteger releases=new AtomicInteger();
  map.eventListener(new GridOffHeapEventListener(){
    @Override public void onEvent(    GridOffHeapEvent evt){
switch (evt) {
case REHASH:
        rehashes.incrementAndGet();
      break;
case RELEASE:
    releases.incrementAndGet();
  break;
default :
}
}
}
);
int max=1024;
Map<String,String> m=new HashMap<>(max);
for (int i=0; i < max; i++) {
String key=string();
String val=string();
assertTrue(map.put(hash(key),key.getBytes(),val.getBytes()));
assertTrue(map.contains(hash(key),key.getBytes()));
assertNotNull(map.get(hash(key),key.getBytes()));
assertEquals(new String(map.get(hash(key),key.getBytes())),val);
m.put(key,val);
int cnt=0;
try (GridCloseableIterator<GridBiTuple<byte[],byte[]>> it=map.iterator(null)){
while (it.hasNext()) {
GridBiTuple<byte[],byte[]> t=it.next();
String k=new String(t.get1());
String v=new String(t.get2());
assertEquals(m.get(k),v);
cnt++;
}
}
 assertEquals(map.size(),cnt);
}
assertEquals(max,map.size());
info("Stats [size=" + map.size() + ", rehashes="+ rehashes+ ", releases="+ releases+ ']');
assertTrue(rehashes.get() > 0);
assertEquals(rehashes.get(),releases.get());
}
