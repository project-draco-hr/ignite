{
  GridCacheMvccCandidate<K> cand=cctx.mvcc().explicitLock(threadId,entry.key());
  if (inTx()) {
    GridCacheTxEntry<K,V> txEntry=tx.entry(entry.txKey());
    txEntry.cached(entry,txEntry.keyBytes());
    if (cand != null) {
      if (!tx.implicit())       throw new IgniteCheckedException("Cannot access key within transaction if lock is " + "externally held [key=" + entry.key() + ", entry="+ entry+ ']');
 else       return null;
    }
 else {
      cand=new GridCacheMvccCandidate<>(entry,cctx.localNodeId(),null,null,threadId,lockVer,timeout,true,tx.entry(entry.txKey()).locked(),inTx(),inTx() && tx.implicitSingle(),false,false);
      cand.topologyVersion(topSnapshot.get().topologyVersion());
    }
  }
 else {
    if (cand == null) {
      cand=new GridCacheMvccCandidate<>(entry,cctx.localNodeId(),null,null,threadId,lockVer,timeout,true,false,inTx(),inTx() && tx.implicitSingle(),false,false);
      cand.topologyVersion(topSnapshot.get().topologyVersion());
    }
 else     cand=cand.reenter();
    cctx.mvcc().addExplicitLock(threadId,cand,topSnapshot.get());
  }
  return cand;
}
