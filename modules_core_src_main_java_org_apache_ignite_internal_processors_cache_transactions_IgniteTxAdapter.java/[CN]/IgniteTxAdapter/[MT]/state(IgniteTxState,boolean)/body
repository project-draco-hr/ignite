{
  boolean valid=false;
  IgniteTxState prev;
  boolean notify=false;
  lock();
  try {
    prev=this.state;
switch (state) {
case ACTIVE:
{
        valid=false;
        break;
      }
case PREPARING:
{
      valid=prev == ACTIVE;
      break;
    }
case PREPARED:
{
    valid=prev == PREPARING;
    break;
  }
case COMMITTING:
{
  valid=prev == PREPARED;
  break;
}
case UNKNOWN:
{
if (isDone.compareAndSet(false,true)) notify=true;
valid=prev == ROLLING_BACK || prev == COMMITTING;
break;
}
case COMMITTED:
{
if (isDone.compareAndSet(false,true)) notify=true;
valid=prev == COMMITTING;
break;
}
case ROLLED_BACK:
{
if (isDone.compareAndSet(false,true)) notify=true;
valid=prev == ROLLING_BACK;
break;
}
case MARKED_ROLLBACK:
{
valid=prev == ACTIVE || prev == PREPARING || prev == PREPARED || prev == COMMITTING;
break;
}
case ROLLING_BACK:
{
valid=prev == ACTIVE || prev == MARKED_ROLLBACK || prev == PREPARING || prev == PREPARED || (prev == COMMITTING && local() && !dht());
break;
}
}
if (valid) {
this.state=state;
this.timedOut=timedOut;
if (log.isDebugEnabled()) log.debug("Changed transaction state [prev=" + prev + ", new="+ this.state+ ", tx="+ this+ ']');
signalAll();
}
 else {
if (log.isDebugEnabled()) log.debug("Invalid transaction state transition [invalid=" + state + ", cur="+ this.state+ ", tx="+ this+ ']');
}
}
  finally {
unlock();
}
if (notify) {
GridFutureAdapter<IgniteTxEx> fut=finFut.get();
if (fut != null) fut.onDone(this);
}
if (valid) {
if (state != ACTIVE) seal();
cctx.tm().onTxStateChange(prev,state,this);
}
return valid;
}
