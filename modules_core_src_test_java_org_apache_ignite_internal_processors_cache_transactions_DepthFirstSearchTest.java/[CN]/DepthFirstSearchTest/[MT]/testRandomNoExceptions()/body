{
  int maxNodesCnt=100;
  int minNodesCnt=10;
  int maxWaitForNodesCnt=20;
  int cyclesFound=0;
  int cyclesNotFound=0;
  Random seedRnd=new Random();
  Random rnd=new Random();
  for (int i=0; i < 50000; i++) {
    long seed=seedRnd.nextLong();
    rnd.setSeed(seed);
    System.out.println(">>> Iteration " + i + " with seed "+ seed);
    int nodesCnt=rnd.nextInt(maxNodesCnt - minNodesCnt) + minNodesCnt;
    Map<GridCacheVersion,Set<GridCacheVersion>> wfg=new HashMap<>();
    for (int j=0; j < nodesCnt; j++) {
      if (rnd.nextInt(100) > 30) {
        int waitForNodesCnt=rnd.nextInt(maxWaitForNodesCnt);
        Set<GridCacheVersion> waitForNodes=null;
        if (waitForNodesCnt > 0) {
          waitForNodes=new LinkedHashSet<>();
          for (int k=0; k < waitForNodesCnt; ) {
            int n=rnd.nextInt(nodesCnt);
            if (n != j) {
              waitForNodes.add(new GridCacheVersion(n,0,0,0));
              k++;
            }
          }
        }
        wfg.put(new GridCacheVersion(j,0,0,0),waitForNodes);
      }
    }
    for (int j=0; j < nodesCnt; j++) {
      try {
        List<GridCacheVersion> cycle=findCycle(wfg,new GridCacheVersion(j,0,0,0));
        if (cycle == null)         cyclesNotFound++;
 else         cyclesFound++;
      }
 catch (      Throwable e) {
        U.error(null,"Error during finding cycle in graph: ",e);
        U.warn(null,"Seed: " + seed);
        U.warn(null,"Wait-for-graph: " + wfg);
        fail();
      }
    }
  }
  System.out.println(">>> Test finished. Cycles found: " + cyclesFound + ", cycles not found: "+ cyclesNotFound);
}
