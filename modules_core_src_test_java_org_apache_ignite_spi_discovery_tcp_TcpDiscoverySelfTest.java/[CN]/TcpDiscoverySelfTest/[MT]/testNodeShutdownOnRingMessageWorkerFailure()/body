{
  try {
    TestMessageWorkerFailureSpi1 spi0=new TestMessageWorkerFailureSpi1();
    nodeSpi.set(spi0);
    final Ignite ignite0=startGrid(0);
    nodeSpi.set(new TcpDiscoverySpi());
    Ignite ignite1=startGrid(1);
    final AtomicBoolean disconnected=new AtomicBoolean();
    final CountDownLatch latch=new CountDownLatch(1);
    final UUID failedNodeId=ignite0.cluster().localNode().id();
    ignite1.events().localListen(new IgnitePredicate<Event>(){
      @Override public boolean apply(      Event evt){
        if (evt.type() == EventType.EVT_NODE_FAILED && failedNodeId.equals(((DiscoveryEvent)evt).eventNode().id()))         disconnected.set(true);
        latch.countDown();
        return false;
      }
    }
,EventType.EVT_NODE_FAILED);
    spi0.stop=true;
    latch.await(15,TimeUnit.SECONDS);
    assertTrue(disconnected.get());
    try {
      ignite0.cluster().localNode().id();
    }
 catch (    IllegalStateException e) {
      if (e.getMessage().contains("Grid is in invalid state to perform this operation"))       return;
    }
    fail();
  }
  finally {
    stopAllGrids();
  }
}
