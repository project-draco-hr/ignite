{
  GridReplicatedTxPrepareFuture<K,V> fut=prepareFut.get();
  if (fut == null) {
    Collection<GridNode> nodeGrp=resolveNodes();
    topologyVersion(cctx.discovery().topologyVersion());
    if (!prepareFut.compareAndSet(null,fut=new GridReplicatedTxPrepareFuture<>(cctx,this,nodeGrp)))     return prepareFut.get();
  }
 else   return fut;
  if (!state(PREPARING)) {
    if (setRollbackOnly()) {
      if (timedOut())       fut.onError(new GridCacheTxTimeoutException("Transaction timed out and was rolled back: " + this));
 else       fut.onError(new GridException("Invalid transaction state for prepare [state=" + state() + ", tx="+ this+ ']'));
    }
 else     fut.onError(new GridCacheTxRollbackException("Invalid transaction state for prepare [state=" + state() + ", tx="+ this+ ']'));
    return fut;
  }
  if (pessimistic()) {
    try {
      userPrepare();
      if (!state(PREPARED)) {
        setRollbackOnly();
        fut.onError(new GridException("Invalid transaction state for commit [state=" + state() + ", tx="+ this+ ']'));
        return fut;
      }
      fut.complete();
      return fut;
    }
 catch (    GridException e) {
      fut.onError(e);
      return fut;
    }
  }
  GridFuture<Object> preloadFut=cctx.preloader().request(F.viewReadOnly(F.concat(false,readEntries(),writeEntries()),CU.<K,V>tx2key()),topologyVersion());
  if (preloadFut.isDone()) {
    try {
      preloadFut.get();
      prepareAsync0(fut);
    }
 catch (    GridException e) {
      fut.onError(e);
    }
    return fut;
  }
  final GridReplicatedTxPrepareFuture<K,V> fut0=fut;
  return new GridEmbeddedFuture<>(true,preloadFut,new C2<Object,Exception,GridFuture<GridCacheTxEx<K,V>>>(){
    @Override public GridFuture<GridCacheTxEx<K,V>> apply(    Object o,    Exception err){
      if (err != null)       fut0.onError(err);
 else       prepareAsync0(fut0);
      return fut0;
    }
  }
,cctx.kernalContext());
}
