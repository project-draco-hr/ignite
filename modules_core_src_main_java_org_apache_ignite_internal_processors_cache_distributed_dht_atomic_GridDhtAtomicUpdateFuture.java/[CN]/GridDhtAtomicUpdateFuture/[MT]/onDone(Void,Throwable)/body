{
  if (super.onDone(res,err)) {
    cctx.mvcc().removeAtomicFuture(version());
    if (err != null) {
      if (!mappings.isEmpty() && lsnrs != null) {
        Collection<KeyCacheObject> hndKeys=new ArrayList<>(keys.size());
        exit:         for (        GridDhtAtomicUpdateRequest req : mappings.values()) {
          for (int i=0; i < req.size(); i++) {
            KeyCacheObject key=req.key(i);
            if (!hndKeys.contains(key)) {
              updateRes.addFailedKey(key,err);
              cctx.continuousQueries().skipUpdateEvent(lsnrs,key,req.partitionId(i),req.updateCounter(i),updateReq.topologyVersion());
              hndKeys.add(key);
              if (hndKeys.size() == keys.size())               break exit;
            }
          }
        }
      }
 else       for (      KeyCacheObject key : keys)       updateRes.addFailedKey(key,err);
    }
 else {
      if (lsnrs != null) {
        Collection<KeyCacheObject> hndKeys=new ArrayList<>(keys.size());
        exit:         for (        GridDhtAtomicUpdateRequest req : mappings.values()) {
          for (int i=0; i < req.size(); i++) {
            KeyCacheObject key=req.key(i);
            if (!hndKeys.contains(key)) {
              try {
                cctx.continuousQueries().onEntryUpdated(lsnrs,key,req.value(i),req.localPreviousValue(i),key.internal() || !cctx.userCache(),req.partitionId(i),true,false,req.updateCounter(i),updateReq.topologyVersion());
              }
 catch (              IgniteCheckedException e) {
                U.warn(log,"Failed to send continuous query message. [key=" + key + ", newVal="+ req.value(i)+ ", err="+ e+ "]");
              }
              hndKeys.add(key);
              if (hndKeys.size() == keys.size())               break exit;
            }
          }
        }
      }
    }
    if (updateReq.writeSynchronizationMode() == FULL_SYNC)     completionCb.apply(updateReq,updateRes);
    return true;
  }
  return false;
}
