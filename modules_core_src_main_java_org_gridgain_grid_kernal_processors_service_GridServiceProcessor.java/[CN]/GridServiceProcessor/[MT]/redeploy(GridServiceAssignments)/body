{
  String svcName=assigns.name();
  Integer assignCnt=assigns.assigns().get(ctx.localNodeId());
  if (assignCnt == null)   assignCnt=0;
  GridService svc=assigns.service();
  Collection<GridServiceContextImpl> ctxs;
synchronized (locSvcs) {
    ctxs=locSvcs.get(svcName);
    if (ctxs == null)     locSvcs.put(svcName,ctxs=new ArrayList<>());
  }
synchronized (ctxs) {
    if (ctxs.size() > assignCnt) {
      int cancelCnt=ctxs.size() - assignCnt;
      cancel(ctxs,cancelCnt);
    }
 else     if (ctxs.size() < assignCnt) {
      int createCnt=assignCnt - ctxs.size();
      for (int i=0; i < createCnt; i++) {
        final GridService copy=copyAndInject(svc);
        final ExecutorService exe=Executors.newSingleThreadExecutor(threadFactory);
        final GridServiceContextImpl svcCtx=new GridServiceContextImpl(assigns.name(),UUID.randomUUID(),assigns.cacheName(),assigns.affinityKey(),copy,exe);
        ctxs.add(svcCtx);
        if (log.isInfoEnabled())         log.info("Starting service instance [name=" + svcCtx.name() + ", execId="+ svcCtx.executionId()+ ']');
        exe.submit(new Runnable(){
          @Override public void run(){
            try {
              copy.execute(svcCtx);
            }
 catch (            Throwable e) {
              log.error("Service execution stopped with error [name=" + svcCtx.name() + ", execId="+ svcCtx.executionId()+ ']',e);
            }
 finally {
              exe.shutdownNow();
              try {
                ctx.resource().cleanup(copy);
              }
 catch (              GridException e) {
                log.error("Failed to clean up service (will ignore): " + svcCtx.name(),e);
              }
            }
          }
        }
);
      }
    }
  }
}
