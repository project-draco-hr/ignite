{
  int max=waitJobsThreshold + activeJobsThreshold;
  if (max < 0)   max=Integer.MAX_VALUE;
  int jobsToSteal=max - (waitJobs.size() + activeJobs.size());
  if (log.isDebugEnabled())   log.debug("Total number of jobs to be stolen: " + jobsToSteal);
  if (jobsToSteal > 0) {
    int jobsLeft=jobsToSteal;
    GridNode next;
    int nodeCnt=getSpiContext().remoteNodes().size();
    int idx=0;
    while (jobsLeft > 0 && idx++ < nodeCnt && (next=nodeQueue.poll()) != null) {
      if (getSpiContext().node(next.id()) == null)       continue;
      if (!F.isEmpty(stealAttrs) && (next.attributes() == null || !U.containsAll(next.attributes(),stealAttrs))) {
        if (log.isDebugEnabled())         log.debug("Skip node as it does not have all attributes: " + next.id());
        continue;
      }
      int delta=0;
      try {
        MessageInfo msgInfo=sndMsgMap.get(next.id());
        if (msgInfo == null) {
          if (log.isDebugEnabled())           log.debug("Failed to find message info for node: " + next.id());
          continue;
        }
        Integer waitThreshold=next.attribute(createSpiAttributeName(WAIT_JOBS_THRESHOLD_NODE_ATTR));
        if (waitThreshold == null) {
          U.error(log,"Remote node is not configured with GridJobStealingCollisionSpi and " + "jobs will not be stolen from it (you must stop it and update its configuration to use " + "GridJobStealingCollisionSpi): "+ next);
          continue;
        }
        delta=next.metrics().getCurrentWaitingJobs() - waitThreshold;
        if (log.isDebugEnabled())         log.debug("Maximum number of jobs to steal from node [jobsToSteal=" + delta + ", node="+ next.id()+ ']');
        if (delta <= 0)         continue;
synchronized (msgInfo) {
          if (!msgInfo.expired() && msgInfo.jobsToSteal() > 0) {
            jobsLeft-=msgInfo.jobsToSteal();
            continue;
          }
          if (jobsLeft < delta)           delta=jobsLeft;
          jobsLeft-=delta;
          msgInfo.reset(delta);
        }
        getSpiContext().send(next,new GridJobStealingRequest(delta),JOB_STEALING_COMM_TOPIC);
      }
 catch (      GridSpiException e) {
        U.error(log,"Failed to send job stealing message to node: " + next,e);
        jobsLeft+=delta;
      }
 finally {
        if (getSpiContext().node(next.id()) != null)         nodeQueue.offer(next);
      }
    }
  }
}
