{
  interceptor=new RebalanceUpdateInterceptor();
  for (int iter=0; iter < TEST_ITERATIONS; iter++) {
    log.info("Iteration: " + iter);
    failed=false;
    final IgniteEx ignite=startGrid(1);
    final IgniteCache<Integer,Integer> cache=ignite.cache(CACHE_NAME);
    for (int i=0; i < CNT; i++)     cache.put(i,i);
    final CountDownLatch latch=new CountDownLatch(1);
    final IgniteInternalFuture<Object> updFut=GridTestUtils.runAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        latch.await();
        for (int j=1; j <= 3; j++) {
          for (int i=0; i < CNT; i++) {
            if (i % 2 == 0) {
              try (Transaction tx=ignite.transactions().txStart(PESSIMISTIC,REPEATABLE_READ)){
                operation.run(cache,i,i + j);
                tx.commit();
              }
             }
 else             operation.run(cache,i,i + j);
          }
        }
        return null;
      }
    }
);
    final IgniteInternalFuture<Object> rebFut=GridTestUtils.runAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        latch.await();
        for (int i=2; i < NODES; i++)         startGrid(i);
        return null;
      }
    }
);
    latch.countDown();
    updFut.get();
    rebFut.get();
    stopAllGrids();
    assertFalse(failed);
  }
}
