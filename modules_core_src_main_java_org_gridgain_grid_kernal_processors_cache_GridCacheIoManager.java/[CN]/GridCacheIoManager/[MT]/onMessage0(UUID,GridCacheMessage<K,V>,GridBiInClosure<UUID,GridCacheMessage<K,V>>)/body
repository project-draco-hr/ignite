{
  rw.readLock();
  try {
    if (stopping) {
      if (log.isDebugEnabled())       log.debug("Received cache communication message while stopping (will ignore) [nodeId=" + nodeId + ", msg="+ cacheMsg+ ']');
      return;
    }
    if (depEnabled)     cctx.deploy().ignoreOwnership(true);
    unmarshall(nodeId,cacheMsg);
    if (cacheMsg.allowForStartup())     processMessage(nodeId,cacheMsg,c);
 else {
      GridFuture<?> startFut=cctx.preloader().startFuture();
      if (startFut.isDone())       processMessage(nodeId,cacheMsg,c);
 else {
        if (log.isDebugEnabled())         log.debug("Waiting for start future to complete for message [nodeId=" + nodeId + ", locId="+ cctx.nodeId()+ ", msg="+ cacheMsg+ ']');
        startFut.listenAsync(new CI1<GridFuture<?>>(){
          @Override public void apply(          GridFuture<?> f){
            rw.readLock();
            try {
              if (stopping) {
                if (log.isDebugEnabled())                 log.debug("Received cache communication message while stopping " + "(will ignore) [nodeId=" + nodeId + ", msg="+ cacheMsg+ ']');
                return;
              }
              f.get();
              if (log.isDebugEnabled())               log.debug("Start future completed for message [nodeId=" + nodeId + ", locId="+ cctx.nodeId()+ ", msg="+ cacheMsg+ ']');
              processMessage(nodeId,cacheMsg,c);
            }
 catch (            GridException e) {
              if (startErr.compareAndSet(false,true))               U.error(log,"Failed to complete preload start future (will ignore message) " + "[fut=" + f + ", nodeId="+ nodeId+ ", msg="+ cacheMsg+ ']',e);
            }
 finally {
              rw.readUnlock();
            }
          }
        }
);
      }
    }
  }
 catch (  Throwable e) {
    if (CU.isUtilityCache(cctx.name()) && X.hasCause(e,ClassNotFoundException.class))     U.error(log,"Failed processing message (note that distributed services " + "do not support peerClassLoadingEnabled flag, if you deploy distributed service " + "you should add all required classes to CLASSPATH on remote node) [senderId=" + nodeId + ']',e);
 else     U.error(log,"Failed processing message [senderId=" + nodeId + ']',e);
  }
 finally {
    if (depEnabled)     cctx.deploy().ignoreOwnership(false);
    rw.readUnlock();
  }
}
