{
  String overrideMcastGrp=System.getProperty(GG_OVERRIDE_MCAST_GRP);
  if (overrideMcastGrp != null)   mcastGrp=overrideMcastGrp;
  if (F.isEmpty(mcastGrp))   throw new GridSpiException("Multicast IP address is not specified.");
  if (mcastPort < 0 || mcastPort > 65535)   throw new GridSpiException("Invalid multicast port: " + mcastPort);
  if (resWaitTime <= 0)   throw new GridSpiException("Invalid wait time, value greater than zero is expected: " + resWaitTime);
  if (addrReqAttempts <= 0)   throw new GridSpiException("Invalid number of address request attempts, " + "value greater than zero is expected: " + addrReqAttempts);
  if (F.isEmpty(getRegisteredAddresses()))   U.warn(log,"GridTcpDiscoveryMulticastIpFinder has no pre-configured addresses " + "(it is recommended in production to specify at least one address in " + "GridTcpDiscoveryMulticastIpFinder.getAddresses() configuration property)");
  InetAddress mcastAddr;
  try {
    mcastAddr=InetAddress.getByName(mcastGrp);
  }
 catch (  UnknownHostException e) {
    throw new GridSpiException("Unknown multicast group: " + mcastGrp,e);
  }
  if (!mcastAddr.isMulticastAddress())   throw new GridSpiException("Invalid multicast group address: " + mcastAddr);
  Collection<String> locAddrs;
  try {
    locAddrs=U.resolveLocalAddresses(U.resolveLocalHost(locAddr)).get1();
  }
 catch (  IOException|GridException e) {
    throw new GridSpiException("Failed to resolve local addresses [locAddr=" + locAddr + ']',e);
  }
  addrSnds=new ArrayList<>(locAddrs.size());
  Collection<InetAddress> reqItfs=new ArrayList<>(locAddrs.size());
  for (  String locAddr : locAddrs) {
    InetAddress addr;
    try {
      addr=InetAddress.getByName(locAddr);
    }
 catch (    UnknownHostException e) {
      if (log.isDebugEnabled())       log.debug("Failed to resolve local address [locAddr=" + locAddr + ", err="+ e+ ']');
      continue;
    }
    if (!addr.isLoopbackAddress()) {
      try {
        addrSnds.add(new AddressSender(mcastAddr,addr,addrs));
        reqItfs.add(addr);
      }
 catch (      IOException e) {
        if (log.isDebugEnabled())         log.debug("Failed to create multicast socket [mcastAddr=" + mcastAddr + ", mcastGrp="+ mcastGrp+ ", mcastPort="+ mcastPort+ ", locAddr="+ addr+ ", err="+ e+ ']');
      }
    }
  }
  if (addrSnds.isEmpty()) {
    try {
      addrSnds.add(new AddressSender(mcastAddr,null,addrs));
    }
 catch (    IOException e) {
      throw new GridSpiException("Failed to create multicast socket [mcastAddr=" + mcastAddr + ", mcastGrp="+ mcastGrp+ ", mcastPort="+ mcastPort+ ']',e);
    }
  }
  for (  AddressSender addrSnd : addrSnds)   addrSnd.start();
  Collection<InetSocketAddress> ret;
  if (reqItfs.size() > 1) {
    ret=new HashSet<>();
    Collection<AddressReceiver> rcvrs=new ArrayList<>();
    for (    InetAddress itf : reqItfs) {
      AddressReceiver rcvr=new AddressReceiver(mcastAddr,itf);
      rcvr.start();
      rcvrs.add(rcvr);
    }
    for (    AddressReceiver rcvr : rcvrs) {
      try {
        rcvr.join();
        ret.addAll(rcvr.addresses());
      }
 catch (      InterruptedException ignore) {
        U.warn(log,"Got interrupted while receiving address request.");
        Thread.currentThread().interrupt();
        break;
      }
    }
  }
 else   ret=requestAddresses(mcastAddr,F.first(reqItfs));
  if (!ret.isEmpty())   registerAddresses(ret);
}
