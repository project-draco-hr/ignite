{
  log.info("Check transform.");
  Grid grid0=grid(0);
  GridCache<Integer,Integer> cache0=grid0.cache(null);
  GridCacheAffinity<Integer> aff=cache0.affinity();
  UUID id0=grid0.localNode().id();
  Integer primaryKey=key(grid0,PRIMARY);
  log.info("Transform from primary.");
  cache0.transform(primaryKey,new TransformClosure(primaryKey));
  for (int i=0; i < GRID_CNT; i++)   checkEntry(grid(i),primaryKey,primaryKey,false);
  if (backups > 0) {
    Integer backupKey=key(grid0,BACKUP);
    log.info("Transform from backup.");
    cache0.transform(backupKey,new TransformClosure(backupKey));
    for (int i=0; i < GRID_CNT; i++)     checkEntry(grid(i),backupKey,backupKey,false);
  }
  Integer nearKey=key(grid0,NOT_PRIMARY_AND_BACKUP);
  log.info("Transform from near.");
  cache0.transform(nearKey,new TransformClosure(nearKey));
  for (int i=0; i < GRID_CNT; i++) {
    UUID[] expReaders=aff.isPrimary(grid(i).localNode(),nearKey) ? new UUID[]{id0} : new UUID[]{};
    checkEntry(grid(i),nearKey,nearKey,i == 0,expReaders);
  }
  Collection<UUID> readers=new HashSet<>();
  readers.add(id0);
  int val=nearKey + 1;
  for (int i=0; i < GRID_CNT; i++) {
    delay();
    GridCache<Integer,Integer> cache=grid(i).cache(null);
    log.info("Transform [grid=" + grid(i).name() + ", val="+ val+ ']');
    cache.transform(nearKey,new TransformClosure(val));
    if (!aff.isPrimaryOrBackup(grid(i).localNode(),nearKey))     readers.add(grid(i).localNode().id());
    for (int j=0; j < GRID_CNT; j++) {
      boolean primaryNode=aff.isPrimary(grid(j).localNode(),nearKey);
      UUID[] expReaders=primaryNode ? U.toArray(readers,new UUID[readers.size()]) : new UUID[]{};
      checkEntry(grid(j),nearKey,val,readers.contains(grid(j).localNode().id()),expReaders);
    }
    val++;
  }
}
