{
  HashEntry[] oldTbl=tbl;
  int oldCap=oldTbl.length;
  if (oldCap >= MAX_CAP)   return;
  HashEntry[] newTbl=new HashEntry[oldCap << 1];
  threshold=(int)(newTbl.length * loadFactor);
  int sizeMask=newTbl.length - 1;
  for (int i=0; i < oldCap; i++) {
    HashEntry e=oldTbl[i];
    if (e != null) {
      HashEntry next=e.next;
      int idx=e.mapEntry.hash() & sizeMask;
      if (next == null)       newTbl[idx]=e;
 else {
        HashEntry lastRun=e;
        int lastIdx=idx;
        for (HashEntry last=next; last != null; last=last.next) {
          int k=last.mapEntry.hash() & sizeMask;
          if (k != lastIdx) {
            lastIdx=k;
            lastRun=last;
          }
        }
        newTbl[lastIdx]=lastRun;
        for (HashEntry p=e; p != lastRun; p=p.next) {
          int k=p.mapEntry.hash() & sizeMask;
          HashEntry n=newTbl[k];
          newTbl[k]=new HashEntry(p.mapEntry,n);
        }
      }
    }
  }
  tbl=newTbl;
  if (DEBUG)   checkSegmentConsistency();
}
