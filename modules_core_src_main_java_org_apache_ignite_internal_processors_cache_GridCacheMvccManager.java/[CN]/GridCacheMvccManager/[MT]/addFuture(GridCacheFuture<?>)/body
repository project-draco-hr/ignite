{
  if (fut.isDone()) {
    fut.markNotTrackable();
    return true;
  }
  if (!fut.trackable())   return true;
  while (true) {
    Collection<GridCacheFuture<?>> old=futs.get(fut.version());
    if (old == null) {
      Collection<GridCacheFuture<?>> col=new HashSet<GridCacheFuture<?>>(U.capacity(4),0.75f){
{
          add(fut);
        }
        @Override public int hashCode(){
          return System.identityHashCode(this);
        }
        @Override public boolean equals(        Object obj){
          return obj == this;
        }
      }
;
      old=futs.putIfAbsent(fut.version(),col);
    }
    if (old != null) {
      boolean empty, dup=false;
synchronized (old) {
        empty=old.isEmpty();
        if (!empty)         dup=!old.add(fut);
      }
      if (empty) {
        if (futs.remove(fut.version(),old)) {
          if (log.isDebugEnabled())           log.debug("Removed future list from futures map for lock version: " + fut.version());
        }
        continue;
      }
      if (dup) {
        if (log.isDebugEnabled())         log.debug("Found duplicate future in futures map (will not add): " + fut);
        return false;
      }
    }
    if (fut instanceof GridCacheMappedVersion) {
      GridCacheVersion from=((GridCacheMappedVersion)fut).mappedVersion();
      if (from != null)       mapVersion(from,fut.version());
    }
    if (log.isDebugEnabled())     log.debug("Added future to future map: " + fut);
    break;
  }
  for (  ClusterNode n : fut.nodes()) {
    if (cctx.discovery().node(n.id()) == null)     fut.onNodeLeft(n.id());
  }
  if (fut.isDone())   removeFuture(fut);
 else   onFutureAdded(fut);
  return true;
}
