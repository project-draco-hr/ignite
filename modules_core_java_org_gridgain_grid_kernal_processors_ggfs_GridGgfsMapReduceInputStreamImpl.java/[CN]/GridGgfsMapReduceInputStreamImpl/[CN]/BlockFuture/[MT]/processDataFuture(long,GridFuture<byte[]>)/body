{
  rawFut.syncNotify(false);
  rawFut.listenAsync(new CI1<GridFuture<byte[]>>(){
    @Override public void apply(    GridFuture<byte[]> rawFut){
      try {
        byte[] rawData=rawFut.get();
        if (rawData != null) {
          List<DelimiterGroup> delimPoss=null;
          boolean delimBeforeHead=false;
          if (!noDelims) {
            List<byte[]> nextDataChunks=new ArrayList<>(maxDelimLen / fileInfo.blockSize() + 1);
            int nextDataChunksLen=0;
            long nextIdx=idx + 1;
            while (nextDataChunksLen < maxDelimLen - 1 && nextIdx < fileInfo.blocksCount()) {
              byte[] nextDataChunk=data.dataBlock(fileInfo,path,nextIdx,inWrapper).get();
              if (nextDataChunk == null)               throw new GridException("Data block was not found [path=" + path + ", blockIdx="+ nextIdx+ ']');
              nextDataChunks.add(nextDataChunk);
              nextDataChunksLen+=nextDataChunk.length;
              nextIdx+=1;
            }
            byte[][] nextData=nextDataChunks.toArray(new byte[nextDataChunks.size()][]);
            List<DelimiterGroup> delimPoss0=null;
            List<byte[]> prevDataChunks=new ArrayList<>(1);
            int prevDataChunksLen=0;
            long prevIdx=idx - 1;
            while (prevIdx >= 0) {
              byte[] prevDataChunk=data.dataBlock(fileInfo,path,prevIdx,inWrapper).get();
              if (prevDataChunk == null)               throw new GridException("Data block was not found [path=" + path + ", blockIdx="+ prevIdx+ ']');
              prevDataChunks.add(0,prevDataChunk);
              prevDataChunksLen+=prevDataChunk.length;
              delimPoss0=delimiters(prevDataChunks.toArray(new byte[prevDataChunks.size()][]),rawData,nextData);
              int nearestPos=prevDataChunksLen * -1;
              int nearestDelimIdx=-1;
              for (int i=0; i < delimPoss0.size(); i++) {
                DelimiterGroup delimPos=delimPoss0.get(i);
                if (delimPos.start() < 0) {
                  if (delimPos.end() > nearestPos) {
                    nearestDelimIdx=i;
                    nearestPos=delimPos.end();
                  }
                }
 else                 break;
              }
              if (nearestDelimIdx == -1) {
                if (prevDataChunksLen >= maxDelimLen)                 break;
              }
 else {
                DelimiterGroup delimPos=delimPoss0.get(nearestDelimIdx);
                if ((delimPos.end() < 0 && (delimPos.end() + 1) * -1 >= maxDelimLen) || prevDataChunksLen + delimPos.start() >= maxDelimLen)                 break;
              }
              prevIdx-=1;
            }
            if (delimPoss0 == null)             delimPoss0=delimiters(null,rawData,nextData);
            delimPoss=new ArrayList<>(delimPoss0.size());
            for (            DelimiterGroup delimPos : delimPoss0) {
              if ((delimPos.start() >= 0 && delimPos.start() < rawData.length) || (delimPos.end() >= 0 && delimPos.end() < rawData.length) || (delimPos.start() < 0 && delimPos.end() >= rawData.length))               delimPoss.add(delimPos);
              for (              Delimiter delim : delimPos.delimiters()) {
                if (delim.end() == -1)                 delimBeforeHead=true;
              }
            }
          }
          boolean loc=locKeys.contains(idx);
          int skip=0;
          if (!noDelims && idx != 0) {
            if (prevBlock != null && prevBlock.continuation()) {
              if (!delimPoss.isEmpty() && delimPoss.get(0).start() <= 0)               skip=delimPoss.get(0).firstRelated().end() + 1;
            }
 else             if (!delimBeforeHead) {
              if (delimPoss.isEmpty())               skip=rawData.length;
 else {
                int delimEnd=delimPoss.get(0).firstRelated().end();
                skip=Math.min(rawData.length,delimEnd + 1);
              }
            }
          }
          boolean continuation=!noDelims && (loc ? (skip != rawData.length && (delimPoss.isEmpty() || delimPoss.get(delimPoss.size() - 1).lastRelated().end() != rawData.length - 1)) : (delimPoss.isEmpty() || delimPoss.get(0).firstRelated().end() >= rawData.length));
          int limit=rawData.length;
          if (!loc && !delimPoss.isEmpty()) {
            Delimiter delim=delimPoss.get(0).firstRelated();
            if (delim.end() < rawData.length - 1)             limit=delim.end() + 1;
          }
          Block block=new Block(idx,rawData,loc,continuation,skip,limit,delimPoss);
          lastFut=new BlockFuture(block);
          block.nextBlock(lastFut);
          if (lastFut.acquirePrefetch())           lastFut.process();
          onDone(block);
        }
 else         throw new GridException("Data block was not found [path=" + path + ", blockIdx="+ idx+ ']');
      }
 catch (      GridException e) {
        onDone(e);
      }
    }
  }
);
}
