{
  try {
    final Grid grid1=startGrid(1);
    GridCache<Integer,Object> cache1=grid1.cache(null);
    for (int i=0; i < 5000; i++)     cache1.put(i,VALUE + i);
    info("Finished data population.");
    final AtomicBoolean done=new AtomicBoolean();
    final CountDownLatch startLatch=new CountDownLatch(1);
    int oldSize=cache1.size();
    GridFuture fut=multithreadedAsync(new Callable<Object>(){
      @Nullable @Override public Object call() throws Exception {
        startLatch.await();
        info("Started evicting...");
        for (int i=0; i < 3000 && !done.get(); i++) {
          GridCacheEntry<Integer,Object> entry=randomEntry(grid1);
          if (entry != null)           entry.evict();
 else           info("Entry is null.");
        }
        info("Finished evicting.");
        return null;
      }
    }
,1);
    grid1.events().localListen(new GridPredicate<GridEvent>(){
      @Override public boolean apply(      GridEvent evt){
        startLatch.countDown();
        return true;
      }
    }
,EVT_NODE_JOINED);
    final Grid grid2=startGrid(2);
    done.set(true);
    fut.get();
    sleepUntilCashesEqualize(grid1,grid2,oldSize);
    checkCachesConsistency(grid1,grid2);
    oldSize=cache1.size();
    info("Evicting on constant topology.");
    for (int i=0; i < 1000; i++) {
      GridCacheEntry<Integer,Object> entry=randomEntry(grid1);
      if (entry != null)       entry.evict();
 else       info("Entry is null.");
    }
    sleepUntilCashesEqualize(grid1,grid2,oldSize);
    checkCachesConsistency(grid1,grid2);
  }
  finally {
    stopAllGrids();
  }
}
