{
  initCap=10;
  map=newMap();
  final AtomicInteger rehashes=new AtomicInteger();
  final AtomicInteger releases=new AtomicInteger();
  map.eventListener(new GridOffHeapEventListener(){
    @Override public void onEvent(    GridOffHeapEvent evt){
switch (evt) {
case REHASH:
        rehashes.incrementAndGet();
      break;
case RELEASE:
    releases.incrementAndGet();
  break;
default :
}
}
}
);
final int max=1024;
final ConcurrentMap<String,String> m=new ConcurrentHashMap8<>(max * parts);
final AtomicInteger part=new AtomicInteger();
multithreaded(new Callable<Object>(){
@Override public Object call() throws Exception {
int p=part.getAndIncrement();
for (int i=0; i < max; i++) {
String key=string();
String val=string();
String old=m.putIfAbsent(key,val);
if (old != null) val=old;
assertTrue(map.put(p,hash(key),key.getBytes(),val.getBytes()));
assertTrue(map.contains(p,hash(key),key.getBytes()));
assertNotNull(map.get(p,hash(key),key.getBytes()));
assertEquals(new String(map.get(p,hash(key),key.getBytes())),val);
}
try (GridCloseableIterator<IgniteBiTuple<byte[],byte[]>> it=map.iterator()){
while (it.hasNext()) {
  IgniteBiTuple<byte[],byte[]> t=it.next();
  String k=new String(t.get1());
  String v=new String(t.get2());
  assertEquals(m.get(k),v);
}
}
 return null;
}
}
,parts);
int cnt=0;
try (GridCloseableIterator<IgniteBiTuple<byte[],byte[]>> it=map.iterator()){
while (it.hasNext()) {
IgniteBiTuple<byte[],byte[]> t=it.next();
String k=new String(t.get1());
String v=new String(t.get2());
assertEquals(m.get(k),v);
cnt++;
}
}
 assertEquals(map.size(),cnt);
assertEquals(max * parts,map.size());
info("Stats [size=" + map.size() + ", rehashes="+ rehashes+ ", releases="+ releases+ ']');
assertTrue(rehashes.get() > 0);
assertEquals(rehashes.get(),releases.get());
}
