{
  PlatformConfiguration interopCfg=igniteCfg.getPlatformConfiguration();
  if (interopCfg != null && !(interopCfg instanceof PlatformCppConfiguration))   throw new IgniteException("Illegal interop configuration (must be of type " + PlatformCppConfiguration.class.getName() + "): "+ interopCfg.getClass().getName());
  PlatformCppConfiguration cppCfg=interopCfg != null ? (PlatformCppConfiguration)interopCfg : null;
  if (cppCfg == null)   cppCfg=new PlatformCppConfiguration();
  PlatformMemoryManagerImpl memMgr=new PlatformMemoryManagerImpl(gate,1024);
  PlatformCppConfigurationEx cppCfg0=new PlatformCppConfigurationEx(cppCfg,gate,memMgr);
  igniteCfg.setPlatformConfiguration(cppCfg0);
  Marshaller marsh=igniteCfg.getMarshaller();
  if (marsh == null) {
    PortableMarshaller marsh0=new PortableMarshaller();
    marsh0.setCompactFooter(false);
    igniteCfg.setMarshaller(marsh0);
    cppCfg0.warnings(Collections.singleton("Marshaller is automatically set to " + PortableMarshaller.class.getName() + " (other nodes must have the same marshaller type)."));
  }
 else   if (!(marsh instanceof PortableMarshaller))   throw new IgniteException("Unsupported marshaller (only " + PortableMarshaller.class.getName() + " can be used when running Apache Ignite C++): "+ marsh.getClass().getName());
 else   if (((PortableMarshaller)marsh).isCompactFooter())   throw new IgniteException("Unsupported " + PortableMarshaller.class.getName() + " \"compactFooter\" flag: must be false when running Apache Ignite C++.");
  String ggHome=igniteCfg.getIgniteHome();
  if (ggHome == null)   ggHome=U.getIgniteHome();
 else   U.setIgniteHome(ggHome);
  try {
    U.setWorkDirectory(igniteCfg.getWorkDirectory(),ggHome);
  }
 catch (  IgniteCheckedException e) {
    throw U.convertException(e);
  }
}
