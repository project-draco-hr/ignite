{
  if (!parseUrl(url,info))   throw new SQLException("URL is invalid: " + url);
  List<DriverPropertyInfo> props=Arrays.<DriverPropertyInfo>asList(new PropertyInfo("Hostname",info.getProperty(PROP_HOST),""),new PropertyInfo("Port number",info.getProperty(PROP_PORT),""),new PropertyInfo("Cache name",info.getProperty(PROP_CACHE),""),new PropertyInfo("Node ID",info.getProperty(PROP_NODE_ID),""),new PropertyInfo("Local",info.getProperty(PROP_LOCAL),""),new PropertyInfo("Collocated",info.getProperty(PROP_COLLOCATED),""),new PropertyInfo("Distributed Joins",info.getProperty(PROP_DISTRIBUTED_JOINS),""));
  if (info.getProperty(PROP_CFG) != null)   props.add(new PropertyInfo("Configuration path",info.getProperty(PROP_CFG),""));
 else   props.addAll(Arrays.<DriverPropertyInfo>asList(new PropertyInfo("ignite.client.protocol",info.getProperty("ignite.client.protocol","TCP"),"Communication protocol (TCP or HTTP)."),new PropertyInfo("ignite.client.connectTimeout",info.getProperty("ignite.client.connectTimeout","0"),"Socket connection timeout."),new PropertyInfo("ignite.client.tcp.noDelay",info.getProperty("ignite.client.tcp.noDelay","true"),"Flag indicating whether TCP_NODELAY flag should be enabled for outgoing connections."),new PropertyInfo("ignite.client.ssl.enabled",info.getProperty("ignite.client.ssl.enabled","false"),"Flag indicating that SSL is needed for connection."),new PropertyInfo("ignite.client.ssl.protocol",info.getProperty("ignite.client.ssl.protocol","TLS"),"SSL protocol."),new PropertyInfo("ignite.client.ssl.key.algorithm",info.getProperty("ignite.client.ssl.key.algorithm","SunX509"),"Key manager algorithm."),new PropertyInfo("ignite.client.ssl.keystore.location",info.getProperty("ignite.client.ssl.keystore.location",""),"Key store to be used by client to connect with Ignite topology."),new PropertyInfo("ignite.client.ssl.keystore.password",info.getProperty("ignite.client.ssl.keystore.password",""),"Key store password."),new PropertyInfo("ignite.client.ssl.keystore.type",info.getProperty("ignite.client.ssl.keystore.type","jks"),"Key store type."),new PropertyInfo("ignite.client.ssl.truststore.location",info.getProperty("ignite.client.ssl.truststore.location",""),"Trust store to be used by client to connect with Ignite topology."),new PropertyInfo("ignite.client.ssl.keystore.password",info.getProperty("ignite.client.ssl.truststore.password",""),"Trust store password."),new PropertyInfo("ignite.client.ssl.truststore.type",info.getProperty("ignite.client.ssl.truststore.type","jks"),"Trust store type."),new PropertyInfo("ignite.client.credentials",info.getProperty("ignite.client.credentials",""),"Client credentials used in authentication process."),new PropertyInfo("ignite.client.cache.top",info.getProperty("ignite.client.cache.top","false"),"Flag indicating that topology is cached internally. Cache will be refreshed in the " + "background with interval defined by topologyRefreshFrequency property (see below)."),new PropertyInfo("ignite.client.topology.refresh",info.getProperty("ignite.client.topology.refresh","2000"),"Topology cache refresh frequency (ms)."),new PropertyInfo("ignite.client.idleTimeout",info.getProperty("ignite.client.idleTimeout","30000"),"Maximum amount of time that connection can be idle before it is closed (ms).")));
  return props.toArray(new DriverPropertyInfo[0]);
}
