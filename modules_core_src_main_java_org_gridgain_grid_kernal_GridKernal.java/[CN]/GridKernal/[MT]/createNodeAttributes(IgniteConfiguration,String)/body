{
  Map<String,Object> attrs=new HashMap<>();
  final String[] incProps=cfg.getIncludeProperties();
  try {
    attrs.putAll(F.view(System.getenv(),new P1<String>(){
      @Override public boolean apply(      String name){
        return incProps == null || U.containsStringArray(incProps,name,true) || U.isVisorNodeStartProperty(name) || U.isVisorRequiredProperty(name);
      }
    }
));
    if (log.isDebugEnabled())     log.debug("Added environment properties to node attributes.");
  }
 catch (  SecurityException e) {
    throw new GridException("Failed to add environment properties to node attributes due to " + "security violation: " + e.getMessage());
  }
  try {
    for (    Map.Entry<Object,Object> e : F.view(System.getProperties(),new P1<Object>(){
      @Override public boolean apply(      Object o){
        String name=(String)o;
        return incProps == null || U.containsStringArray(incProps,name,true) || U.isVisorRequiredProperty(name);
      }
    }
).entrySet()) {
      Object val=attrs.get(e.getKey());
      if (val != null && !val.equals(e.getValue()))       U.warn(log,"System property will override environment variable with the same name: " + e.getKey());
      attrs.put((String)e.getKey(),e.getValue());
    }
    if (log.isDebugEnabled())     log.debug("Added system properties to node attributes.");
  }
 catch (  SecurityException e) {
    throw new GridException("Failed to add system properties to node attributes due to security " + "violation: " + e.getMessage());
  }
  String ips=F.concat(U.allLocalIps(),", ");
  String macs=F.concat(U.allLocalMACs(),", ");
  if (log.isInfoEnabled()) {
    log.info("Non-loopback local IPs: " + (F.isEmpty(ips) ? "N/A" : ips));
    log.info("Enabled local MACs: " + (F.isEmpty(macs) ? "N/A" : macs));
  }
  if (ips.isEmpty() && macs.isEmpty())   U.warn(log,"GridGain is starting on loopback address... Only nodes on the same physical " + "computer can participate in topology.","GridGain is starting on loopback address...");
  add(attrs,ATTR_IPS,(ips.isEmpty() ? "" : ips));
  add(attrs,ATTR_MACS,(macs.isEmpty() ? "" : macs));
  add(attrs,ATTR_JIT_NAME,U.getCompilerMx() == null ? "" : U.getCompilerMx().getName());
  add(attrs,ATTR_BUILD_VER,COMPOUND_VER);
  add(attrs,ATTR_BUILD_DATE,build);
  add(attrs,ATTR_COMPATIBLE_VERS,(Serializable)compatibleVersions());
  add(attrs,ATTR_MARSHALLER,cfg.getMarshaller().getClass().getName());
  add(attrs,ATTR_USER_NAME,System.getProperty("user.name"));
  add(attrs,ATTR_GRID_NAME,gridName);
  add(attrs,ATTR_PEER_CLASSLOADING,cfg.isPeerClassLoadingEnabled());
  add(attrs,ATTR_DEPLOYMENT_MODE,cfg.getDeploymentMode());
  add(attrs,ATTR_LANG_RUNTIME,getLanguage());
  add(attrs,ATTR_JVM_PID,U.jvmPid());
  SB jvmArgs=new SB(512);
  for (  String arg : U.jvmArgs()) {
    if (arg.startsWith("-"))     jvmArgs.a("@@@");
 else     jvmArgs.a(' ');
    jvmArgs.a(arg);
  }
  add(attrs,ATTR_JVM_ARGS,jvmArgs.toString());
  if (isDaemon())   add(attrs,ATTR_DAEMON,"true");
  if (isJmxRemoteEnabled()) {
    String portStr=System.getProperty("com.sun.management.jmxremote.port");
    if (portStr != null)     try {
      add(attrs,ATTR_JMX_PORT,Integer.parseInt(portStr));
    }
 catch (    NumberFormatException ignore) {
    }
  }
  add(attrs,ATTR_RESTART_ENABLED,Boolean.toString(isRestartEnabled()));
  if (cfg.getClientConnectionConfiguration() != null)   add(attrs,ATTR_REST_PORT_RANGE,cfg.getClientConnectionConfiguration().getRestPortRange());
  try {
    GridAuthenticationSpi authSpi=cfg.getAuthenticationSpi();
    boolean securityEnabled=authSpi != null && !U.hasAnnotation(authSpi.getClass(),IgniteSpiNoop.class);
    GridSecurityCredentialsProvider provider=cfg.getSecurityCredentialsProvider();
    if (provider != null) {
      GridSecurityCredentials cred=provider.credentials();
      if (cred != null)       add(attrs,ATTR_SECURITY_CREDENTIALS,cred);
 else       if (securityEnabled)       throw new GridException("Failed to start node (authentication SPI is configured, " + "by security credentials provider returned null).");
    }
 else     if (securityEnabled)     throw new GridException("Failed to start node (authentication SPI is configured, " + "but security credentials provider is not set. Fix the configuration and restart the node).");
  }
 catch (  GridException e) {
    throw new GridException("Failed to create node security credentials",e);
  }
  addAttributes(attrs,cfg.getCollisionSpi());
  addAttributes(attrs,cfg.getSwapSpaceSpi());
  addAttributes(attrs,cfg.getDiscoverySpi());
  addAttributes(attrs,cfg.getFailoverSpi());
  addAttributes(attrs,cfg.getCommunicationSpi());
  addAttributes(attrs,cfg.getEventStorageSpi());
  addAttributes(attrs,cfg.getCheckpointSpi());
  addAttributes(attrs,cfg.getLoadBalancingSpi());
  addAttributes(attrs,cfg.getAuthenticationSpi());
  addAttributes(attrs,cfg.getSecureSessionSpi());
  addAttributes(attrs,cfg.getDeploymentSpi());
  if (cfg.getUserAttributes() != null) {
    for (    Map.Entry<String,?> e : cfg.getUserAttributes().entrySet()) {
      if (attrs.containsKey(e.getKey()))       U.warn(log,"User or internal attribute has the same name as environment or system " + "property and will take precedence: " + e.getKey());
      attrs.put(e.getKey(),e.getValue());
    }
  }
  return attrs;
}
