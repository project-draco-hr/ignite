{
  cacheMode=CacheMode.PARTITIONED;
  backups=1;
  commSpiFactory=new TestFallbackCommunicationSpiFactory();
  final Set<Integer> candidates=new TreeSet<>();
  final AtomicBoolean test=new AtomicBoolean(false);
  for (int j=0; j < 2; j++) {
    clientMode=true;
    latch=new CountDownLatch(1);
    try {
      final Ignite ignite0=startGrid(0);
      clientMode=false;
      final IgniteEx ignite1=startGrid(1);
      final IgniteEx ignite2=startGrid(2);
      startGrid(3);
      if (test.get()) {
        expNodeId=ignite1.localNode().id();
        expFallbackNodeId=ignite2.localNode().id();
      }
      final IgniteCacheProxy<Integer,Integer> cache=fillCache(ignite0);
      if (!test.get()) {
        candidates.addAll(localPartitions(ignite1));
        candidates.retainAll(localPartitions(ignite2));
      }
      Runnable run=new Runnable(){
        @Override public void run(){
          try {
            startGrid(4);
            startGrid(5);
            awaitPartitionMapExchange();
            if (!test.get()) {
              candidates.removeAll(localPartitions(ignite1));
              F.retain(candidates,false,localPartitions(ignite2));
            }
            latch.countDown();
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
;
      Integer part=null;
      CacheQuery<Map.Entry<Integer,Integer>> qry=null;
      if (test.get()) {
        part=F.first(candidates);
        qry=cache.context().queries().createScanQuery(null,part,false);
      }
      new Thread(run).start();
      if (test.get())       doTestScanQuery(qry,part);
 else       latch.await();
    }
  finally {
      test.set(true);
      stopAllGrids();
    }
  }
}
