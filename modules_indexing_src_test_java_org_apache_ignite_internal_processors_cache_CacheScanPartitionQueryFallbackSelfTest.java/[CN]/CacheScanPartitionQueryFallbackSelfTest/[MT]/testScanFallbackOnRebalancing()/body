{
  cacheMode=CacheMode.PARTITIONED;
  clientMode=false;
  backups=1;
  commSpiFactory=new TestFallbackOnRebalancingCommunicationSpiFactory();
  try {
    Ignite ignite=startGrids(GRID_CNT);
    final IgniteCacheProxy<Integer,Integer> cache=fillCache(ignite);
    final AtomicBoolean done=new AtomicBoolean(false);
    final AtomicInteger idx=new AtomicInteger(GRID_CNT);
    IgniteInternalFuture fut1=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        int id=idx.getAndIncrement();
        while (!done.get()) {
          startGrid(id);
          Thread.sleep(3000);
          stopGrid(id);
          if (done.get())           return null;
          Thread.sleep(3000);
        }
        return null;
      }
    }
,GRID_CNT);
    final AtomicInteger nodeIdx=new AtomicInteger();
    IgniteInternalFuture fut2=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        int nodeId=nodeIdx.getAndIncrement();
        IgniteCacheProxy<Integer,Integer> cache=(IgniteCacheProxy<Integer,Integer>)grid(nodeId).<Integer,Integer>cache(null);
        while (!done.get()) {
          IgniteBiTuple<Integer,UUID> tup=remotePartition(cache.context());
          int part=tup.get1();
          try {
            CacheQuery<Map.Entry<Integer,Integer>> qry=cache.context().queries().createScanQuery(null,part,false);
            doTestScanQuery(qry);
          }
 catch (          ClusterGroupEmptyCheckedException e) {
            log.warning("Invalid partition: " + part,e);
          }
        }
        return null;
      }
    }
,GRID_CNT);
    Thread.sleep(60 * 1000);
    done.set(true);
    fut2.get();
    fut1.get();
  }
  finally {
    stopAllGrids();
  }
}
