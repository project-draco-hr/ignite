{
  cacheMode=CacheMode.PARTITIONED;
  clientMode=false;
  backups=1;
  commSpiFactory=new TestFallbackOnRebalancingCommunicationSpiFactory();
  try {
    Ignite ignite=startGrids(GRID_CNT);
    fillCache(ignite);
    final AtomicBoolean done=new AtomicBoolean(false);
    IgniteInternalFuture fut1=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        for (int i=0; i < 5; i++) {
          startGrid(GRID_CNT + i);
          U.sleep(500);
        }
        done.set(true);
        return null;
      }
    }
,1);
    final AtomicInteger nodeIdx=new AtomicInteger();
    IgniteInternalFuture fut2=multithreadedAsync(new Callable<Object>(){
      @Override public Object call() throws Exception {
        int nodeId=nodeIdx.getAndIncrement();
        IgniteCache<Integer,Integer> cache=grid(nodeId).cache(null);
        int cntr=0;
        while (!done.get()) {
          int part=ThreadLocalRandom.current().nextInt(ignite(nodeId).affinity(null).partitions());
          if (cntr++ % 100 == 0)           info("Running query [node=" + nodeId + ", part="+ part+ ']');
          try (QueryCursor<Cache.Entry<Integer,Integer>> cur=cache.query(new ScanQuery<Integer,Integer>(part).setPageSize(5))){
            doTestScanQueryCursor(cur,part);
          }
         }
        return null;
      }
    }
,GRID_CNT);
    fut1.get();
    fut2.get();
  }
  finally {
    stopAllGrids();
  }
}
