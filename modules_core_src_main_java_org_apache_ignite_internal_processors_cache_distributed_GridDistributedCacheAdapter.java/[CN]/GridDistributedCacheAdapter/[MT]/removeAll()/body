{
  try {
    AffinityTopologyVersion topVer;
    boolean retry;
    CacheOperationContext opCtx=ctx.operationContextPerCall();
    boolean skipStore=opCtx != null && opCtx.skipStore();
    boolean keepBinary=opCtx != null && opCtx.isKeepBinary();
    do {
      retry=false;
      topVer=ctx.affinity().affinityTopologyVersion();
      Collection<ClusterNode> nodes=ctx.grid().cluster().forDataNodes(name()).nodes();
      if (!nodes.isEmpty()) {
        ctx.kernalContext().task().setThreadContext(TC_SUBGRID,nodes);
        retry=!ctx.kernalContext().task().execute(new RemoveAllTask(ctx.name(),topVer,skipStore,keepBinary),null).get();
      }
    }
 while (ctx.affinity().affinityTopologyVersion().compareTo(topVer) != 0 || retry);
  }
 catch (  ClusterGroupEmptyCheckedException ignore) {
    if (log.isDebugEnabled())     log.debug("All remote nodes left while cache remove [cacheName=" + name() + "]");
  }
}
