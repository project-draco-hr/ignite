{
  Collection<ClusterNode> nodes=ctx.grid().cluster().forDataNodes(name()).nodes();
  if (!nodes.isEmpty()) {
    CacheOperationContext opCtx=ctx.operationContextPerCall();
    IgniteInternalFuture<?> rmvFut=ctx.closures().callAsyncNoFailover(BROADCAST,new GlobalRemoveAllCallable<>(name(),topVer,opCtx != null && opCtx.skipStore()),nodes,true);
    rmvFut.listen(new IgniteInClosure<IgniteInternalFuture<?>>(){
      @Override public void apply(      IgniteInternalFuture<?> fut){
        try {
          fut.get();
          AffinityTopologyVersion topVer0=ctx.affinity().affinityTopologyVersion();
          if (topVer0.equals(topVer))           opFut.onDone();
 else           removeAllAsync(opFut,topVer0);
        }
 catch (        ClusterGroupEmptyCheckedException ignore) {
          if (log.isDebugEnabled())           log.debug("All remote nodes left while cache remove [cacheName=" + name() + "]");
          opFut.onDone();
        }
catch (        IgniteCheckedException e) {
          opFut.onDone(e);
        }
catch (        Error e) {
          opFut.onDone(e);
          throw e;
        }
      }
    }
);
  }
 else   opFut.onDone();
}
