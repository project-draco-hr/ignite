{
  startStopwatch();
  assertParameter(ipFinder != null,"ipFinder != null");
  assertParameter(netTimeout > 0,"networkTimeout > 0");
  assertParameter(sockTimeout > 0,"sockTimeout > 0");
  assertParameter(ackTimeout > 0,"ackTimeout > 0");
  assertParameter(hbFreq > 0,"heartbeatFreq > 0");
  assertParameter(threadPri > 0,"threadPri > 0");
  try {
    locHost=U.resolveLocalHost(locAddr);
  }
 catch (  IOException e) {
    throw new IgniteSpiException("Unknown local address: " + locAddr,e);
  }
  if (log.isDebugEnabled()) {
    log.debug(configInfo("localHost",locHost.getHostAddress()));
    log.debug(configInfo("threadPri",threadPri));
    log.debug(configInfo("networkTimeout",netTimeout));
    log.debug(configInfo("sockTimeout",sockTimeout));
    log.debug(configInfo("ackTimeout",ackTimeout));
    log.debug(configInfo("ipFinder",ipFinder));
    log.debug(configInfo("heartbeatFreq",hbFreq));
  }
  if (netTimeout < 3000)   U.warn(log,"Network timeout is too low (at least 3000 ms recommended): " + netTimeout);
  if (hbFreq < 2000)   U.warn(log,"Heartbeat frequency is too high (at least 2000 ms recommended): " + hbFreq);
  registerMBean(gridName,this,TcpClientDiscoverySpiMBean.class);
  try {
    locHost=U.resolveLocalHost(locAddr);
  }
 catch (  IOException e) {
    throw new IgniteSpiException("Unknown local address: " + locAddr,e);
  }
  if (ipFinder instanceof TcpDiscoveryMulticastIpFinder) {
    TcpDiscoveryMulticastIpFinder mcastIpFinder=((TcpDiscoveryMulticastIpFinder)ipFinder);
    if (mcastIpFinder.getLocalAddress() == null)     mcastIpFinder.setLocalAddress(locAddr);
  }
  IgniteBiTuple<Collection<String>,Collection<String>> addrs;
  try {
    addrs=U.resolveLocalAddresses(locHost);
  }
 catch (  IOException|IgniteCheckedException e) {
    throw new IgniteSpiException("Failed to resolve local host to set of external addresses: " + locHost,e);
  }
  locNode=new TcpDiscoveryNode(getLocalNodeId(),addrs.get1(),addrs.get2(),0,metricsProvider,locNodeVer);
  locNode.setAttributes(locNodeAttrs);
  locNode.local(true);
  sockTimeoutWorker=new SocketTimeoutWorker();
  sockTimeoutWorker.start();
  joinTopology(false);
  disconnectHnd=new DisconnectHandler();
  disconnectHnd.start();
  if (log.isDebugEnabled())   log.debug(startInfo());
}
