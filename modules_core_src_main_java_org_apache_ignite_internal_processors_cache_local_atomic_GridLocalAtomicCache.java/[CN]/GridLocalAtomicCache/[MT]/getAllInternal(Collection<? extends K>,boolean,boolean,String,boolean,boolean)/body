{
  ctx.checkSecurity(SecurityPermission.CACHE_READ);
  if (F.isEmpty(keys))   return Collections.emptyMap();
  CacheOperationContext opCtx=ctx.operationContextPerCall();
  UUID subjId=ctx.subjectIdPerCall(null,opCtx);
  Map<K,V> vals=new HashMap<>(keys.size(),1.0f);
  if (keyCheck)   validateCacheKeys(keys);
  final IgniteCacheExpiryPolicy expiry=expiryPolicy(opCtx != null ? opCtx.expiry() : null);
  boolean success=true;
  for (  K key : keys) {
    if (key == null)     throw new NullPointerException("Null key.");
    GridCacheEntryEx entry=null;
    KeyCacheObject cacheKey=ctx.toCacheKeyObject(key);
    while (true) {
      try {
        entry=swapOrOffheap ? entryEx(cacheKey) : peekEx(cacheKey);
        if (entry != null) {
          CacheObject v=entry.innerGet(null,swapOrOffheap,false,false,true,true,!skipVals,false,subjId,null,taskName,expiry,!deserializePortable);
          if (v != null)           ctx.addResult(vals,cacheKey,v,skipVals,false,deserializePortable,true);
 else           success=false;
        }
 else {
          if (!storeEnabled && configuration().isStatisticsEnabled() && !skipVals)           metrics0().onRead(false);
          success=false;
        }
        break;
      }
 catch (      GridCacheEntryRemovedException ignored) {
      }
 finally {
        if (entry != null)         ctx.evicts().touch(entry,ctx.affinity().affinityTopologyVersion());
      }
      if (!success && storeEnabled)       break;
    }
  }
  if (success || !storeEnabled)   return vals;
  return getAllAsync(keys,opCtx == null || !opCtx.skipStore(),false,subjId,taskName,deserializePortable,false,expiry,skipVals,true).get();
}
