{
  ctx.denyOnFlag(LOCAL);
  A.notNull(keys,"keys");
  final boolean swapOrOffheap=ctx.isSwapOrOffheapEnabled();
  final boolean storeEnabled=ctx.readThrough();
  final boolean clone=ctx.hasFlag(CLONE);
  return asyncOp(new Callable<Map<K,V>>(){
    @Override public Map<K,V> call() throws Exception {
      return getAllInternal(keys,filter,swapOrOffheap,storeEnabled,clone,taskName,deserializePortable);
    }
  }
);
}
