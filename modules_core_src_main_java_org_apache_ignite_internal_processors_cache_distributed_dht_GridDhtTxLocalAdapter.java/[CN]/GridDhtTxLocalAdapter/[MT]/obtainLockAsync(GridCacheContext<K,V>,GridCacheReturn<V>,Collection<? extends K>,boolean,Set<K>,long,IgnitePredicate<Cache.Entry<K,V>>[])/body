{
  if (log.isDebugEnabled())   log.debug("Before acquiring transaction lock on keys [passedKeys=" + passedKeys + ", skipped="+ skipped+ ']');
  if (passedKeys.isEmpty())   return new GridFinishedFuture<>(cctx.kernalContext(),ret);
  GridDhtTransactionalCacheAdapter<K,V> dhtCache=cacheCtx.isNear() ? cacheCtx.nearTx().dht() : cacheCtx.dhtTx();
  IgniteInternalFuture<Boolean> fut=dhtCache.lockAllAsyncInternal(passedKeys,lockTimeout(),this,isInvalidate(),read,false,isolation,accessTtl,CU.<K,V>empty());
  return new GridEmbeddedFuture<>(fut,new PLC1<GridCacheReturn<V>>(ret){
    @Override protected GridCacheReturn<V> postLock(    GridCacheReturn<V> ret) throws IgniteCheckedException {
      if (log.isDebugEnabled())       log.debug("Acquired transaction lock on keys: " + passedKeys);
      postLockWrite(cacheCtx,passedKeys,skipped,ret,false,false,read,accessTtl,filter == null ? CU.<K,V>empty() : filter,false);
      return ret;
    }
  }
,cctx.kernalContext());
}
