{
  if (log.isDebugEnabled())   log.debug("Before acquiring transaction lock on keys [passedKeys=" + passedKeys + ", skipped="+ skipped+ ']');
  if (passedKeys.isEmpty())   return new GridFinishedFuture<>(cctx.kernalContext(),ret);
  GridDhtTransactionalCacheAdapter<?,?> dhtCache=cacheCtx.isNear() ? cacheCtx.nearTx().dht() : cacheCtx.dhtTx();
  IgniteInternalFuture<Boolean> fut=dhtCache.lockAllAsyncInternal(passedKeys,lockTimeout(),this,isInvalidate(),read,false,isolation,accessTtl,(IgnitePredicate[])CU.empty());
  return new GridEmbeddedFuture<>(fut,new PLC1<GridCacheReturn<Object>>(ret){
    @Override protected GridCacheReturn<Object> postLock(    GridCacheReturn<Object> ret) throws IgniteCheckedException {
      if (log.isDebugEnabled())       log.debug("Acquired transaction lock on keys: " + passedKeys);
      postLockWrite(cacheCtx,passedKeys,skipped,ret,false,false,read,accessTtl,filter == null ? CU.empty() : filter,false);
      return ret;
    }
  }
,cctx.kernalContext());
}
