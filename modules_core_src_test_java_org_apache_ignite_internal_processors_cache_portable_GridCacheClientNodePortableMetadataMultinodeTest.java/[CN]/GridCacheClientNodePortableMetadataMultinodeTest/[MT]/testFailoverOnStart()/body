{
  startGrids(4);
  IgnitePortables portables=ignite(0).portables();
  IgniteCache<Object,Object> cache=ignite(0).cache(null).withKeepPortable();
  for (int i=0; i < 1000; i++) {
    PortableBuilder builder=portables.builder("type-" + i);
    builder.setField("f0",i);
    cache.put(i,builder.build());
  }
  client=true;
  final CyclicBarrier barrier=new CyclicBarrier(6);
  final AtomicInteger startIdx=new AtomicInteger(4);
  IgniteInternalFuture<?> fut=GridTestUtils.runMultiThreadedAsync(new Callable<Object>(){
    @Override public Object call() throws Exception {
      barrier.await();
      Ignite ignite=startGrid(startIdx.getAndIncrement());
      assertTrue(ignite.configuration().isClientMode());
      log.info("Started node: " + ignite.name());
      return null;
    }
  }
,5,"start-thread");
  barrier.await();
  U.sleep(ThreadLocalRandom.current().nextInt(10,100));
  for (int i=0; i < 3; i++)   stopGrid(i);
  fut.get();
  assertEquals(6,ignite(3).cluster().nodes().size());
  for (int i=3; i < 7; i++) {
    log.info("Check metadata on node: " + i);
    boolean client=i > 3;
    assertEquals((Object)client,ignite(i).configuration().isClientMode());
    portables=ignite(i).portables();
    final IgnitePortables p0=portables;
    GridTestUtils.waitForCondition(new GridAbsPredicate(){
      @Override public boolean apply(){
        Collection<PortableMetadata> metaCol=p0.metadata();
        return metaCol.size() == 1000;
      }
    }
,getTestTimeout());
    Collection<PortableMetadata> metaCol=portables.metadata();
    assertEquals(1000,metaCol.size());
    Set<String> names=new HashSet<>();
    for (    PortableMetadata meta : metaCol) {
      assertTrue(names.add(meta.typeName()));
      assertNull(meta.affinityKeyFieldName());
      assertEquals(1,meta.fields().size());
    }
    assertEquals(1000,names.size());
  }
}
