{
  Iterator<K> keyIter;
  GridDhtLocalPartition locPart=null;
  Integer part=qry.partition();
  if (part == null || cctx.isLocal()) {
    if (locNode && plc == null && !cctx.isLocal()) {
      GridDhtCacheAdapter<K,V> cache=cctx.isNear() ? cctx.near().dht() : cctx.dht();
      final Iterator<Cache.Entry<K,V>> iter=cache.localEntriesIterator(true,backups,cache.context().keepBinary());
      return new GridIteratorAdapter<IgniteBiTuple<K,V>>(){
        /** 
 */
        private IgniteBiTuple<K,V> next;
{
          advance();
        }
        @Override public boolean hasNextX() throws IgniteCheckedException {
          return next != null;
        }
        @Override public IgniteBiTuple<K,V> nextX() throws IgniteCheckedException {
          if (next == null)           throw new NoSuchElementException();
          IgniteBiTuple<K,V> next0=next;
          advance();
          return next0;
        }
        @Override public void removeX() throws IgniteCheckedException {
        }
        private void advance(){
          IgniteBiTuple<K,V> next0=null;
          while (iter.hasNext()) {
            Cache.Entry<K,V> cacheEntry=iter.next();
            if (keyValFilter != null && !keyValFilter.apply(cacheEntry.getKey(),cacheEntry.getValue()))             continue;
            next0=new IgniteBiTuple<>(cacheEntry.getKey(),cacheEntry.getValue());
            break;
          }
          next=next0;
        }
      }
;
    }
    IgniteInternalCache<K,V> keepBinaryCache=cctx.cache().keepBinary();
    keyIter=backups ? keepBinaryCache.keySetx().iterator() : keepBinaryCache.primaryKeySet().iterator();
  }
 else   if (part < 0 || part >= cctx.affinity().partitions())   keyIter=new GridEmptyIterator<>();
 else {
    final GridDhtCacheAdapter dht=cctx.isNear() ? cctx.near().dht() : cctx.dht();
    locPart=dht.topology().localPartition(part,topVer,false);
    if (locPart == null || locPart.state() != OWNING || !locPart.reserve() || locPart.state() != OWNING)     throw new GridDhtUnreservedPartitionException(part,cctx.affinity().affinityTopologyVersion(),"Partition can not be reserved.");
    final GridDhtLocalPartition locPart0=locPart;
    keyIter=new Iterator<K>(){
      private Iterator<KeyCacheObject> iter0=locPart0.keySet().iterator();
      @Override public boolean hasNext(){
        return iter0.hasNext();
      }
      @Override public K next(){
        return (K)iter0.next();
      }
      @Override public void remove(){
        iter0.remove();
      }
    }
;
  }
  final GridDhtLocalPartition locPart0=locPart;
  return new PeekValueExpiryAwareIterator(keyIter,plc,topVer,keyValFilter,qry.keepBinary(),locNode,true){
    @Override protected void onClose(){
      super.onClose();
      if (locPart0 != null)       locPart0.release();
    }
  }
;
}
