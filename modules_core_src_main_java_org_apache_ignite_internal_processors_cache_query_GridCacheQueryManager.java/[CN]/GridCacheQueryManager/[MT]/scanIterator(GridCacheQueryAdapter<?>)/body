{
  IgniteInternalCache<K,V> prj0=cctx.cache();
  if (qry.keepPortable())   prj0=prj0.keepPortable();
  final IgniteInternalCache<K,V> prj=prj0;
  final IgniteBiPredicate<K,V> keyValFilter=qry.scanFilter();
  injectResources(keyValFilter);
  final GridDhtCacheAdapter dht=cctx.isLocal() ? null : (cctx.isNear() ? cctx.near().dht() : cctx.dht());
  final ExpiryPolicy plc=cctx.expiry();
  final boolean backups=qry.includeBackups() || cctx.isReplicated();
  final GridCloseableIteratorAdapter<IgniteBiTuple<K,V>> heapIt=new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
    private IgniteBiTuple<K,V> next;
    private IgniteCacheExpiryPolicy expiryPlc=cctx.cache().expiryPolicy(plc);
    private Iterator<K> iter;
    private GridDhtLocalPartition locPart;
{
      Integer part=qry.partition();
      if (part == null || dht == null)       iter=backups ? prj.keySetx().iterator() : prj.primaryKeySet().iterator();
 else       if (part < 0 || part >= cctx.affinity().partitions())       iter=F.emptyIterator();
 else {
        AffinityTopologyVersion topVer=cctx.affinity().affinityTopologyVersion();
        locPart=dht.topology().localPartition(part,topVer,false);
        if (locPart == null || locPart.state() != OWNING || !locPart.reserve() || locPart.state() != OWNING)         throw new GridDhtInvalidPartitionException(part,"Partition can't be reserved");
        iter=new Iterator<K>(){
          private Iterator<KeyCacheObject> iter0=locPart.keySet().iterator();
          @Override public boolean hasNext(){
            return iter0.hasNext();
          }
          @Override public K next(){
            KeyCacheObject key=iter0.next();
            return key.value(cctx.cacheObjectContext(),false);
          }
          @Override public void remove(){
            iter0.remove();
          }
        }
;
      }
      advance();
    }
    @Override public boolean onHasNext(){
      return next != null;
    }
    @Override public IgniteBiTuple<K,V> onNext(){
      if (next == null)       throw new NoSuchElementException();
      IgniteBiTuple<K,V> next0=next;
      advance();
      return next0;
    }
    private void advance(){
      IgniteBiTuple<K,V> next0=null;
      while (iter.hasNext()) {
        next0=null;
        K key=iter.next();
        V val;
        try {
          val=prj.localPeek(key,CachePeekModes.ONHEAP_ONLY,expiryPlc);
        }
 catch (        IgniteCheckedException e) {
          if (log.isDebugEnabled())           log.debug("Failed to peek value: " + e);
          val=null;
        }
        if (dht != null && expiryPlc != null && expiryPlc.readyToFlush(100)) {
          dht.sendTtlUpdateRequest(expiryPlc);
          expiryPlc=cctx.cache().expiryPolicy(plc);
        }
        if (val != null) {
          next0=F.t(key,val);
          if (checkPredicate(next0))           break;
 else           next0=null;
        }
      }
      next=next0 != null ? new IgniteBiTuple<>(next0.getKey(),next0.getValue()) : null;
      if (next == null)       sendTtlUpdate();
    }
    @Override protected void onClose(){
      sendTtlUpdate();
      if (locPart != null)       locPart.release();
    }
    private void sendTtlUpdate(){
      if (dht != null && expiryPlc != null) {
        dht.sendTtlUpdateRequest(expiryPlc);
        expiryPlc=null;
      }
    }
    private boolean checkPredicate(    Map.Entry<K,V> e){
      if (keyValFilter != null) {
        Map.Entry<K,V> e0=(Map.Entry<K,V>)cctx.unwrapPortableIfNeeded(e,qry.keepPortable());
        return keyValFilter.apply(e0.getKey(),e0.getValue());
      }
      return true;
    }
  }
;
  final GridIterator<IgniteBiTuple<K,V>> it;
  if (cctx.isSwapOrOffheapEnabled()) {
    List<GridIterator<IgniteBiTuple<K,V>>> iters=new ArrayList<>(3);
    iters.add(heapIt);
    if (cctx.isOffHeapEnabled())     iters.add(offheapIterator(qry,backups));
    if (cctx.swap().swapEnabled())     iters.add(swapIterator(qry,backups));
    it=new CompoundIterator<>(iters);
  }
 else   it=heapIt;
  return new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
    @Override protected boolean onHasNext(){
      return it.hasNext();
    }
    @Override protected IgniteBiTuple<K,V> onNext(){
      return it.next();
    }
    @Override protected void onRemove(){
      it.remove();
    }
    @Override protected void onClose() throws IgniteCheckedException {
      try {
        heapIt.close();
      }
  finally {
        if (keyValFilter instanceof CacheQueryCloseableScanBiPredicate)         ((CacheQueryCloseableScanBiPredicate)keyValFilter).onClose();
      }
    }
  }
;
}
