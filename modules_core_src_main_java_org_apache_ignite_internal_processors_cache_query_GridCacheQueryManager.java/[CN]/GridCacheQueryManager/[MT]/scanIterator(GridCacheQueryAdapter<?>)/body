{
  IgniteInternalCache<K,V> prj0=cctx.cache();
  if (qry.keepBinary())   prj0=prj0.keepBinary();
  final IgniteInternalCache<K,V> prj=prj0;
  final IgniteBiPredicate<K,V> keyValFilter=qry.scanFilter();
  try {
    injectResources(keyValFilter);
    final GridDhtCacheAdapter dht=cctx.isLocal() ? null : (cctx.isNear() ? cctx.near().dht() : cctx.dht());
    final GridCacheAdapter cache=dht != null ? dht : cctx.cache();
    final ExpiryPolicy plc=cctx.expiry();
    final AffinityTopologyVersion topVer=cctx.affinity().affinityTopologyVersion();
    final boolean backups=qry.includeBackups() || cctx.isReplicated();
    final GridCloseableIteratorAdapter<IgniteBiTuple<K,V>> heapIt=new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
      private IgniteBiTuple<K,V> next;
      private IgniteCacheExpiryPolicy expiryPlc=cctx.cache().expiryPolicy(plc);
      private Iterator<K> iter;
      private GridDhtLocalPartition locPart;
{
        Integer part=qry.partition();
        if (part == null || dht == null)         iter=backups ? prj.keySetx().iterator() : prj.primaryKeySet().iterator();
 else         if (part < 0 || part >= cctx.affinity().partitions())         iter=F.emptyIterator();
 else {
          locPart=dht.topology().localPartition(part,topVer,false);
          if (locPart == null || locPart.state() != OWNING || !locPart.reserve() || locPart.state() != OWNING)           throw new GridDhtUnreservedPartitionException(part,cctx.affinity().affinityTopologyVersion(),"Partition can not be reserved");
          iter=new Iterator<K>(){
            private Iterator<KeyCacheObject> iter0=locPart.keySet().iterator();
            @Override public boolean hasNext(){
              return iter0.hasNext();
            }
            @Override public K next(){
              KeyCacheObject key=iter0.next();
              return key.value(cctx.cacheObjectContext(),false);
            }
            @Override public void remove(){
              iter0.remove();
            }
          }
;
        }
        advance();
      }
      @Override public boolean onHasNext(){
        return next != null;
      }
      @Override public IgniteBiTuple<K,V> onNext(){
        if (next == null)         throw new NoSuchElementException();
        IgniteBiTuple<K,V> next0=next;
        advance();
        return next0;
      }
      private void advance(){
        IgniteBiTuple<K,V> next0=null;
        while (iter.hasNext()) {
          next0=null;
          K key=iter.next();
          V val;
          try {
            GridCacheEntryEx entry=cache.peekEx(key);
            CacheObject cacheVal=entry != null ? entry.peek(true,false,false,topVer,expiryPlc) : null;
            val=(V)cctx.cacheObjectContext().unwrapBinaryIfNeeded(cacheVal,qry.keepBinary());
          }
 catch (          GridCacheEntryRemovedException e) {
            val=null;
          }
catch (          IgniteCheckedException e) {
            if (log.isDebugEnabled())             log.debug("Failed to peek value: " + e);
            val=null;
          }
          if (dht != null && expiryPlc != null && expiryPlc.readyToFlush(100)) {
            dht.sendTtlUpdateRequest(expiryPlc);
            expiryPlc=cctx.cache().expiryPolicy(plc);
          }
          if (val != null) {
            next0=F.t(key,val);
            if (checkPredicate(next0))             break;
 else             next0=null;
          }
        }
        next=next0 != null ? new IgniteBiTuple<>(next0.getKey(),next0.getValue()) : null;
        if (next == null)         sendTtlUpdate();
      }
      @Override protected void onClose(){
        sendTtlUpdate();
        if (locPart != null)         locPart.release();
      }
      private void sendTtlUpdate(){
        if (dht != null && expiryPlc != null) {
          dht.sendTtlUpdateRequest(expiryPlc);
          expiryPlc=null;
        }
      }
      private boolean checkPredicate(      Map.Entry<K,V> e){
        if (keyValFilter != null) {
          Map.Entry<K,V> e0=(Map.Entry<K,V>)cctx.unwrapBinaryIfNeeded(e,qry.keepBinary());
          return keyValFilter.apply(e0.getKey(),e0.getValue());
        }
        return true;
      }
    }
;
    final GridIterator<IgniteBiTuple<K,V>> it;
    if (cctx.isSwapOrOffheapEnabled()) {
      List<GridIterator<IgniteBiTuple<K,V>>> iters=new ArrayList<>(3);
      iters.add(heapIt);
      if (cctx.isOffHeapEnabled())       iters.add(offheapIterator(qry,backups));
      if (cctx.swap().swapEnabled())       iters.add(swapIterator(qry,backups));
      it=new CompoundIterator<>(iters);
    }
 else     it=heapIt;
    return new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
      @Override protected boolean onHasNext(){
        return it.hasNext();
      }
      @Override protected IgniteBiTuple<K,V> onNext(){
        return it.next();
      }
      @Override protected void onRemove(){
        it.remove();
      }
      @Override protected void onClose() throws IgniteCheckedException {
        try {
          heapIt.close();
        }
  finally {
          closeScanFilter(keyValFilter);
        }
      }
    }
;
  }
 catch (  IgniteCheckedException|RuntimeException e) {
    closeScanFilter(keyValFilter);
    throw e;
  }
}
