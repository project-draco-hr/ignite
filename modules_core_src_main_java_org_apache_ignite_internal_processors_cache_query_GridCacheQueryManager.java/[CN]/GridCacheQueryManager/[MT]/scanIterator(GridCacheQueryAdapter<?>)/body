{
  IgnitePredicate<Cache.Entry<K,V>> filter=null;
  if (qry.projectionFilter() != null) {
    filter=new P1<Cache.Entry<K,V>>(){
      @Override public boolean apply(      Cache.Entry<K,V> e){
        return qry.projectionFilter().apply((Cache.Entry<Object,Object>)e);
      }
    }
;
  }
  CacheProjection<K,V> prj0=filter != null ? cctx.cache().projection(filter) : cctx.cache();
  if (qry.keepPortable())   prj0=prj0.keepPortable();
  final CacheProjection<K,V> prj=prj0;
  final IgniteBiPredicate<K,V> keyValFilter=qry.scanFilter();
  injectResources(keyValFilter);
  final CachePeekMode[] peekModes={CachePeekMode.ONHEAP};
  final GridDhtCacheAdapter dht=cctx.isLocal() ? null : (cctx.isNear() ? cctx.near().dht() : cctx.dht());
  final ExpiryPolicy plc=cctx.expiry();
  final GridCloseableIteratorAdapter<IgniteBiTuple<K,V>> heapIt=new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
    private IgniteBiTuple<K,V> next;
    private IgniteCacheExpiryPolicy expiryPlc=cctx.cache().accessExpiryPolicy(plc);
    private Iterator<K> iter=qry.includeBackups() || cctx.isReplicated() ? prj.keySet().iterator() : prj.primaryKeySet().iterator();
{
      advance();
    }
    @Override public boolean onHasNext(){
      return next != null;
    }
    @Override public IgniteBiTuple<K,V> onNext(){
      if (next == null)       throw new NoSuchElementException();
      IgniteBiTuple<K,V> next0=next;
      advance();
      return next0;
    }
    private void advance(){
      IgniteBiTuple<K,V> next0=null;
      while (iter.hasNext()) {
        next0=null;
        K key=iter.next();
        V val;
        try {
          val=prj.localPeek(key,peekModes,expiryPlc);
        }
 catch (        IgniteCheckedException e) {
          if (log.isDebugEnabled())           log.debug("Failed to peek value: " + e);
          val=null;
        }
        if (dht != null && expiryPlc != null && expiryPlc.readyToFlush(100)) {
          dht.sendTtlUpdateRequest(expiryPlc);
          expiryPlc=cctx.cache().accessExpiryPolicy(plc);
        }
        if (val != null) {
          next0=F.t(key,val);
          if (checkPredicate(next0))           break;
 else           next0=null;
        }
      }
      next=next0 != null ? new IgniteBiTuple<>(next0.getKey(),next0.getValue()) : null;
      if (next == null)       sendTtlUpdate();
    }
    @Override protected void onClose() throws IgniteCheckedException {
      sendTtlUpdate();
    }
    private void sendTtlUpdate(){
      if (dht != null && expiryPlc != null) {
        dht.sendTtlUpdateRequest(expiryPlc);
        expiryPlc=null;
      }
    }
    private boolean checkPredicate(    Map.Entry<K,V> e){
      if (keyValFilter != null) {
        Map.Entry<K,V> e0=(Map.Entry<K,V>)cctx.unwrapPortableIfNeeded(e,qry.keepPortable());
        return keyValFilter.apply(e0.getKey(),e0.getValue());
      }
      return true;
    }
  }
;
  final GridIterator<IgniteBiTuple<K,V>> it;
  if (cctx.isSwapOrOffheapEnabled()) {
    List<GridIterator<IgniteBiTuple<K,V>>> iters=new ArrayList<>(3);
    iters.add(heapIt);
    if (cctx.isOffHeapEnabled())     iters.add(offheapIterator(qry));
    if (cctx.swap().swapEnabled())     iters.add(swapIterator(qry));
    it=new CompoundIterator<>(iters);
  }
 else   it=heapIt;
  return new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
    @Override protected boolean onHasNext(){
      return it.hasNext();
    }
    @Override protected IgniteBiTuple<K,V> onNext(){
      return it.next();
    }
    @Override protected void onRemove(){
      it.remove();
    }
    @Override protected void onClose() throws IgniteCheckedException {
      heapIt.close();
    }
  }
;
}
