{
  IgniteInternalCache<K,V> prj0=cctx.cache();
  prj0=prj0.keepBinary();
  final IgniteInternalCache prj=prj0;
  final IgniteBiPredicate<K,V> keyValFilter=qry.scanFilter();
  try {
    injectResources(keyValFilter);
    final ExpiryPolicy plc=cctx.expiry();
    final AffinityTopologyVersion topVer=cctx.affinity().affinityTopologyVersion();
    final boolean backups=qry.includeBackups() || cctx.isReplicated();
    Iterator<K> keyIter;
    GridDhtLocalPartition locPart=null;
    Integer part=qry.partition();
    if (part == null || cctx.isLocal())     keyIter=backups ? prj.keySetx().iterator() : prj.primaryKeySet().iterator();
 else     if (part < 0 || part >= cctx.affinity().partitions())     keyIter=new GridEmptyIterator<>();
 else {
      final GridDhtCacheAdapter dht=cctx.isNear() ? cctx.near().dht() : cctx.dht();
      locPart=dht.topology().localPartition(part,topVer,false);
      if (locPart == null || locPart.state() != OWNING || !locPart.reserve() || locPart.state() != OWNING)       throw new GridDhtUnreservedPartitionException(part,cctx.affinity().affinityTopologyVersion(),"Partition can not be reserved");
      final GridDhtLocalPartition locPart0=locPart;
      keyIter=new Iterator<K>(){
        private Iterator<KeyCacheObject> iter0=locPart0.keySet().iterator();
        @Override public boolean hasNext(){
          return iter0.hasNext();
        }
        @Override public K next(){
          return (K)iter0.next();
        }
        @Override public void remove(){
          iter0.remove();
        }
      }
;
    }
    final GridDhtLocalPartition locPart0=locPart;
    final GridCloseableIteratorAdapter<IgniteBiTuple<K,V>> heapIt=new PeekValueExpiryAwareIterator(keyIter,plc,topVer,keyValFilter,qry.keepBinary(),true){
      @Override protected void onClose(){
        super.onClose();
        if (locPart0 != null)         locPart0.release();
      }
    }
;
    final GridIterator<IgniteBiTuple<K,V>> it;
    if (cctx.isSwapOrOffheapEnabled()) {
      List<GridIterator<IgniteBiTuple<K,V>>> iters=new ArrayList<>(3);
      iters.add(heapIt);
      if (cctx.isOffHeapEnabled())       iters.add(offheapIterator(qry,topVer,backups,plc));
      if (cctx.swap().swapEnabled())       iters.add(swapIterator(qry,topVer,backups,plc));
      it=new CompoundIterator<>(iters);
    }
 else     it=heapIt;
    return new GridCloseableIteratorAdapter<IgniteBiTuple<K,V>>(){
      @Override protected boolean onHasNext(){
        return it.hasNext();
      }
      @Override protected IgniteBiTuple<K,V> onNext(){
        return it.next();
      }
      @Override protected void onRemove(){
        it.remove();
      }
      @Override protected void onClose() throws IgniteCheckedException {
        try {
          heapIt.close();
        }
  finally {
          closeScanFilter(keyValFilter);
        }
      }
    }
;
  }
 catch (  IgniteCheckedException|RuntimeException e) {
    closeScanFilter(keyValFilter);
    throw e;
  }
}
