{
  final AtomicInteger lockEvtCnt=new AtomicInteger();
  GridPredicate<GridEvent> lsnr=new GridPredicate<GridEvent>(){
    @Override public boolean apply(    GridEvent evt){
      lockEvtCnt.incrementAndGet();
      return true;
    }
  }
;
  try {
    grid(0).events().localListen(lsnr,EVT_CACHE_OBJECT_LOCKED,EVT_CACHE_OBJECT_UNLOCKED);
    GridCache<String,Integer> cache=cache();
    GridCacheTx tx=cache.txStart(PESSIMISTIC,REPEATABLE_READ);
    try {
      int key=0;
      for (int i=0; i < 1000; i++) {
        if (cache.affinity().mapKeyToNode("key" + i).id().equals(grid(0).localNode().id())) {
          key=i;
          break;
        }
      }
      cache.get("key" + key);
      for (int i=key + 1; i < 1000; i++) {
        if (cache.affinity().mapKeyToNode("key" + i).id().equals(grid(0).localNode().id())) {
          key=i;
          break;
        }
      }
      ((GridCacheProjectionEx<String,Integer>)cache).getAllOutTx(F.asList("key" + key));
    }
  finally {
      tx.close();
    }
    assertTrue(GridTestUtils.waitForCondition(new PA(){
      @Override public boolean apply(){
        info("Lock event count: " + lockEvtCnt.get());
        return lockEvtCnt.get() == (nearEnabled() ? 4 : 2);
      }
    }
,15000));
  }
  finally {
    grid(0).events().stopLocalListen(lsnr,EVT_CACHE_OBJECT_LOCKED,EVT_CACHE_OBJECT_UNLOCKED);
  }
}
