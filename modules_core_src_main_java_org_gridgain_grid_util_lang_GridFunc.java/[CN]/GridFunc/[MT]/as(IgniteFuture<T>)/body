{
  A.notNull(fut,"fut");
  return new GridSerializableFuture<T>(){
    @Override public boolean cancel(    boolean mayInterruptIfRunning){
      if (mayInterruptIfRunning) {
        try {
          return fut.cancel();
        }
 catch (        GridException e) {
          throw new GridRuntimeException(e);
        }
      }
 else       return false;
    }
    @Override public boolean isCancelled(){
      return fut.isCancelled();
    }
    @Override public boolean isDone(){
      return fut.isDone();
    }
    @Override public T get() throws InterruptedException, ExecutionException {
      try {
        return fut.get();
      }
 catch (      GridFutureCancelledException ignore) {
        throw new CancellationException("The computation was cancelled.");
      }
catch (      GridInterruptedException ignore) {
        throw new InterruptedException("The computation was interrupted.");
      }
catch (      GridException e) {
        throw new ExecutionException("The computation failed.",e);
      }
    }
    @Override public T get(    long timeout,    @NotNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
      try {
        return fut.get(timeout,unit);
      }
 catch (      GridFutureCancelledException ignore) {
        throw new CancellationException("The computation was cancelled.");
      }
catch (      GridInterruptedException ignore) {
        throw new InterruptedException("The computation was interrupted.");
      }
catch (      GridFutureTimeoutException e) {
        throw new TimeoutException("The computation timed out: " + e.getMessage());
      }
catch (      GridException e) {
        throw new ExecutionException("The computation failed.",e);
      }
    }
  }
;
}
