{
  if (nodes.size() == 1)   return nodes;
  List<GridBiTuple<Long,GridNode>> lst=new ArrayList<>();
  MessageDigest d=digest.get();
  for (  GridNode node : nodes) {
    Object nodeHash=hashIdRslvr.resolve(node);
    try {
      ByteArrayOutputStream out=new ByteArrayOutputStream();
      byte[] nodeHashBytes=marshaller.marshal(nodeHash);
      out.write(nodeHashBytes,0,nodeHashBytes.length);
      out.write(U.intToBytes(part),0,4);
      d.reset();
      byte[] bytes=d.digest(out.toByteArray());
      long hash=(bytes[0] & 0xFFL) | ((bytes[1] & 0xFFL) << 8) | ((bytes[2] & 0xFFL) << 16)| ((bytes[3] & 0xFFL) << 24)| ((bytes[4] & 0xFFL) << 32)| ((bytes[5] & 0xFFL) << 40)| ((bytes[6] & 0xFFL) << 48)| ((bytes[7] & 0xFFL) << 56);
      lst.add(F.t(hash,node));
    }
 catch (    GridException e) {
      throw new GridRuntimeException(e);
    }
  }
  Collections.sort(lst,COMPARATOR);
  int primaryAndBackups=backups + 1;
  List<GridNode> res=new ArrayList<>(primaryAndBackups);
  GridNode primary=lst.get(0).get2();
  res.add(primary);
  for (int i=1; i < lst.size(); i++) {
    GridBiTuple<Long,GridNode> next=lst.get(i);
    GridNode node=next.get2();
    if (exclNeighbors) {
      Collection<GridNode> allNeighbors=allNeighbors(neighborhoodCache,res);
      if (!allNeighbors.contains(node))       res.add(node);
    }
 else {
      if (!res.contains(node) && (backupFilter == null || backupFilter.apply(primary,node)))       res.add(next.get2());
    }
    if (res.size() == primaryAndBackups)     break;
  }
  if (res.size() < primaryAndBackups && nodes.size() >= primaryAndBackups && exclNeighbors) {
    for (int i=1; i < lst.size(); i++) {
      GridBiTuple<Long,GridNode> next=lst.get(i);
      GridNode node=next.get2();
      if (!res.contains(node))       res.add(next.get2());
      if (res.size() == primaryAndBackups)       break;
    }
  }
  return res;
}
