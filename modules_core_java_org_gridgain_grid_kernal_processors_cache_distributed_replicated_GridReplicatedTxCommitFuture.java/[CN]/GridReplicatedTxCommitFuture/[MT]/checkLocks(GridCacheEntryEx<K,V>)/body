{
  if (log.isDebugEnabled())   log.debug("Transaction future received owner changed callback: " + entry);
  if (!tx.isRollbackOnly()) {
    if (!tx.pessimistic() && !commit.get() && !isDone()) {
      Collection<GridCacheTxEntry<K,V>> checkEntries=tx.groupLock() ? Collections.singletonList(tx.groupLockEntry()) : tx.writeEntries();
      for (      GridCacheTxEntry<K,V> txEntry : checkEntries) {
        while (true) {
          GridCacheEntryEx<K,V> cached=txEntry.cached();
          try {
            if (cached != entry && !locked(cached)) {
              if (log.isDebugEnabled())               log.debug("Transaction entry is not locked by transaction (will wait) [entry=" + cached + ", tx="+ tx+ ']');
              return;
            }
            break;
          }
 catch (          GridCacheEntryRemovedException ignored) {
            if (log.isDebugEnabled())             log.debug("Got removed entry in future onAllReplies method (will retry): " + txEntry);
            txEntry.cached(cctx.cache().entryEx(txEntry.key()),txEntry.keyBytes());
          }
        }
      }
    }
    commit();
  }
 else   rollback();
}
