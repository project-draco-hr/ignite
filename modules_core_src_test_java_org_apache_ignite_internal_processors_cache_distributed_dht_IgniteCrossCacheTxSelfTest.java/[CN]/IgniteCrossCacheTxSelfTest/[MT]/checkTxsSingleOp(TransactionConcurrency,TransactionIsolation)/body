{
  Map<Integer,String> firstCheck=new HashMap<>();
  Map<Integer,String> secondCheck=new HashMap<>();
  for (int i=0; i < TX_CNT; i++) {
    int grid=ThreadLocalRandom8.current().nextInt(nodeCount());
    IgniteCache<Integer,String> first=grid(grid).cache(FIRST_CACHE);
    IgniteCache<Integer,String> second=grid(grid).cache(SECOND_CACHE);
    try (Transaction tx=grid(grid).transactions().txStart(concurrency,isolation)){
      try {
        int size=ThreadLocalRandom8.current().nextInt(24) + 1;
        for (int k=0; k < size; k++) {
          boolean rnd=ThreadLocalRandom8.current().nextBoolean();
          IgniteCache<Integer,String> cache=rnd ? first : second;
          Map<Integer,String> check=rnd ? firstCheck : secondCheck;
          String val=rnd ? "first" + i : "second" + i;
          cache.put(k,val);
          check.put(k,val);
        }
        tx.commit();
      }
 catch (      Throwable e) {
        e.printStackTrace();
        throw e;
      }
    }
     if (i > 0 && i % 100 == 0)     info("Finished iteration: " + i);
  }
  for (int g=0; g < nodeCount(); g++) {
    IgniteEx grid=grid(g);
    assertEquals(0,grid.context().cache().context().tm().idMapSize());
    ClusterNode locNode=grid.localNode();
    IgniteCache<Object,Object> firstCache=grid.cache(FIRST_CACHE);
    for (    Map.Entry<Integer,String> entry : firstCheck.entrySet()) {
      boolean primary=grid.affinity(FIRST_CACHE).isPrimary(locNode,entry.getKey());
      boolean backup=grid.affinity(FIRST_CACHE).isBackup(locNode,entry.getKey());
      assertEquals("Invalid value found first cache [primary=" + primary + ", backup="+ backup+ ", node="+ locNode.id()+ ", key="+ entry.getKey()+ ']',entry.getValue(),firstCache.get(entry.getKey()));
    }
    for (    Map.Entry<Integer,String> entry : secondCheck.entrySet()) {
      boolean primary=grid.affinity(SECOND_CACHE).isPrimary(locNode,entry.getKey());
      boolean backup=grid.affinity(SECOND_CACHE).isBackup(locNode,entry.getKey());
      assertEquals("Invalid value found second cache [primary=" + primary + ", backup="+ backup+ ", node="+ locNode.id()+ ", key="+ entry.getKey()+ ']',entry.getValue(),grid.cache(SECOND_CACHE).get(entry.getKey()));
    }
  }
}
