{
  boolean hasSrvs=routers.isEmpty();
  final Collection<InetSocketAddress> connSrvs=(hasSrvs) ? new LinkedHashSet<>(srvs) : routers;
  if (hasSrvs) {
    try {
      for (      GridClientNodeImpl node : top.nodes()) {
        List<InetSocketAddress> endpoints=new ArrayList<>(node.availableAddresses(cfg.getProtocol()));
        final boolean emptyAttr=node.attributes().isEmpty();
        final boolean sameHost=emptyAttr || F.containsAny(U.allLocalMACs(),node.attribute(ATTR_MACS).toString().split(", "));
        if (sameHost)         Collections.sort(endpoints,GridClientUtils.inetSocketAddressesComparator(!emptyAttr));
 else         for (int i=endpoints.size() - 1; i >= 0; i--)         if (endpoints.get(i).getAddress().isLoopbackAddress())         endpoints.remove(i);
        connSrvs.addAll(endpoints);
      }
    }
 catch (    GridClientDisconnectedException ignored) {
    }
  }
  connMgr.init(connSrvs);
  Map<String,GridClientCacheMode> overallCaches=new HashMap<>();
  for (  GridClientNodeImpl node : top.nodes())   overallCaches.putAll(node.caches());
  for (  Map.Entry<String,GridClientCacheMode> entry : overallCaches.entrySet()) {
    GridClientDataAffinity affinity=affinity(entry.getKey());
    if (affinity instanceof GridClientPartitionAffinity && entry.getValue() != GridClientCacheMode.PARTITIONED)     log.warning(GridClientPartitionAffinity.class.getSimpleName() + " is used for a cache configured " + "for non-partitioned mode [cacheName="+ entry.getKey()+ ", cacheMode="+ entry.getValue()+ ']');
  }
}
