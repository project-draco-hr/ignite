{
  X.println(">>>");
  X.println(">>> Running test.");
  X.println(">>>");
  final AtomicLong putNum=new AtomicLong();
  final AtomicLong rmvNum=new AtomicLong();
  Thread timer=new Thread(new Runnable(){
    @Override public void run(){
      try {
        while (!Thread.currentThread().isInterrupted()) {
          long rmv=rmvNum.get();
          long put=putNum.get();
          if (args.evictionEnabled())           X.println("Put: " + put);
 else           X.println("Put: " + put + ", removed: "+ rmv);
          Thread.sleep(5000);
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
);
  timer.setDaemon(true);
  timer.start();
  int queueSize=100000;
  final BlockingQueue<Long> queue=new ArrayBlockingQueue<>(queueSize);
  if (!args.evictionEnabled()) {
    Thread rmvThread=new Thread(new Runnable(){
      @Override public void run(){
        try {
          for (long i=0; i < Long.MAX_VALUE; i++) {
            Long key=queue.take();
            cache.remove(key);
            rmvNum.set(key);
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
,"rmvThread");
    rmvThread.start();
  }
  for (long i=0; i < Long.MAX_VALUE; i++) {
    cache.put(i,i);
    putNum.set(i);
    if (!args.evictionEnabled()) {
      if (!queue.offer(i)) {
        while (!queue.isEmpty())         Thread.sleep(1000);
        X.println("Waited for the remover thread to empty the queue.");
        queue.offer(i);
      }
    }
  }
}
