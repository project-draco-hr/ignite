{
  if (!busyLock.enterBusy())   throw new IllegalStateException("Failed to execute query (grid is stopping).");
  try {
    String space=cctx.name();
    String type=qry.getType();
    String sqlQry=qry.getSql();
    Object[] params=qry.getArgs();
    TypeDescriptor typeDesc=typesByName.get(new TypeName(space,type));
    if (typeDesc == null || !typeDesc.registered())     throw new CacheException("Failed to find SQL table for type: " + type);
    final GridCloseableIterator<IgniteBiTuple<K,V>> i=idx.query(space,sqlQry,F.asList(params),typeDesc,idx.backupFilter(null));
    if (ctx.event().isRecordable(EVT_CACHE_QUERY_EXECUTED)) {
      ctx.event().record(new CacheQueryExecutedEvent<>(ctx.discovery().localNode(),"SQL query executed.",EVT_CACHE_QUERY_EXECUTED,CacheQueryType.SQL.name(),null,null,sqlQry,null,null,params,null,null));
    }
    return new ClIter<Cache.Entry<K,V>>(){
      @Override public void close() throws Exception {
        i.close();
      }
      @Override public boolean hasNext(){
        return i.hasNext();
      }
      @Override public Cache.Entry<K,V> next(){
        IgniteBiTuple<K,V> t=i.next();
        return new CacheEntryImpl<>(t.getKey(),t.getValue());
      }
      @Override public void remove(){
        throw new UnsupportedOperationException();
      }
    }
;
  }
 catch (  IgniteCheckedException e) {
    throw new IgniteException(e);
  }
 finally {
    busyLock.leaveBusy();
  }
}
