{
  idx.registerCache(ccfg);
  try {
    if (!F.isEmpty(ccfg.getQueryEntities())) {
      for (      QueryEntity qryEntity : ccfg.getQueryEntities()) {
        if (F.isEmpty(qryEntity.getValueType()))         throw new IgniteCheckedException("Value type is not set: " + qryEntity);
        TypeDescriptor desc=new TypeDescriptor();
        Class<?> keyCls=U.classForName(qryEntity.getKeyType(),Object.class);
        Class<?> valCls=U.classForName(qryEntity.getValueType(),null);
        String simpleValType=valCls == null ? typeName(qryEntity.getValueType()) : typeName(valCls);
        desc.name(simpleValType);
        if (ctx.cacheObjects().isPortableEnabled(ccfg)) {
          if (SQL_TYPES.contains(valCls))           desc.valueClass(valCls);
 else           desc.valueClass(Object.class);
          if (SQL_TYPES.contains(keyCls))           desc.keyClass(keyCls);
 else           desc.keyClass(Object.class);
        }
 else {
          if (keyCls == null)           throw new IgniteCheckedException("Failed to find key class in the node classpath " + "(use default marshaller to enable binary objects): " + qryEntity.getKeyType());
          if (valCls == null)           throw new IgniteCheckedException("Failed to find value class in the node classpath " + "(use default marshaller to enable binary objects) : " + qryEntity.getValueType());
          desc.valueClass(valCls);
          desc.keyClass(keyCls);
        }
        TypeId typeId;
        TypeId altTypeId=null;
        if (valCls == null || ctx.cacheObjects().isPortableEnabled(ccfg)) {
          processPortableMeta(qryEntity,desc);
          typeId=new TypeId(ccfg.getName(),ctx.cacheObjects().typeId(qryEntity.getValueType()));
          if (valCls != null)           altTypeId=new TypeId(ccfg.getName(),valCls);
        }
 else {
          processClassMeta(qryEntity,desc);
          typeId=new TypeId(ccfg.getName(),valCls);
          altTypeId=new TypeId(ccfg.getName(),ctx.cacheObjects().typeId(qryEntity.getValueType()));
        }
        addTypeByName(ccfg,desc);
        types.put(typeId,desc);
        if (altTypeId != null)         types.put(altTypeId,desc);
        desc.registered(idx.registerType(ccfg.getName(),desc));
      }
    }
    if (!F.isEmpty(ccfg.getTypeMetadata())) {
      for (      CacheTypeMetadata meta : ccfg.getTypeMetadata()) {
        if (F.isEmpty(meta.getValueType()))         throw new IgniteCheckedException("Value type is not set: " + meta);
        if (meta.getQueryFields().isEmpty() && meta.getAscendingFields().isEmpty() && meta.getDescendingFields().isEmpty()&& meta.getGroups().isEmpty())         continue;
        TypeDescriptor desc=new TypeDescriptor();
        Class<?> keyCls=U.classForName(meta.getKeyType(),Object.class);
        Class<?> valCls=U.classForName(meta.getValueType(),null);
        desc.name(meta.getSimpleValueType());
        if (ctx.cacheObjects().isPortableEnabled(ccfg)) {
          if (SQL_TYPES.contains(valCls))           desc.valueClass(valCls);
 else           desc.valueClass(Object.class);
          if (SQL_TYPES.contains(keyCls))           desc.keyClass(keyCls);
 else           desc.keyClass(Object.class);
        }
 else {
          desc.valueClass(valCls);
          desc.keyClass(keyCls);
        }
        TypeId typeId;
        TypeId altTypeId=null;
        if (valCls == null || ctx.cacheObjects().isPortableEnabled(ccfg)) {
          processPortableMeta(meta,desc);
          typeId=new TypeId(ccfg.getName(),ctx.cacheObjects().typeId(meta.getValueType()));
          if (valCls != null)           altTypeId=new TypeId(ccfg.getName(),valCls);
        }
 else {
          processClassMeta(meta,desc);
          typeId=new TypeId(ccfg.getName(),valCls);
          altTypeId=new TypeId(ccfg.getName(),ctx.cacheObjects().typeId(meta.getValueType()));
        }
        addTypeByName(ccfg,desc);
        types.put(typeId,desc);
        if (altTypeId != null)         types.put(altTypeId,desc);
        desc.registered(idx.registerType(ccfg.getName(),desc));
      }
    }
  }
 catch (  IgniteCheckedException|RuntimeException e) {
    idx.unregisterCache(ccfg);
    throw e;
  }
}
