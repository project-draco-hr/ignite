{
  idx.registerCache(ccfg);
  try {
    if (!F.isEmpty(ccfg.getTypeMetadata())) {
      for (      CacheTypeMetadata meta : ccfg.getTypeMetadata()) {
        if (F.isEmpty(meta.getValueType()))         throw new IgniteCheckedException("Value type is not set: " + meta);
        TypeDescriptor desc=new TypeDescriptor();
        Class<?> valCls=U.classForName(meta.getValueType(),null);
        desc.name(valCls != null ? typeName(valCls) : meta.getValueType());
        desc.valueClass(valCls != null ? valCls : Object.class);
        desc.keyClass(meta.getKeyType() == null ? Object.class : U.classForName(meta.getKeyType(),Object.class));
        TypeId typeId;
        if (valCls == null || ctx.cacheObjects().isPortableEnabled()) {
          processPortableMeta(meta,desc);
          typeId=new TypeId(ccfg.getName(),ctx.cacheObjects().typeId(meta.getValueType()));
        }
 else {
          processClassMeta(meta,desc);
          typeId=new TypeId(ccfg.getName(),valCls);
        }
        addTypeByName(ccfg,desc);
        types.put(typeId,desc);
        desc.registered(idx.registerType(ccfg.getName(),desc));
      }
    }
    Class<?>[] clss=ccfg.getIndexedTypes();
    if (!F.isEmpty(clss)) {
      for (int i=0; i < clss.length; i+=2) {
        Class<?> keyCls=clss[i];
        Class<?> valCls=clss[i + 1];
        TypeDescriptor desc=processKeyAndValueClasses(keyCls,valCls);
        addTypeByName(ccfg,desc);
        types.put(new TypeId(ccfg.getName(),valCls),desc);
        desc.registered(idx.registerType(ccfg.getName(),desc));
      }
    }
  }
 catch (  IgniteCheckedException|RuntimeException e) {
    idx.unregisterCache(ccfg);
    throw e;
  }
}
