{
  idx.registerCache(ccfg);
  if (!F.isEmpty(ccfg.getTypeMetadata())) {
    for (    CacheTypeMetadata meta : ccfg.getTypeMetadata()) {
      if (F.isEmpty(meta.getValueType()))       throw new IgniteCheckedException("Value type is not set: " + meta);
      TypeDescriptor desc=new TypeDescriptor(ccfg);
      Class<?> valCls=U.classForName(meta.getValueType(),null);
      desc.name(valCls != null ? typeName(valCls) : meta.getValueType());
      desc.valueClass(valCls != null ? valCls : Object.class);
      desc.keyClass(meta.getKeyType() == null ? Object.class : U.classForName(meta.getKeyType(),Object.class));
      TypeId typeId;
      if (valCls == null || ctx.cacheObjects().isPortableClass(valCls)) {
        processPortableMeta(meta,desc);
        typeId=new TypeId(ccfg.getName(),ctx.cacheObjects().typeId(meta.getValueType()));
      }
 else {
        processClassMeta(meta,desc);
        typeId=new TypeId(ccfg.getName(),valCls);
      }
      desc.registered(idx.registerType(ccfg.getName(),desc));
      typesByName.put(new TypeName(ccfg.getName(),desc.name()),desc);
      types.put(typeId,desc);
    }
  }
  Class<?>[] clss=ccfg.getIndexedTypes();
  if (!F.isEmpty(clss)) {
    for (int i=0; i < clss.length; i+=2) {
      Class<?> keyCls=clss[i];
      Class<?> valCls=clss[i + 1];
      TypeDescriptor desc=processKeyAndValueClasses(ccfg,keyCls,valCls);
      desc.registered(idx.registerType(ccfg.getName(),desc));
      typesByName.put(new TypeName(ccfg.getName(),desc.name()),desc);
      types.put(new TypeId(ccfg.getName(),valCls),desc);
    }
  }
}
