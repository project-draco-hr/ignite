{
  A.notEmpty(entries,"entries");
  enterBusy();
  try {
    GridFutureAdapter<Object> resFut=new GridFutureAdapter<>(ctx);
    activeFuts.add(resFut);
    resFut.listenAsync(rmvActiveFut);
    Collection<K> keys=new GridConcurrentHashSet<>(entries.size(),1.0f,16);
    if (isRequireSerializable && !entries.isEmpty() && !(entries.iterator().next() instanceof Serializable))     entries=F.transform(entries,new C1<Map.Entry<K,V>,Map.Entry<K,V>>(){
      @Override public Map.Entry<K,V> apply(      Map.Entry<K,V> o){
        return new Entry0<>(o.getKey(),o.getValue());
      }
    }
);
    for (    Map.Entry<K,V> entry : entries) {
      keys.add(entry.getKey());
      if (portableEnabled)       entry.setValue((V)ctx.portable().marshalToPortable(entry.getValue()));
    }
    load0(entries,resFut,keys,0);
    return resFut;
  }
 catch (  GridRuntimeException e) {
    return new GridFinishedFuture<>(ctx,e);
  }
 finally {
    leaveBusy();
  }
}
