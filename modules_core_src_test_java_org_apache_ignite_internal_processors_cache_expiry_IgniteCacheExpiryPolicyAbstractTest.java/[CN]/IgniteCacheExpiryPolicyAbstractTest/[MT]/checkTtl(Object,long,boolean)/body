{
  boolean found=false;
  for (int i=0; i < gridCount(); i++) {
    IgniteKernal grid=(IgniteKernal)grid(i);
    GridCacheAdapter<Object,Object> cache=grid.context().cache().internalCache();
    if (cache.context().isNear())     cache=cache.context().near().dht();
    while (true) {
      try {
        GridCacheEntryEx e=memoryMode() == CacheMemoryMode.ONHEAP_TIERED ? cache.peekEx(key) : cache.entryEx(key);
        if (e != null && e.deleted()) {
          assertEquals(0,e.ttl());
          assertFalse("Invalid entry [e=" + e + ", node="+ i+ ']',cache.affinity().isPrimaryOrBackup(grid.localNode(),key));
          continue;
        }
        if (e == null)         assertTrue("Not found " + key,!cache.affinity().isPrimaryOrBackup(grid.localNode(),key));
 else {
          e.unswap();
          found=true;
          if (wait)           waitTtl(cache,key,ttl);
          boolean primary=cache.affinity().isPrimary(grid.localNode(),key);
          boolean backup=cache.affinity().isBackup(grid.localNode(),key);
          assertEquals("Unexpected ttl [grid=" + i + ", nodeId="+ grid.getLocalNodeId()+ ", key="+ key+ ", e="+ e+ ", primary="+ primary+ ", backup="+ backup+ ']',ttl,e.ttl());
          if (ttl > 0)           assertTrue(e.expireTime() > 0);
 else           assertEquals(0,e.expireTime());
        }
        break;
      }
 catch (      GridCacheEntryRemovedException ignore) {
        info("RETRY");
      }
catch (      GridDhtInvalidPartitionException ignore) {
        break;
      }
    }
  }
  assertTrue(found);
}
