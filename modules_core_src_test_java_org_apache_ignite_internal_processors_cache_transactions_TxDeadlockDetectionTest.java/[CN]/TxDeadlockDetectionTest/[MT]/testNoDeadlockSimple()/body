{
  final AtomicInteger threadCnt=new AtomicInteger();
  final AtomicBoolean deadlock=new AtomicBoolean();
  final AtomicBoolean timedOut=new AtomicBoolean();
  final CyclicBarrier barrier=new CyclicBarrier(2);
  final long timeout=500;
  IgniteInternalFuture<Long> fut=GridTestUtils.runMultiThreadedAsync(new Runnable(){
    @Override public void run(){
      int threadNum=threadCnt.getAndIncrement();
      Ignite ignite=ignite(threadNum);
      IgniteCache<Integer,Integer> cache=ignite.cache(CACHE);
      try (Transaction tx=ignite.transactions().txStart(PESSIMISTIC,REPEATABLE_READ,timeout,0)){
        int key=42;
        if (log.isDebugEnabled())         log.debug(">>> Performs put [node=" + ((IgniteKernal)ignite).localNode() + ", tx="+ tx+ ", key="+ key+ ']');
        cache.put(key,0);
        barrier.await(timeout + 1000,TimeUnit.MILLISECONDS);
        tx.commit();
      }
 catch (      Exception e) {
        if (hasCause(e,TransactionTimeoutException.class))         timedOut.set(true);
        if (hasCause(e,TransactionDeadlockException.class))         deadlock.set(true);
      }
    }
  }
,2,"tx-thread");
  fut.get();
  assertTrue(timedOut.get());
  assertFalse(deadlock.get());
  checkDetectionFuts();
}
