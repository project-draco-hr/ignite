{
  for (int i=2; i <= 10; i++) {
    final int threads=i;
    log.info(">>> Test with " + threads + " transactions.");
    final AtomicInteger threadCnt=new AtomicInteger();
    final AtomicBoolean deadlock=new AtomicBoolean();
    final AtomicBoolean timedOut=new AtomicBoolean();
    final CyclicBarrier barrier=new CyclicBarrier(threads);
    final long timeout=500;
    IgniteInternalFuture<Long> fut=GridTestUtils.runMultiThreadedAsync(new Runnable(){
      @Override public void run(){
        int threadNum=threadCnt.incrementAndGet();
        Ignite ignite=ignite(threadNum % NODES_CNT);
        IgniteCache<Integer,Integer> cache=ignite.cache(CACHE);
        try (Transaction tx=ignite.transactions().txStart(PESSIMISTIC,REPEATABLE_READ,timeout,0)){
          int key1=threadNum;
          log.info(">>> Performs put [node=" + ((IgniteKernal)ignite).localNode() + ", tx="+ tx+ ", key="+ key1+ ']');
          cache.put(key1,0);
          barrier.await();
          if (threadNum == threads) {
            log.info(">>> Performs sleep. [node=" + ((IgniteKernal)ignite).localNode() + ", tx="+ tx+ ']');
            U.sleep(timeout * 2);
          }
 else {
            int key2=threadNum + 1;
            log.info(">>> Performs put [node=" + ((IgniteKernal)ignite).localNode() + ", tx="+ tx+ ", key2="+ key2+ ']');
            cache.put(key2,1);
          }
          tx.commit();
        }
 catch (        Exception e) {
          if (hasCause(e,TransactionTimeoutException.class))           timedOut.set(true);
          if (hasCause(e,TransactionDeadlockException.class))           deadlock.set(true);
        }
      }
    }
,threads,"tx-thread");
    fut.get();
    assertTrue(timedOut.get());
    assertFalse(deadlock.get());
    checkDetectionFuts();
  }
}
